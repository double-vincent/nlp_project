,readme_txt,language
0,"














Install
Usage
Game
Check schedule
Options
-d <date> or --date <date>
-y or --yesterday
-t or --today
-T or --tomorrow
-n or --networks
Pregame
Live
Final
Filter
Options
-f or --filter
Player
Options
-i or --info
-r or --regular
-p or --playoffs
-c or --compare
Mixed them all
Development
Related repo:
License





README.md















The finest NBA CLI.

Watch NBA live play-by-play, game preview, box score and player information on your console.
Best CLI tool for those who are both NBA fans and Engineers.
All data comes from stats.nba.com APIs.
Install
In order to use nba-go, make sure that you have Node version 6.0.0 or higher.
$ npm install -g nba-go

Or in a Docker Container:
$ docker build -t nba-go:latest .
$ docker run -it nba-go:latest

By default, the docker container will run nba-go game -t, but you can
override this command at run time.
For example:
$ docker run -it nba-go:latest nba-go player Curry -i

Or download the latest version pkg binaries in releases. It can be run on Linux, macOs and Windows.
For example:
./nba-go-macos game -h

Usage
nba-go provides two main commands.

game or g
player or p

Game
There are two things to do.

Check schedule.
Choose one game which you want to watch.

Depending on the status of the game you chose, a different result will be shown. There are three kinds of statuses that may be displayed.



Status
Example
Description




Pregame

It shows when the game starts.  Selecting this will show the comparison between two teams, including average points, field goal percents, average assists, etc.


Live

It shows live game clock.  Most powerful feature! Selecting this will show the live page which includes scoreboard, play-by-play and box score.


Final

Selecting this will show scoreboard, detailed box score, etc.



Check schedule
In order to show the schedule on some days, nba-go provides the command nba-go game with some options.
Options
-d <date> or --date <date>
Enter a specific date to check the schedule on that day.
$ nba-go game -d 2017/11/02


-y or --yesterday
Check yesterday's schedule.
$ nba-go game -y


-t or --today
Check today's schedule.
$ nba-go game -t


-T or --tomorrow
Check tomorrow's schedule.
$ nba-go game -T


-n or --networks
Display on schedule home team and away team television network information.
$ nba-go game -n

Pregame
⭐️⭐️
Check the detailed comparison data between two teams in the game.

Live
⭐️⭐️⭐️
Best feature! Realtime updated play-by-play, scoreboard and box score. Turn on fullscreen mode for better experience.
Btw, play-by-play is scrollable!.

Final
⭐️⭐️
Check two teams' detailed scoreboard and box score.

Filter
Filter results to quickly jump to the info you care about
Options
-f or --filter
Currently only supports filtering the results by team but more options on the way
nba-go game --filter team=Detroit

Player
Get player's basic information, regular season data and playoffs data.
Note. Must place player's name between nba-go player and options.
Options
-i or --info
Get player's basic information.
$ nba-go player Curry -i


-r or --regular
Get player's basic information.
$ nba-go player Curry -r


-p or --playoffs
Get player's basic information.
$ nba-go player Curry -p


-c or --compare
Get and compare the stats from multiple players. The better stat will be highlighted in green to make comparing easier.
When listing the multiple names they must be in quotes and seperated by commas. Can be combined with the -i, -r, and -p flags.
$ nba-go player ""Lebron James, Stephen Curry, James Harden"" -c -i -r -p


Mixed them all
Get all data at the same time.
$ nba-go player Curry -i -r -p


Development

It's simple to run nba-go on your local computer.
The following is step-by-step instruction.

$ git clone https://github.com/xxhomey19/nba-go.git
$ cd nba-go
$ yarn
$ NODE_ENV=development node bin/cli.js <command>

Related repo:

nba-bar
watch-nba
nba-color

License
MIT © xxhomey19


",JavaScript
1,"














🐔🐔🐔JetPackMvvm
演示Demo
效果图展示
APK下载：
1.如何集成
2.继承基类
3.编写一个登录功能
4.网络请求（Retrofit+协程）
注意：使用该请求方式时需要注意，如果该ViewModel并不是跟Activity/Fragment绑定的泛型ViewModel，而是
addLoadingObserve(viewModel)
4.4 开启打印日志开关
5.获取ViewModel
6.写了一些常用的拓展函数
7.混淆
联系
License





README.md




  
🐔🐔🐔JetPackMvvm

基于MVVM模式集成谷歌官方推荐的JetPack组件库：LiveData、ViewModel、Lifecycle、Navigation组件
使用kotlin语言，添加大量拓展函数，简化代码
加入Retrofit网络请求,协程，帮你简化各种操作，让你快速请求网络

演示Demo
已用该库重构了我之前的玩安卓项目，利用Navigation组件以单Activity+Fragment架构编写，优化了很多代码，对比之前的mvp项目，开发效率与舒适度要提高了不少，想看之前MVP的项目可以去 https://github.com/hegaojian/WanAndroid
效果图展示

APK下载：


Github下载


firm下载(推荐)


扫码下载(推荐)



1.如何集成

1.1 在root's build.gradle中加入Jitpack仓库

allprojects {
    repositories {
        ...
        maven { url 'https://jitpack.io' }
    }
}

1.2 在app's build.gradle中添加依赖

dependencies {
  ...
  implementation 'com.github.hegaojian:JetpackMvvm:1.2.7'
}

1.3 在app's build.gradle中，android 模块下按需开启DataBinding与ViewBinding

AndroidStudio 4.0 以下版本------>
android {
    ...
    dataBinding {
        enabled = true 
    }
    viewBinding {
        enabled = true
    }
}

AndroidStudio 4.0及以上版本 ------>
android {
    ...
   buildFeatures {
        dataBinding = true
        viewBinding = true
    }
}
 
2.继承基类
一般我们项目中都会有一套自己定义的符合业务需求的基类 BaseActivity/BaseFragment，所以我们的基类需要继承本框架的Base类

不想用Databinding与ViewBinding-------可以继承 BaseVmActivity/BaseVmFragment
用Databinding-----------可以继承BaseVmDbActivity/BaseVmDbFragment**
用Viewbinding-----------可以继承BaseVmVbActivity/BaseVmVbFragment**

Activity：
abstract class BaseActivity<VM : BaseViewModel, DB : ViewDataBinding> : BaseVmDbActivity<VM, DB>() {
     /**
     * 当前Activity绑定的视图布局Id abstract修饰供子类实现
     */
    abstract override fun layoutId(): Int
    /**
     * 当前Activityc创建后调用的方法 abstract修饰供子类实现
     */
    abstract override fun initView(savedInstanceState: Bundle?)

    /**
     * 创建liveData数据观察
     */
    override override fun createObserver()


    /**
     * 打开等待框 在这里实现你的等待框展示
     */
    override fun showLoading(message: String) {
       ...
    }

    /**
     * 关闭等待框 在这里实现你的等待框关闭
     */
    override fun dismissLoading() {
       ...
    }
}
Fragment：
abstract class BaseFragment<VM : BaseViewModel,DB:ViewDataBinding> : BaseVmDbFragment<VM,DB>() {
   
    abstract override fun initView(savedInstanceState: Bundle?)

    /**
     * 懒加载 只有当前fragment视图显示时才会触发该方法 abstract修饰供子类实现
     */
    abstract override fun lazyLoadData()

    /**
     * 创建liveData数据观察 懒加载之后才会触发
     */
    override override fun createObserver()
  
    /**
     * Fragment执行onViewCreated后触发的方法 
     */
    override fun initData() {

    }
    
   /**
     * 打开等待框 在这里实现你的等待框展示
     */
    override fun showLoading(message: String) {
       ...
    }

    /**
     * 关闭等待框 在这里实现你的等待框关闭
     */
    override fun dismissLoading() {
       ...
    }
}
3.编写一个登录功能

3.1 创建LoginViewModel类继承BaseViewModel

class LoginViewModel : BaseViewModel() {
  
}

3.2 创建LoginFragment 继承基类传入相关泛型,第一个泛型为你创建的LoginViewModel,第二个泛型为ViewDataBind，保存fragment_login.xml后databinding会生成一个FragmentLoginBinding类。（如果没有生成，试着点击Build->Clean Project）

class LoginFragment : BaseFragment<LoginViewModel, FragmentLoginBinding>() {
    
    /**
     *  初始化操作
     */
    override fun initView(savedInstanceState: Bundle?) {
        ...
    }
    
    /**
     *  fragment 懒加载
     */
    override fun lazyLoadData() { 
        ...
    }
}
4.网络请求（Retrofit+协程）

4.1 新建请求配置类继承 BaseNetworkApi 示例：

class NetworkApi : BaseNetworkApi() {

   companion object {
         
        val instance: NetworkApi by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) { NetworkApi() }

        //双重校验锁式-单例 封装NetApiService 方便直接快速调用
        val service: ApiService by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {
            instance.getApi(ApiService::class.java, ApiService.SERVER_URL)
        }
    }
   
    /**
     * 实现重写父类的setHttpClientBuilder方法，
     * 在这里可以添加拦截器，可以对 OkHttpClient.Builder 做任意你想要做的骚操作
     */
    override fun setHttpClientBuilder(builder: OkHttpClient.Builder): OkHttpClient.Builder {
        builder.apply {
            //示例：添加公共heads，可以存放token，公共参数等， 注意要设置在日志拦截器之前，不然Log中会不显示head信息
            addInterceptor(MyHeadInterceptor())
            // 日志拦截器
            addInterceptor(LogInterceptor())
            //超时时间 连接、读、写
            connectTimeout(10, TimeUnit.SECONDS)
            readTimeout(5, TimeUnit.SECONDS)
            writeTimeout(5, TimeUnit.SECONDS)
        }
        return builder
    }

    /**
     * 实现重写父类的setRetrofitBuilder方法，
     * 在这里可以对Retrofit.Builder做任意骚操作，比如添加GSON解析器，protobuf等
     */
    override fun setRetrofitBuilder(builder: Retrofit.Builder): Retrofit.Builder {
        return builder.apply {
            addConverterFactory(GsonConverterFactory.create(GsonBuilder().create()))
            addCallAdapterFactory(CoroutineCallAdapterFactory())
        }
    }
}

4.2如果你请求服务器返回的数据有基类（没有可忽略这一步）例如:

{
    ""data"": ...,
    ""errorCode"": 0,
    ""errorMsg"": """"
}
该示例格式是 玩Android Api返回的数据格式，如果errorCode等于0 请求成功，否则请求失败
作为开发者的角度来说，我们主要是想得到脱壳数据-data，且不想每次都判断errorCode==0请求是否成功或失败
这时我们可以在服务器返回数据基类中继承BaseResponse，实现相关方法：
data class ApiResponse<T>(var errorCode: Int, var errorMsg: String, var data: T) : BaseResponse<T>() {

    // 这里是示例，wanandroid 网站返回的 错误码为 0 就代表请求成功，请你根据自己的业务需求来编写
    override fun isSucces() = errorCode == 0

    override fun getResponseCode() = errorCode

    override fun getResponseData() = data

    override fun getResponseMsg() = errorMsg

}

4.3 在ViewModel中发起请求，所有请求都是在viewModelScope中启动，请求会发生在IO线程，最终回调在主线程上，当页面销毁的时候，请求会统一取消，不用担心内存泄露的风险，框架做了2种请求使用方式

1、将请求数据包装给ResultState，在Activity/Fragment中去监听ResultState拿到数据做处理
class RequestLoginViewModel: BaseViewModel {

  //自动脱壳过滤处理请求结果，自动判断结果是否成功
    var loginResult = MutableLiveData<ResultState<UserInfo>>()
    
  //不用框架帮脱壳
    var loginResult2 = MutableLiveData<ResultState<ApiResponse<UserInfo>>>()
    
  fun login(username: String, password: String){
   //1.在 Activity/Fragment的监听回调中拿到已脱壳的数据（项目有基类的可以用）
        request(
            { HttpRequestCoroutine.login(username, password) }, //请求体
            loginResult,//请求的结果接收者，请求成功与否都会改变该值，在Activity或fragment中监听回调结果，具体可看loginActivity中的回调
            true,//是否显示等待框，，默认false不显示 可以默认不传
            ""正在登录中...""//等待框内容，可以默认不填请求网络中...
        )
        
   //2.在Activity/Fragment中的监听拿到未脱壳的数据，你可以自己根据code做业务需求操作（项目没有基类的可以用）
        requestNoCheck(
          {HttpRequestCoroutine.login(username,password)},
          loginResult2,
          true,
          ""正在登录中..."") 
}


class LoginFragment : BaseFragment<LoginViewModel, FragmentLoginBinding>() {
    
    private val requestLoginRegisterViewModel: RequestLoginRegisterViewModel by viewModels()
    
    /**
     *  初始化操作
     */
    override fun initView(savedInstanceState: Bundle?) {
        ...
    }
    
    /**
     *  fragment 懒加载
     */
    override fun lazyLoadData() { 
        ...
    }
    
    override fun createObserver(){
      //脱壳
       requestLoginRegisterViewModel.loginResult.observe(viewLifecycleOwner,
            Observer { resultState ->
                parseState(resultState, {
                    //登录成功 打印用户
                    it.username.logd()
                }, {
                    //登录失败(网络连接问题，服务器的结果码不正确...异常都会走在这里)
                    showMessage(it.errorMsg)
                })
            })
    
       //不脱壳
       requestLoginRegisterViewModel.loginResult2.observe(viewLifecycleOwner, Observer {resultState ->
               parseState(resultState,{
                   if(it.errorCode==0){
                       //登录成功 打印用户名
                       it.data.username.logd()
                   }else{
                       //登录失败
                       showMessage(it.errorMsg)
                   }
               },{
                   //请求发生了异常
                   showMessage(it.errorMsg)
               })
           })
   } 
}
2、 直接在当前ViewModel中拿到请求结果
class RequestLoginViewModel : BaseViewModel() {
    
  fun login(username: String, password: String){
   //1.拿到已脱壳的数据（项目有基类的可以用）
     request({HttpRequestCoroutine.login(username,password)},{
             //请求成功 已自动处理了 请求结果是否正常
             it.username.logd()
         },{
             //请求失败 网络异常，或者请求结果码错误都会回调在这里
             it.errorMsg.logd()
         },true,""正在登录中..."")
        
   //2.拿到未脱壳的数据，你可以自己根据code做业务需求操作（项目没有基类或者不想框架帮忙脱壳的可以用）
       requestNoCheck({HttpRequestCoroutine.login(username,password)},{
            //请求成功 自己拿到数据做业务需求操作
            if(it.errorCode==0){
                //结果正确
                it.data.username.logd()
            }else{
                //结果错误
                it.errorMsg.logd()
            }
        },{
            //请求失败 网络异常回调在这里
            it.errorMsg.logd()
        },true,""正在登录中..."")
}
 
注意：使用该请求方式时需要注意，如果该ViewModel并不是跟Activity/Fragment绑定的泛型ViewModel，而是
val mainViewModel:MainViewModel by viewModels()
或者
val mainViewModel：MainViewModel by activityViewModels()
获取的
如果请求时要弹出loading，你需要在Activity | Fragment中添加以下代码：
addLoadingObserve(viewModel)
4.4 开启打印日志开关
设置全局jetpackMvvmLog变量 是否打开请求日志，默认false不打印，如需要打印日志功能，请设值为 true
5.获取ViewModel

5.1我们的activity/fragment会有多个ViewModel，按传统的写法感觉有点累

 val mainViewModel = ViewModelProvider(this,
            ViewModelProvider.AndroidViewModelFactory(application)).get(MainViewModel::class.java)
**现在官方Ktx有拓展函数可以轻松调用
//在activity中获取当前Activity级别作用域的ViewModel
 private val mainViewModel:MainViewModel by viewModels()
 
//在activity中获取Application级别作用域的ViewModel（注，这个是本框架提供的，Application类继承框架的BaseApp才有用）
 private val mainViewModel by lazy { getAppViewModel<MainViewModel>()}

//在fragment中获取当前Fragment级别作用域的ViewModel
 private val mainViewModel:MainViewModel by viewModels()

//在fragment中获取父类Activity级别作用域的ViewModel
private val mainViewModel：MainViewModel by activityViewModels()

//在fragment中获取Application级别作用域的ViewModel（注，这个是本框架提供的，Application类继承框架的BaseApp才有用）
private val mainViewModel by lazy { getAppViewModel<MainViewModel>()}
6.写了一些常用的拓展函数
 算了不写了，这个不重要，想具体看的话可以在
 me.hgj.jetpackmvvm.ext.util
 me.hgj.jetpackmvvm.ext.view
 的包中看，反正你也可以自己写，按照自己的喜好与需求来
7.混淆
-keep class me.hgj.jetpackmvvm.**{*;}
################ ViewBinding & DataBinding ###############
-keepclassmembers class * implements androidx.viewbinding.ViewBinding {
  public static * inflate(android.view.LayoutInflater);
  public static * inflate(android.view.LayoutInflater, android.view.ViewGroup, boolean);
  public static * bind(android.view.View);
}
联系

QQ交流群：419581249

License
 Copyright 2019, hegaojian(何高建)       
  
   Licensed under the Apache License, Version 2.0 (the ""License"");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at 
 
       http://www.apache.org/licenses/LICENSE-2.0 

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an ""AS IS"" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



",Kotlin
2,"



README.md




Dunk

Dunk is a Dribbble client.


",Swift
3,"














Getting Started
Get a copy
Prerequisites
Hosting
Alternatives
Google Colab
Heroku
Project Structure
Features
Shot and Pose analysis
Shot counting
Pose analysis
Shot detection
Detection API
Detection model
Future plans





README.md

















🏀 Analyze basketball shots and shooting pose with machine learning!

This is an artificial intelligence application built on the concept of object detection. Analyze basketball shots by digging into the data collected from object detection. We can get the result by simply uploading files to the web App, or submitting a POST request to the API. Please check the features below. There are more features coming up! Feel free to follow.
All the data for the shooting pose analysis is calculated by implementing OpenPose. Please note that this is an implementation only for noncommercial research use only. Please read the LICENSE, which is exaclty same as the CMU's OpenPose License.
If your are interested in the concept of human pose estimation, I have written a research paper summary of OpenPose. Check it out!
Getting Started
These instructions will get you a copy of the project up and running on your local machine.
Get a copy
Get a copy of this project by simply running the git clone command.
git clone https://github.com/chonyy/AI-basketball-analysis.git

Prerequisites
Before running the project, we have to install all the dependencies from requirements.txt
pip install -r requirements.txt

Please note that you need a GPU with proper CUDA setup to run the video analysis, since a CUDA device is required to run OpenPose.
Hosting
Last, get the project hosted on your local machine with a single command.
python app.py



Alternatives
Google Colab

Thanks to hardik0. Now we can play around with it without a GPU machine!
Heroku
This project is also hosted on Heroku. However, the heavy computation of TensorFlow may cause Timeout error and crash the app (especially for video analysis). Therefore, hosting the project on your local machine is more preferable.
Please note that the shooting pose analysis won't be running on the Heroku hosted website, since a CUDA device is required to run OpenPose.
Project Structure



Features
This project has three main features, shot analysis, shot detection, detection API.
Shot and Pose analysis
Shot counting



Counting shooting attempts and missing, scoring shots from the input video.
Detection keypoints in different colors have different meanings listed below:

Blue: Detected basketball in normal status
Purple: Undetermined shot
Green: Shot went in
Red: Miss

Pose analysis



Implementing OpenPose to calculate the angle of elbow and knee during shooting.



Release angle and release time are calculated by all the data collected from shot analysis and pose analysis. Please note that there will be a relatively big error for the release time since it was calculated as the total time when the ball is in hand.
Shot detection



Detection will be shown on the image. The confidence and the coordinate of the detection will be listed below.
Detection API



Get the JSON response by submitting a POST request to (./detection_json) with ""image"" as KEY and input image as VALUE.
Detection model



The object detection model is trained with the Faster R-CNN model architecture, which includes pretrained weight on COCO dataset. Taking the configuration from the model architecture and train it on my own dataset.
Future plans

 Change the model to a more efficient YOLOv4
 Implement SORT Tracking algorithm to filter out false detection
 Improve the visual effect
 Improve the efficiency, making it executable on web app services.



",Python
4,"














通知 该项目已停止维护
WanAndroid
前言
实现的功能
APP下载
应用截图
项目中用到的开源库
素材来源
特别感谢
更新日志
v 1.0.9 (2019-12-6)
v 1.0.8 (2019-11-12)
v 1.0.7 (2019-10-18)
v 1.0.6 (2019-10-9)
v 1.0.5 (2019-9-28)
v 1.0.4 (2019-9-25)
v 1.0.3 (2019-9-11)
v 1.0.2 (2019-9-6)
v 1.0.1 (2019-9-6)
v 1.0.0 (2019-9-5)
License





README.md




  
通知 该项目已停止维护
已使用JetPack+MVVM重构该项目 新地址： https://github.com/hegaojian/JetpackMvvm
WanAndroid
一位练习时长两年半的安卓练习生根据鸿神提供的WanAndroid开放Api来制作的产品级App,基本实现了所有的功能，使用Kotlin语言，基于Material Design+AndroidX + MVP + RxJava + Retrofit等优秀的开源框架开发,注释超详细，方便大家练手
如果你觉得本项目做的还不错对你有帮助，容我卑微地向你要个star，有任何问题或建议，欢迎提交issues
前言
前段时间学习了 Kotlin ，于是打算写一个项目来练练手刷刷熟练度，因为经常逛鸿神的WanAndroid网站，觉得很不错，Api也很丰富健全， 虽然根据WanAndroidAPi开发出的app多如牛毛，有诸多优秀的app,但是每个人的喜好与审美不一样，所以都没有做到我心目中的最完美，于是我就想自己设计开发一个让自己觉得满意的玩安卓App。界面的话参考了一些市场上App的风格搭配实现
实现的功能

首页五大模块：首页 / 项目 / 体系/ 公众号 / 我的
登录注册功能
导航功能
搜索功能 热门搜索推荐 搜索历史记录
积分功能 积分排行 积分获取记录
收藏功能 收藏文章 收藏网址
待办清单 添加清单 编辑清单 删除清单
广场功能
发布自己的文章、查询、删除文章
文章网址详情 详情中收藏 分享 浏览器打开
全局修改应用主题色
全局修改列表的加载动画
文章在任何地方收藏与取消，其他界面相对应的数据也会变化
布局优化，大量使用ConstraintLayout
集成Bugly收集bug并实现App更新
全局捕捉异常防止崩溃

APP下载


GitHub下载


fir.im下载


小米应用市场下载


扫码



应用截图





项目中用到的开源库

一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的框架-RxJava2
一个依赖注入框架-Dagger2
处理网络请求的框架-Okhttp
一个基于OKHttp封装的网络加载框架-Retrofit
转换json数据的官方框架-Gson
Android的事件发布-Eventbus
项目核心库MVP框架-MVPArms
屏幕适配AndroidAutoSize
一个美丽的、流体和可扩展的对话框-Material-dialogs
一个强大的Fragment管理库-Fragmentation
一个增强BottomNavigationView的安卓库-BottomNavigationViewEx
强大、可定制、易扩展的 ViewPager 指示器框架-MagicIndicator
一个强大的轮播库-BGABanner-Android
一个强大并且灵活的RecyclerViewAdapter-BaseRecyclerViewAdapterHelper
RecyclerView侧滑菜单，Item拖拽，滑动删除Item，自动加载更多，HeaderView，FooterView，Item分组黏贴-SwipeRecyclerView
揭示效果布局-RevealLayout
优雅地处理加载中，重试，无数据-Loadsir
基于Android WebView的一个强大的库-Agentweb
Android流式布局-FlowLayout
基于mmap内存映射的移动端通用 key-value 组件-MMKV
全局捕捉异常防止崩溃-CustomActivityOnCrash

素材来源

阿里巴巴矢量图标库
借鉴了花瓣APP的登录页
个人中心界面借鉴
goweii项目中的Launch图标

特别感谢

感谢鸿洋大神提供的WanAndroid开放API，我在issues提了一些自己的需求，鸿神都耐心的帮忙添加了，谢谢

更新日志
v 1.0.9 (2019-12-6)

1.添加kotlin拓展函数，优化设置控件主题，跳转拦截代码
2.请求网络写法纠正，具体看#11

v 1.0.8 (2019-11-12)

1.添加Bugly校验
2.我的-加入我们 修改了群号为作者自己的
3.删除build中的signingConfigs编译信息

v 1.0.7 (2019-10-18)

1.添加积分规则
2.添加分享文章提示
3.修复5.1手机打开webview报错bug
4.修复recyclerview在加载更多时，点击会调用多次接口bug
5.升级gradle版本至3.5.1,SDK提升至29

v 1.0.6 (2019-10-9)

1.添加广场功能
2.自己的文章-删除、查询、添加
3.可以查看他人的信息
4.个人中心界面改版

v 1.0.5 (2019-9-28)

😍😍😍为祖国母亲庆生，添加国庆主题

v 1.0.4 (2019-9-25)

1.修复bug体系-广场中的列表数据没有显示作者
2.修复部分tab，标题，文本数据显示了网页标签bug
3.修改体系中tab位置起始位左侧显示

v 1.0.3 (2019-9-11)

1.修复部分手机登录注册返回主页后闪退的bug
2.暂时去掉侧滑功能，现在输入法出现的黑屏不好看，后面解决后再加上侧滑功能
3.添加全局捕捉异常库，防止崩溃
4.修复Bugly上的bug

v 1.0.2 (2019-9-6)

1.太粗心大意了，修复添加任务清单界面点击返回键无响应bug

v 1.0.1 (2019-9-6)

1.修复开源项目界面点击返回无反应bug

v 1.0.0 (2019-9-5)

首次提交，大致完成功能，但存在一些问题，后期慢慢解决吧
1.因为侧滑返回库的原因导致输入法弹出出现黑屏，实在不行就换个其他的库了
2.kotlin用的不是特别熟练，感觉很多地方还可以精简或者有其他更好的方案替代
3.启动页因为考虑到要根据用户选择的主题色来动态显示，就没有设置纯色背景，所以会导致冷启动时会出现短暂白屏

License
 Copyright 2019, hegaojian(何高建)       
  
   Licensed under the Apache License, Version 2.0 (the ""License"");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at 
 
       http://www.apache.org/licenses/LICENSE-2.0 

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an ""AS IS"" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



",Kotlin
5,"














nba
NOTES:
BLACKLISTED IP ADDRESSES:
CORS restrictions on browser usage
NBA API
Getting Started
Stability Warning
Usability
Documentation
Transport Layer
""I don't use Node.js""





README.md




nba
Node.js client for nba.com API endpoints
npm install nba
NOTES:
BLACKLISTED IP ADDRESSES:
It appears as though the NBA has blacklisted certain blocks of IP addresses, specifically those of cloud hosting providers including AWS. As such, you may hit a situation where an application using this package works fine on your local machine, but doesn't work at all when deployed to a cloud server. Annoyingly, requests from these IPs seem to just hang. More information here and here -- the second issue has a curl command somewhere which will quickly tell you if NBA is accepting requests from your IP. (Incidentally, this is also the same reason the TravisCI build is always ""broken"" but tests all pass locally). There is a simple pass-through server in scripts/proxy that can be used to get around this restriction; you can put the proxy server somewhere that can reach NBA.com (e.g. not on AWS or Heroku or similar) and host your actual application on a cloud provider.
CORS restrictions on browser usage
This package can't be used directly from the browser because of CORS restrictions imposed by nba.com. If you run some sort of intermediate server which relays requests to NBA.com, you can change the host the client points to by following the instructions in the Transport Layer section
NBA API
The stats.nba.com uses a large number of undocumented JSON endpoints to provide the statistics tables and charts displayed on that website. This library provides a JavaScript client for interacting with many of those API endpoints.
Getting Started
NBA.findPlayer(str) will return an object with a player's name, their ID, and their team information. This method is built into the package.
All methods in the NBA.stats namespace require an object to be passed in as a parameter. The keys to the object are in the docs for the stats namespace here
const NBA = require(""nba"");
const curry = NBA.findPlayer('Stephen Curry');
console.log(curry);
/* logs the following:
{
  firstName: 'Stephen',
  lastName: 'Curry',
  playerId: 201939,
  teamId: 1610612744,
  fullName: 'Stephen Curry',
  downcaseName: 'stephen curry'
}
*/
NBA.stats.playerInfo({ PlayerID: curry.playerId }).then(console.log);
For more example API calls, see /test/integration/stats.js and other test files.
Stability Warning
This is a client for an unstable and undocumented API. While I try to follow semver for changes to the JavaScript API this library exposes, the underlying HTTP API can (and has) changed without warning. In particular, the NBA has repeatedly deprecated endpoints, or added certain required headers without which requests will fail. Further, this library comes bundled with a (relatively) up-to-date list of current NBA players which is subject to change at any time -- the specific contents of it should not be considered part of this library's API contract.
Usability
To put it nicely, the NBA's API endpoints are a little clunky to work with. This library tries to strike a balance between being usable but not making assumptions about how the data will be used. Specifically, the NBA sends data in a concise ""table"" form where the column headers come first then each result is an array of values that need to be matched with the proper header. This library does a simple transformation to zip the header and values arrays into a header-keyed object. Beyond that, it tries to not do too much. This is important to note because sometimes the various ""result sets"" that come back on a single endpoint seem sort of arbitrary. The underlying HTTP API doesn't seem to follow standard REST practices; rather it seems the endpoints are tied directly to the data needed by specific tables and charts displayed on stats.nba.com. This is what I mean by ""clunky"" to work with -- it can be tricky to assemble the data you need for a specific analysis from the various endpoints available.
Documentation
still lots to do here...
There are four primary parts of this library

Top-level methods
stats namespace — docs
synergy namespace see tests
– data namespace see tests
~sportVu namespace~ NBA has removed sportVu endpoints. the methods exist here for backwards compatibility but they throw errors

Transport Layer
In some cases you will want to use a different transport layer to handle HTTP requests. Perhaps you have an HTTP client library you like better than what I used here. Better yet, you want to get stats for the WNBA or the G League. The following code snippet shows how to use the withTransport method to create a new client with your own transport function.
// here we are getting stats for the WNBA!

const nba = require(""nba"");
const getJSON = require(""nba/src/get-json"");

// for the G League, try ""stats.gleague.nba.com""
const newHost = ""stats.wnba.com"";

const transport = (url, params, options) => {
  // simply swap the host and then defer the rest to the built in getJSON function
  const fixedURL = url.replace(""stats.nba.com"", ""stats.wnba.com"");
  return getJSON(fixedURL, params, options);
};

// create a new stats client here with our WNBA transport
const wnbaStats = nba.stats.withTransport(transport);

(async () => {
  const result = await wnbaStats.playerInfo({ PlayerID: ""1628886"" });
  console.log(result);
})();
""I don't use Node.js""
Please take a look at nba-client-template. The relevant part of the repo is a single JSON document from which many programming languages can dynamically generate an API client. The repo contains (sloppy) examples in Ruby and Python. Compiled languages can use code generation techniques to the same effect -- there's a (again, sloppy) example in Go. If you'd like me to publish it to a specific registry so you can install it with your language's package manager, please open an issue. Please note, however, that package only includes  the endpoints exposed by this library under the stats namespace -- sportvu and synergy endpoints aren't yet included in it. I also plan to add a command-line interface to this library so that it can be easily driven as a child process by another program.



",JavaScript
6,"














🏀 SprintNBA
完整的NBA第三方Android客户端，包含NBA头条新闻、视频集锦/赛场花絮、比赛直播（目前支持比赛前瞻、文字直播、球队及球员技术统计、视频直播(企鹅推出了球队通、联盟通... 简直不能忍啊！！)）、球队战绩排行、球员数据排名、虎扑论坛专区（已实现发帖与回复功能）、球队及球员的详细资料。
声明
项目
重要更新
V2.0
V1.1
V1.0
下载
TODO
应用截图





README.md




🏀 SprintNBA
完整的NBA第三方Android客户端，包含NBA头条新闻、视频集锦/赛场花絮、比赛直播（目前支持比赛前瞻、文字直播、球队及球员技术统计、视频直播(企鹅推出了球队通、联盟通... 简直不能忍啊！！)）、球队战绩排行、球员数据排名、虎扑论坛专区（已实现发帖与回复功能）、球队及球员的详细资料。
声明
本项目部分API来自NBA中文官网与虎扑体育，纯练手之作，个人未从中获取任何利益，其所有内容均可在NBA中文官网与虎扑体育获取。数据的获取与共享可能会侵犯到NBA中文官网与虎扑体育的权益，若被告知需停止共享与使用，本人会立即删除整个项目。
项目
本项目采用 MaterialDesign + MVP + Retrofit2 开发。项目的大部分功能已经完成，并在百度手机助手等应用商店上架V1.1版本。目前正在不断完善中，喜欢的话不防给个star哈。
重要更新
V2.0

增加比赛视频直播
优化比赛视频直播的稳定性。支持换源

V1.1

由于腾讯视频对真实地址解析后播放进行了加密，故采用新方法进行真实地址解析，若遇到不可播放的视频，可点击右上角跳转到内嵌网页播放。
增强UI体验。修复一些bug
若初次体验V1.0 导致V1.1应用自动更新无法下载，则应到设置->应用->SprintNBA下，授予SD读写权限。

V1.0
初次版本，含NBA新闻、视频花絮、赛程及文字直播、技术统计、球队及球员数据排行、详细资料，虎扑论坛专区。
下载


APK本地下载：SprintNBA-2.0.apk


百度手机助手应用商店：SprintNBA-2.0


百度91无线：SprintNBA-2.0


安卓市场：SprintNBA-2.0


TODO

 代码优化
 虎扑论坛部分功能暂未完善
 单支球队赛程
 优化相关视频播放。腾讯视频真实地址提取功能不稳定，导致部分视频不能播放。
 部分BUG修复（有疑问欢迎提issue）

应用截图
友情提示：高清图片，耐心等待哟~~

头条新闻






比赛视频/赛场花絮






比赛相关








球队/球员 相关








虎扑论坛相关






其他




",Java
7,"











NBA Player Movements
Examples
Usage





README.md




NBA Player Movements
This is a script for visualization of NBA games from raw SportVU logs.
If you admire both Spurs' and Warriors' ball movement, Brad Stevens' playbook, or just miss KD in OKC you'll find this entertaining.
Examples




Usage

Clone this repo:

$ git clone https://github.com/linouk23/NBA-Player-Movements


Choose any NBA game from data/2016.NBA.Raw.SportVU.Game.Logs directory.


Generate an animation for the play by running the following script:


$ python3 main.py --path=Celtics@Lakers.json --event=140
required arguments:
  --path PATH    a path to json file to read the events from

optional arguments:
  --event EVENT  an index of the event to create the animation to
                 (the indexing start with zero, if you index goes beyond out
                 the total number of events (plays), it will show you the last
                 one of the game)
  -h, --help     show the help message and exit



",Python
8,"











react-native-basketball
Versioning
Installation
License





README.md




react-native-basketball
React-Native clone of the Facebook Basketball game

Versioning
For React Native 0.45.1
Installation

git clone https://github.com/FaridSafi/react-native-basketball
cd react-native-basketball && npm install
react-native run-ios

Feel free to ask me questions on Twitter @FaridSafi!
License
Licensed under the MIT


",JavaScript
9,"














Features
Tasks
📝 Demos and documentation
Yeoman generator
Need real-time help? Find us on Slack
🐛 Bugs and feature requests
Browser compatibility
Maintainers and contributors
Community
Contributing
Versioning
Sponsored by





readme.md






A lightweight front-end framework for creating scalable and performant, responsive sites

    
Developed and maintained by Ashley Nolan & Zander Martineau
Features




Feature
Description




⏩
#webperf
Performance-first, responsive philosophy


🚍
Rock-solid build tasks
We use gulp & webpack to deliver the best task runner & developer experience for your project


👓
Unopinionated & extendable
A few common UI elements, a grid & some other base styles. The rest is up to you.


🔮
Future proof
Build complex layouts with flexbox & use ES2015 (ES6) for your javascript.


😠
Lean & mean
CSS: 8.68 kB gzipped JS: 2 kB gzipped It is a boilerplate after all 😉



Tasks



Command
Description




npm start
Basic dev server using Browsersync


npm run watch
Watch all files for changes


npm run deploy
Install all dependencies and compile all assets for production deployment


npm run compile:all
Compile the CSS & JS, compress the images and run any other compilation tasks needed to run your app


npm run compile:release
Add the --release flag to any other task, e.g. gulp javascript --release or gulp css --release


npm run compile:css
Sass (Libsass via node-sass), Postcss with Autoprefixer, CSSNano, Source Maps & more..


npm run compile:js
Babel, Webpack


npm run compile:svg
Auto-generated SVG sprites


npm run compress:images
Image compression with imagemin


npm run lint:js
Lint JS using xo


npm run fix:js
Fix JS linting issues using xo


npm run lint:css
Lint CSS using stylelint. We use the https://github.com/stylelint/stylelint-config-standard rules for our linting


npm test
Run javascript and css tests


npm run clean:all
Clean the compiled files


npm run copy:all
Run the copy tasks - useful for things like webfonts etc


npm run release-patch
Creates a patch release using release-it


npm run release-minor
Creates a minor release using release-it


npm run release-major
Creates a major release using release-it


npm run release-premajor
Creates a premajor release using release-it




📝 Demos and documentation
Kickoff's demo and documentation site is hosted at trykickoff.com.

Yeoman generator
Our Yeoman Generator is the best way to get Kickoff each time you want to start a new project, visit trykickoff.com/docs/yeoman.html for more info.

 Need real-time help? Find us on Slack

🐛 Bugs and feature requests
Have a bug or a feature request? Please search for existing and closed issues. If your problem or idea is not addressed yet, please open a new issue.

Browser compatibility
Kickoff has been tested in the following browsers:



Chrome (latest)
Firefox (latest)
Safari (latest)
Edge (latest)
Opera (latest)












We also support older versions of Internet Explorer but the support is limited. For example, the Kickoff grid relies on flexbox so Modernizr is needed to detect for it and then we can provide a fallback.

Maintainers and contributors



Zander Martineau
Ashley Nolan
Nic Bell









Twitter
Twitter
Twitter


Github
Github
Github


Site
Site
Site



Community
If you're using Kickoff we'd love to hear about it; please e-mail us at trykickoff@gmail.com
Keep track of development and community news by following @TryKickoff on Twitter.
Contributing
Please read our contribution guidelines before contributing to Kickoff.
Versioning
For transparency into our release cycle and in striving to maintain backward compatibility, Kickoff is maintained under the Semantic Versioning guidelines. Sometimes we screw up, but we'll adhere to those rules whenever possible.

Sponsored by

Kickoff was created by Ash and Zander while working at TMW. TMW continue to provide sponsorship for the development of the project as well as trykickoff.com domain renewals, stickers etc.


",CSS
10,"











nba.js
Table of contents
Installation
Usage
Examples
Contribute
License





README.md




nba.js






A Node.js library for current and historical NBA stats, scores, and data.

Table of contents

Installation
Usage
Examples
Contribute
License

Full documentation and usage guide can be found here.
Installation
Install via npm.
$ npm install --save nba.js
Usage


This library provides access to data from 2 different APIs:

data.nba.net
stats.nba.com



For the full usage guide, see USAGE.md.


Method & parameter reference: nba.data,
nba.stats.


Examples
See EXAMPLES.md.
Contribute
This project is completely open source. Feel free to
open an issue or
make a pull request.
For more information, see CONTRIBUTING.md.
License
MIT © Kashav Madan.


",JavaScript
11,"











Documentation
Contributors





README.md


























Basketball Reference is a great site (especially for a basketball stats nut like me), and hopefully they don't get too pissed off at me for creating this.
I initially wrote this library as an exercise for creating my first PyPi package - hope you find it valuable!
Documentation
For documentation about installing the package and API methods see the documentation page.
Contributors
Thanks to @DaiJunyan, @ecallahan5,
@Yotamho, @ntsirakis, and @allanbelliti for their contributions!


",HTML
12,"











ESPN API
Installing
Usage
For Getting Started and API details head over to the Wiki!
Run Tests
Discussions (new)
Issue Reporting





README.md





   
ESPN API
This package uses ESPN's Fantasy API to extract data from any public or private league for Fantasy Football and Basketball (NHL, MLB, and WNBA are in development).
Please feel free to make suggestions, bug reports, and pull request for features or fixes!
This package was inspired and based off of rbarton65/espnff.
Installing
With Git:
git clone https://github.com/cwendt94/espn-api
cd espn-api
python3 setup.py install

With pip:
pip install espn_api

Usage
For Getting Started and API details head over to the Wiki!
# Football API
from espn_api.football import League
# Basketball API
from espn_api.basketball import League
# Hockey API
from espn_api.hockey import League
# Baseball API
from espn_api.baseball import League
# Init
league = League(league_id=222, year=2019)
Run Tests
python3 setup.py nosetests

Discussions (new)
If you have any questions about the package, ESPN API data, or want to talk about a feature please start a discussion!
Issue Reporting
If you find a bug follow the steps below for reporting.


Open a new issue with a brief description of the bug for the title. In the title also add which sport (Football or Basketball)


Run the application in debug mode to view ESPN API request's and response's
# ... import statement above
league = League(league_id=1245, year=2019, debug=True)
The application will print all requests and the response from ESPN's API in the console. I would suggest piping the console output to a text file as it will be a lot of data.


Find the last log before the crash and copy it in the issue descrption with the line number of the crash or possible bug.


Submit the new issue!


I will try to comment on the issue as soon as possible with my thoughts and possible fix!


",Python
13,"











🐔🐔🐔 这是一个快速开发的框架，使用Kotlin语言开发，MVVM+Jetpack架构，封装了公共头部、界面状态管理、ViewModel、LiveData、DataBinding、ViewBinding、头部刷新、加载更多、沉浸式、全局通知、丰富好用的拓展函数、RxHttp网络请求等等一系列工具
更详细的文档介绍 请看 WikiWikiWiki
1.如何集成
混淆





README.md




🐔🐔🐔 这是一个快速开发的框架，使用Kotlin语言开发，MVVM+Jetpack架构，封装了公共头部、界面状态管理、ViewModel、LiveData、DataBinding、ViewBinding、头部刷新、加载更多、沉浸式、全局通知、丰富好用的拓展函数、RxHttp网络请求等等一系列工具
更详细的文档介绍 请看 Wiki Wiki Wiki
clone慢的可以用 gitee链接 https://gitee.com/hegaojian/MvvmHelper
1.如何集成

**1.1 在root's build.gradle中加入 Jitpack 仓库 **

allprojects {
    repositories {
        ...
        maven { url 'https://jitpack.io' }
    }
}

1.2 在app's build.gradle中添加依赖

apply plugin: 'kotlin-kapt'

...

dependencies {
  ...
  implementation 'com.github.hegaojian:MvvmHelper:1.1.7'
  kapt 'com.github.liujingxing.rxhttp:rxhttp-compiler:2.9.3'
}

1.3 在app's build.gradle中，android 模块下开启DataBinding或者ViewBinding 可以自行选择

AndroidStudio 4.0 以下版本------>
android {
    ...
    dataBinding {
        enabled = true //可选 不用可以不写
    }
    viewBinding {
        enabled = true //可选 不用可以不写
    }
}

AndroidStudio 4.0及以上版本 ------>
android {
    ...
   buildFeatures {
        dataBinding = true //可选 不用可以不写
        viewBinding = true //可选 不用可以不写
    }
}
 

1.4 在Application中初始化

 MvvmHelper.init(this,BuildConfig.DEBUG)
混淆
-keepclassmembers class * implements androidx.viewbinding.ViewBinding {
  public static * inflate(android.view.LayoutInflater);
  public static * inflate(android.view.LayoutInflater, android.view.ViewGroup, boolean);
  public static * bind(android.view.View);
}


",Kotlin
14,"














Basketball GM, Football GM, ZenGM Baseball, and ZenGM Hockey
Development Info
License and Contributor License Agreement
Step 1 - Installing
Step 2 - Building
Step 3 - Running
1. Node.js (easiest)
2. Apache
Step 4 - Testing
Code Overview
Shared Worker Debugging
Service Worker
Git Workflow
Less Important Development Info
Sport-specific stuff
Thank you BrowserStack





README.md




Basketball GM, Football GM, ZenGM Baseball, and ZenGM Hockey
Single-player sports simulation games. Make trades, set rosters, draft players,
and try to build the next dynasty, all from within your web browser. The games
are implemented entirely in client-side JavaScript, backed by IndexedDB.
Copyright (C) ZenGM, LLC. All rights reserved.
Email: jeremy@zengm.com
Website: https://zengm.com/
Development: https://github.com/zengm-games/zengm
Discussion:

https://www.reddit.com/r/BasketballGM/
https://www.reddit.com/r/Football_GM/
https://www.reddit.com/r/ZenGMBaseball/
https://www.reddit.com/r/ZenGMHockey/
https://zengm.com/discord/

This project is NOT open source, but it is also not completely closed. Please
see LICENSE.md for details.
Development Info
If you just want to play the game, go to https://zengm.com/. Instructions
below are for developers who want to run a copy locally so they can make changes
to the code.
If you want to contribute but get stuck somewhere, please contact me! I'm happy
to help.
License and Contributor License Agreement
This project is NOT open source, but it is also not completely closed. Please
see LICENSE.md for details.
If you want to contribute code to this project, you must sign a contributor
license agreement. There are separate forms for individuals and entities (such
as corporations):

Individual CLA (this is probably what you want)
Entity CLA

Make a copy of the form, fill in your information at the bottom, and send an
email to jeremy@zengm.com with the subject line, ""Contributor License Agreement
from YOUR_NAME_HERE (GITHUB_USERNAME_HERE)"".
Step 1 - Installing
Make sure you're using a recent version of Node.js, older
versions probably won't work. Then, all of the tooling used in development can
be set up by simply installing Yarn 1 and
running:
yarn install

from within this folder.
Step 2 - Building
To build the app along with all its assets, run
yarn run build

However during development, you probably would rather do
yarn run start-watch

which will start the server and watch JS and CSS files for changes and
recompile. This simply runs both yarn run start and yarn run watch together,
which alternatively can be run separately if you wish.
By default this will build the basketball version of the game. For other sports,
set the SPORT environment variable to ""football"", ""baseball"", or ""hockey"", like:
SPORT=football yarn run start-watch

Open package.json to see all available development scripts.
Step 3 - Running
To run the game locally, you need some way of running a web server to display
the content. There are currently two ways to do it. It doesn't matter which you
use as long as you can get it to run on your computer.
1. Node.js (easiest)
Run
yarn run start

and point your browser to http://localhost:3000/. If you use the command yarn run start-watch from above, then running the command yarn run start is not
necessary.
2. Apache
The mod_rewrite rules in .htaccess let the game run in Apache. Everything
should work if you point it at the build folder with mod_rewrite enabled.
Step 4 - Testing
TypeScript and ESLint are used to enforce some coding standards. To run them on
the entire codebase, run
yarn run lint

Integration and unit tests spread out through the codebase in *.test.ts files.
Coverage is not great. They can be run from the command line with
yarn test

There is also a single end-to-end test which creates a league and simulates a
season. To execute the end-to-end test, run
yarn run test-e2e

For the end-to-end test, by default it is basketball. If you want it to do
football, stick SPORT=football  in front.
Code Overview
This is a single-page app that runs almost entirely client-side by storing data
in IndexedDB. The core of the game runs inside a Shared Worker (or a Web Worker
in crappy browsers that don't support Shared Workers), and then each open tab
runs only UI code that talks to the worker. The UI code is in the src/ui
folder and the core game code is in the src/worker folder. They communicate
through the toUI and toWorker functions.
The UI is built with React and Bootstrap.
In the worker, data is ultimately stored in IndexedDB, but for performance and
cross-browser compatibility reasons, a cache (implemented in
src/worker/db/Cache.ts) sits on top of the database containing all commonly
accessed data. The idea is that IndexedDB should only be accessed for uncommon
situations, like viewing stats from past seasons. For simulating games and
viewing current data, only the cache should be necessary.
The cache is overly complicated because (1) the values it returns are mutable,
so you better not mess with them accidentally, and (2) when you do purposely
mutate a value (like updating a player's stats), you need to remember to always
write it back to the cache manually by calling idb.cache.*.put.
In both the worker and UI processes, there is a global variable self.bbgm
which gives you access to many of the internal functions of the game from
within your browser.
Shared Worker Debugging
As mentioned above, the core of a game runs in a Shared Worker. This makes
debugging a little tricky. For instance, in Chrome, if you console.log
something inside the Shared Worker, you won't see it in the normal JS console.
Instead, you need to go to chrome://inspect/#workers and click ""Inspect"" under
http://localhost/gen/worker.js.
In any browser, if you have two tabs open and you reload one of them, the worker
process will not reload. So make sure you close all tabs except one before
reloading if you want to see changes in the worker.
Service Worker
This only applies if you use Apache, not if you use yarn run start!
A service worker is used for offline caching. This can make development tricky,
because if you load the game in your browser, make a change, wait for
build/watch to finish, and then reload... you will not see your change because
it will cache the original version and then not update it on a reload. This is
the normal behavior for service workers (they only switch to a new version when
you actually close the website and reopen it, not on a reload), but it makes
development annoying.
To work around that, in Chrome you can use the ""Update on reload"" option
and keep your devtools open. Then reloading will always get you the latest
version.
Even with that, ctrl+shift+r may be a good idea to make sure you're seeing your
latest changes.
Git Workflow
If you want to contribute changes back to the project, first create a fork on
GitHub. Then make your changes in a new branch. Confirm that the tests
(hopefully including new ones you wrote!) and ESLint all pass. Finally, send me
a pull request.
It's also probably a good idea to create an issue on
GitHub before you start working
on something to keep me in the loop.
Less Important Development Info
Sport-specific stuff
Abbreviations of stats should be done like basketball-reference.com and
football-reference.com stat pages. For instance, ""defensive rebounds"" is ""drb"".
Thank you BrowserStack
Shout out to BrowserStack for helping with
cross-browser testing.


",TypeScript
15,"














Sport Game Outcome Prediction Project - Bet on Sibyl
Bet on Sibyl in a nutshell
Table of content
Data collection
Data Design Decisions
Web Scraping
Predictions
Data preprocessing
Algorithm Tuning and Running
Results Presentation
Model Performance Metrics
ML one-sport process in a nutshell
License
Links
Notes





README.md




============================================
Sport Game Outcome Prediction Project - Bet on Sibyl
Bet on Sibyl in a nutshell
BetonSibyl is a platform controlled by a set of algorithmic models (a model defined for each sport)
that projects accurately estimated results (predictions of upcoming games) from a multitude of statistical variables.
At launch, the platform will cover the four major US sports (Football, Basketball, Baseball, Hockey), Soccer and Tennis.
Moreover, the models provide stats to measure the
performance of the algorithm for the current season (for each sport) along with bankroll comparaison stats with bookmaker
(scraping from the oddsportal's website to do so). Here's below an image from the mobile app
propotype based on the platform.

Table of content

Data collection

Decomposition - Data Design Decisions
Web Scraping - Selenium/Beautiful Soup


Predictions

Data Preprocessing
Algorithm Tuning and Running


Results Presentation

Bookmakers comparaison over the year
Model Performance Metrics
ML one-sport process in a nutshell


License
Links
Notes

Data collection
Data Design Decisions


It is decided that the two participating teams/players in each matchup are respectively represented by visitor team and home team (player A/player B in case of Tennis).
This is contrary to another popular method of representing the teams as the favorite and underdog.


The point differential is chosen to be positive when the home team scores more points than the away team.


To represent the difference between the two teams that are playing in the matchup, the ratio or the difference between
the same attributes are taken between the two teams. That is, the home team’s statistic is divided by the visitor team’s
statistic. Therefore, when attributes are a positive indicator of performance, a value greater than 1 indicates that
the home team performs better for that particular attribute. When the attributes are integers (not statistics), then
the difference between the home team’s attribute and the away team’s attribute is taken. Examples of this are win
streak, compared to statistics such as points per game that would be compared by taking the ratio.


Web Scraping
The data is scraped from several websites according to each sport using Python and the Selenium and BeautifulSoup (only for MLB data)
packages for Python. Data sources for each sports are described in the ""Link"" section.
According to each sport/league, the script goes through each summary season page and writes season team stats and season game stats
(e.g. date, the home team, away team, home team points, away team points etc.) to a csv file.
Game stat data, team stat data, and datetime data are merge later into a feature file (.npz) for the ML algorithm (Lasso Logistic Regression)
Here's below an example team stats data and game stats data for the NFL league.
In the same scripts, After having obtained the raw data set, data is cleaned throughout the script. The script
checked the completeness and validity of all the data files, and eliminated any CSV parsing errors
or erroneous data values.
ex of NFL team stat data from the 2000 season to the 2015 season

ex of NFL game stat data from the 2000 season to the 2015 season

Predictions
Data preprocessing
Data preprocessing is made in the Prepare_for_ML.py file. Here is the main idea:
Having validated all our available data, the script then proceeded to load the data from the csv files
into an SQL database using the SQLite single-file database engine and a few Python scripts. The
flexibility of SQL queries allowed one to easily perform complex joins and merges between multiple
tables via the the script.
Instead of using each team’s attribute independently in the analysis, attributes are formed to represent the difference
between the attribute for the two participating teams in the matchup. For example, in the NBA league the attributes
‘average_blocks_per_game_home’ and ‘average_blocks_per_game_away’ are not used in the analysis, rather,
the ratio between the two values is used.
Thus, the script converts the clean scraped data to data structures that the libraries in scikit-learn can easily use.
The ultimate result of the routines included in this file is a numpy array containing all the features and game results
for the historical game data. The structure 'features.npz' contains this output and is eventually loaded by scikit-learn.
The features have not been normalized but the next script provide one the ability to easily normalize or standardize the data.
Algorithm Tuning and Running
This step is located in the ""RunModelLeague.py""
According to each sport, it uses scikit-learn and historical game results (in the .npz file) to make predictions on the current season games
that have not been played.
A logistic regression predictive model with the L1 penalty is created. Analysis of results are output to csv files.
Here is below an example of the output for the 2017 nba season

Then, webscraping (through the ScrapeMatchupDatetimeOddsTwoChoicesLeague.py file) is performed  through the betbrain's website so as one can have more information on each league upcoming match.
Thus, the final output give additionnal detail such as odds for both home and away teams, the choice of the bookmaker
(e.g. the team with the lowest odd if designed to be the bookmaker choice), the choice of the algorithm (Sibyl), if
there is a divergence or no between Sibyl and the bookmaker ('Y' = yea, 'N' = no).
Here's below an example of the final output for the Ligue 1 soccer league.

Results Presentation
Model Performance Metrics
First of all, webscraping (through the SibylVsBookiesNFL.py file) is performed in order to have sufficient data to make comparison with
bookmakers over the year (oddsportal's website).
Below you can see an example of output that help one make a clear performance comparison between Sibyl and the bookies
for the 2016 MLB season.

Then, algorithm performance measure is performed through the ModelMetricsLeague.py file
The script provides one for a given league data such as algorithm accuracy (e.g. % of correct predictions) up-to-date, the team of the month to
bet on (team which has performed well when chosen by the algorithm), the worst team of the month, The top teams to bet on
based on the divergence stategy etc...
ML one-sport process in a nutshell
For a given league, the entire process described above can be run via the ModelLeague.py file.
Here is an example of the process code for the
# coding: utf-8

import numpy as np
import sys


class ModelNHL(object):
    from RunModelNHL import NHLMakePredictions
    from ScrapeMatchupDatetimeOddsTwoChoicesNHL import AcquireMatchupDatetimeOddsTwoChoices
    from SibylVsBookiesNHL import AcquireSibylVsBookiesNHL
    from ModelMetricsNHL import ModelMetricsNHL

    def __init__(self, current_season, feature_file, nhl_db_name,
                 betbrain_upcoming_games_url, cs_team_stats_filename, league_name, upcoming_games_output_filename_us,
                 upcoming_games_output_filename_eu, oddsportal_url_fix, oddsportal_url_list_format):
        self.current_season = current_season
        self.feature_file = feature_file
        self.data = np.load(feature_file)
        self.tableau_input_filename = ""nhl_tableau_output_"" + str(current_season) + "".csv""
        self.current_season = current_season
        self.X = self.data['X']
        self.y = self.data['y']
        self.nhl_db_name = nhl_db_name
        self.betbrain_upcoming_games_url = betbrain_upcoming_games_url
        self.cs_team_stats_filename = cs_team_stats_filename
        self.league_name = league_name
        self.upcoming_game_outputs_filename_us = upcoming_games_output_filename_us
        self.upcoming_games_output_filename_eu = upcoming_games_output_filename_eu
        self.oddsportal_url_fix = oddsportal_url_fix
        self.oddsportal_url_list_format = oddsportal_url_list_format
        self.cs_team_stats_filename = cs_team_stats_filename
        self.season_over = 'No'

    def __call__(self):
        print ""NHL Machine Learning process execution...""
        x = self.NHLMakePredictions(self.current_season, self.feature_file, self.nhl_db_name)
        x()
        print ""NHL Machine Learning process execution...OK\n""

        print ""NHL Scraping odds and datetime from Betbrain.com process execution...""
        w = self.AcquireMatchupDatetimeOddsTwoChoices(
            self.season_over,
            self.betbrain_upcoming_games_url,
            self.cs_team_stats_filename, self.league_name,
            self.tableau_input_filename,
            self.upcoming_game_outputs_filename_us,
            self.upcoming_games_output_filename_eu)
        w()
        print ""NHL Scraping odds and datetime from Betbrain.com process execution...OK\n""

        # ----------------------------------------------------------------------------

        self.season_over = w.season_over
        print self.league_name + ' season is over? : ' + self.season_over + '=> '
        if self.season_over == 'No':
            print ""Moving on...\n""
        else:
            print ""Season over => Stopping the NHL process\n""

        # ----------------------------------------------------------------------------

        print ""NHL Sibyl vs Bookies process execution...""
        v = self.AcquireSibylVsBookiesNHL(self.season_over, self.oddsportal_url_fix, self.oddsportal_url_list_format,
                                          self.cs_team_stats_filename, self.tableau_input_filename)
        v()
        print ""NHL Sibyl vs Bookies process execution...OK\n""

        print ""NHL ModelMetrics process execution...""
        u = self.ModelMetricsNHL(self.season_over, self.tableau_input_filename, self.upcoming_game_outputs_filename_us,
                                 self.cs_team_stats_filename)
        u()
        print ""NHL ModelMetrics process execution...OK\n""


if __name__ == '__main__':
    x = ModelNHL(2017, 'nhl_features_2006_2015.npz', 'nhl_team_data_2017.db',
                 'https://www.betbrain.com/ice-hockey/united-states/nhl/', 'nhl_team_stats_2017_2017.csv', 'NHL',
                 'NHL_Upcoming_Matchups_US_P_df.csv', 'NHL_Upcoming_Matchups_EU_P_df.csv',
                 'http://www.oddsportal.com/hockey/usa/nhl/results/',
                 'http://www.oddsportal.com/hockey/usa/nhl/results/#/page/{}/')
    x()

Nb: the script does not take argument.
License
The Bet on Sibyl is licensed under the terms of the GPL Open Source
license and is available for free.
Links
Here are all the website sources for data web scraping:

http://www.baseball-reference.com/ (Beautiful Soup)
http://www.basketball-reference.com/ (Selenium/Phantom JS)
http://www.pro-football-reference.com/ (Selenium)
http://www.hockey-reference.com/ (Selenium)
http://www.soccerstats.com/ (Selenium)
http://www.coretennis.net/ (Selenium/ Phantom JS)
http://www.oddsportal.com (Selenium)
https://www.betbrain.com (Selenium)

Here is the link for the mobile app prototype:

https://marvelapp.com/31dgaj4/screen/17384930

Notes
All us leagues and soccer leagues models are done.
Tennis model is ongoing but partially finished.
Any recommendation, help for the model would be much appreciated.
Enjoy!
Tool used: Ananconda Distribution through Pycharm (Professional version) + Jenkins / Jupyter Notebook / SQLite Browser


",Python
16,"











Sports Video Analysis
Court Detection
Mask R-CNN of persons (mask-rcnn)
Color detection of players (color-detection)
Players tracking
Action Classification
Homography mapping of court





README.md




Sports Video Analysis
See wiki page for more details.
Court Detection

See details on court detection here.
Mask R-CNN of persons (mask-rcnn)
See details here including online tutorial.

Video output example
https://www.youtube.com/watch?v=yEqGTSd5DQU
Color detection of players (color-detection)
The run script will produce a CSV with the RGB values and percentage of each color.
ToDo:  Classify each color result into two groups, identify hopefully each team by color.

Players tracking
See article on players tracking solutions
See also YouTube video with different solutions.
Action Classification

Required so we can classify the game play action of players.
Homography mapping of court
Maps the 3D court onto a 2D version, required for analysis of movement.

See also YouTube video
See details here
and article with tutorial.


",Python
17,"











NBA Player Performance Prediction and Lineup Optimization
What We'll Do
What We Won't Do
Requirements
Understanding Fantasy Sports
Project Structure





README.md




Note (March 2022) This repository is under major refactoring.
NBA Player Performance Prediction and Lineup Optimization
Prediction of NBA player performance defined as Fantasy Points by Draft Kings. This capstone project was conducted and approved by a reviewer as part of Machine Learning Engineer Nanodegree by Udacity. See the final report here for details.
Note that the code was updated since the writing of the report and the content does not necessarily match up. This project is under minor refactoring and documentation as of Jun 2019, feel free to reach out to me via email at kengo@hey.com.
What We'll Do
The end goal of this project is to generate a series of lineups for a fantasy basketball website DraftKings. To achieve that, we'll scrape player statististics from each regular season game starting in the 2014-15 season as well as past fantasy salary information. First, we'll build a predictive model for player performance, and then we will use genetic algorithm to construct fantasy lineups to maximize the total fantasy points while satisfying the salary constraint.
What We Won't Do
Given the complexity of the series structure and difference in nature, we won't be considering playoff games. In addition, a major factor omitted from our analysis is the opponent's defensive ability as a team or at a given position (for instance, Paul George is excellent at stealing the ball), which arguably is one of the most important factors of the game. Tackling this aspect will be an easy improvement to this project.
Requirements
Along with libraries specified in requirements.txt, you need to sign up with Plotly for free to create interactive visualizations.
Understanding Fantasy Sports
The key to select a good fantasy lineup is to identify players that are consistent performers. This basic intuition comes from Harry Morkowitz's Modern Portfolio Theory (MPT), and the following scatter plot looks at the relationship between risk and return, where return is the average fantasy points over a given range of games (in this case, past 10 games) and risk is its standard deviation. For a given level of risk (x-axis), a player with a better return is considered to be superior. The plot is based on the late 2018-19 season statistics, where, for instance, Lebron James is shown in the top-left with a 10-game average of a whopping 58.1 fantasy points and a 7.4 standard deviation. The top curve starting from Harden (top right), Lebron, Paul George, Gorbert, Sexton, and Zubac can be considered as Efficient Frontier in the framework of the MPT. In general, players on the outer left of the cluster are considered as good assets with low risk and high return. Players are color-coded based on rough positions of PG, SG, F (SF, PF, SF/PF), and C (PF/C, C). A fully interactive version can be accessed here.

Another important dimension of the game of fantasy basketball is player salary. Fantasy sports websites like DraftKings determine player salary values given their previous performance and roster information in a semi-automatic fashion, such that it is more costly to include ""stud"" players with high expected return (LeBron, Westbrook, Harden) into your lineup. DraftKings has a salary cap of $50,000 for a selection of 8 players, giving each player an average salary of $6250. The graph below shows a scatterplot of a player's salary and his actual performance of the day in the latest games of the 2018-19 season. One striking insight is that while it is easy to identify studs like Westbrook who had a total fantasy poitns of 61.5 for his 11.8k salary April 10, ""value"" players who exceed expectations are much more difficult to find, with a large variance given a salary level. For instance, Jamal Crawford on the top left had monstrous performance for a combined fantasy points of 70.25, despite the low expectation of his $4300 salary. These ""value"" players are what differentiates winning lineups from those of a typical beginner with a collection of star players and underachieving benchwarmers. This requires deeper insight into who will outperform their expectations. For instance, an injury of a starting player most likely increases minutes for other starting members and the second option player on the bench. A fully interactive version can be accessed here.

Project Structure
This project consists of 9 Jupyter notebooks and functionalities are described below, where the second half consists of construcing machine leanring models and making inference, and optimising lineups for DraftKings.


01.data_scraping.ipynb scrapes games data from Basketball-Reference.com and salary and position information from RotoGuru.


02.merging_data.ipynb merges the two datasets with name standardisation and preliminary preprocessing of data such as calculation of FPTS based on the key statistics.


03.exploratory_analysis.ipynb visually explores relationships between; salary and actual FPTS and; expected FPTS and standard deviation of the past 10 games.


04.feature_engineering.ipynb constructs the baseline model with simple average along with additional three datasets with weighted average, where several features are engineered and incorporated.


05.baseline_models.ipynb sets up the baseline model with simple season average adopted by DraftKings and linear regression with feature selection models. For notebooks 06-08, we use 5-fold cross validation to approximate model errors.


06.lightgbm_bayesian_optimization.ipynb uses bayesian optimisation method to find the best parameters for a boosting model using lightGBM. Parameters and their results are saved in a text file.


07.neural_networks.ipynb constructs three neural network models using keras, and saves model weights only when there was an improvement. While deep learning models might not suit this dataset of limited size, it shows improvement compared to boosting models.



08.predictions.ipynb trains on the whole dataset except for the month of March 2019, where each contest's cashline for double up was manually obtained from RotoGrinders. Inference is made on this test data from March 2019.


09.lightgbm_bayesian_optimization.ipynb uses Genetic Algorithms to select best combinations of players on a given set of games ans predictions. Performance of the lineups chosen by the algorithm against other DraftKings users is examined for contests held in March, 2019. Note that the contest data is manually obtained from Rotogrindrs' ResultsDB page without scraping. Predictions from the baseline model and final model are compared to the actual performance. The following figure shows the optimal lineup this model returns, with differences between the actual FPTS and predicted FPTS with neural network and baseline models.



Main procedures are coded and explained in markdown using Jupyter Notebook. Although not requred, jupyter nbextentions are highly recommended for convenience and visibility (see link). Useful extensions are Codefolding, ExecuteTime, Collapsible Headings, and Variable Inspector. http://jupyter-contrib-nbextensions.readthedocs.io/en/latest/install.html


",Python
18,"











basketball_reference_scraper
Installing
Via pip
Via GitHub
Wait, don't scrapers like this already exist?
API





README.md




basketball_reference_scraper
Basketball Reference is a great resource to aggregate statistics on NBA teams, seasons, players, and games. This package provides methods to acquire data for all these categories in pre-parsed and simplified formats.
Installing
Via pip
I wrote this library as an exercise for creating my first PyPi package. Hopefully, you find it easy to use.
Install using the following command:
pip install basketball-reference-scraper

Via GitHub
Alternatively, you can just clone this repo and import the libraries at your own discretion.
Wait, don't scrapers like this already exist?
Yes, scrapers and APIs do exist. The primary API used currently is for stats.nba.com, but the website blocks too many requests, hindering those who want to acquire a lot of data. Additionally, scrapers for Basketball Reference do exist, but none of them load dynamically rendered content. These scrapers can only acquire statically loaded content, preventing those who want statistics in certain formats (for example, Player Advanced Stats Per Game).
API
Currently, the package contains 5 modules: teams, players, seasons, box_scores, pbp, shot_charts, and injury_report.
The package will be expanding to include other content as well, but this is a start.
For full details on the API please refer to the documentation.


",Python
19,"














截图
安装运行
Go
Homebrew
Docker
Manual
致谢
协议





README.md




          __                ___          
   ____  / /_  ____ _      / (_)   _____ 
  / __ \/ __ \/ __ `/_____/ / / | / / _ \
 / / / / /_/ / /_/ /_____/ / /| |/ /  __/
/_/ /_/_.___/\__,_/     /_/_/ |___/\___/ 







nba-live是一个在终端下观看NBA&CBA文字直播的命令行工具.
所有数据来自手机版直播吧.
截图


安装运行
Go
go get -u github.com/xwjdsh/nba-live
nba-live
Homebrew
brew tap xwjdsh/tap
brew install xwjdsh/tap/nba-live
nba-live
Docker
docker pull wendellsun/nba-live
docker run -it --rm wendellsun/nba-live
Manual
从releases下载可执行文件并将其放到PATH环境变量对应的路径中，然后在终端输入nba-live运行。
致谢

manifoldco/promptui
marcusolsson/tui-go
基于Python命令行的NBA文字直播小工具

协议
MIT License


",Go
20,"











Deep Play-by-Play
Classification performance
Running the code
Examples:
Incorrect classification examples:
FAQ





README.md




Deep Play-by-Play
This repo contains model and data collection / preprocessing code to label NBA broadcast footage with play-by-play descriptions, using 3D ConvNet-based video classification.
To learn how to scrape labelled videos off NBA.com for similar projects, see data_utils/README.
Classification performance
After training on about 3000 training examples (~6000 with augmentation), on a test set with 253 test examples (both sets somewhat evenly divided among 6 classes), the following accuracies were achieved:



# classes
Classes
Accuracy




6
(Inside/Midrange/Three) (Make/Miss)
66%


4
(Two/Three) (Make/Miss)
74%


2
(Make/Miss)
91%



Running the code
You should be able to clone this repo, set up paths appropriately in config.py, and run training or inference. All dependencies for this project ship with either the Python 3 standard library or the everyday machine/deep learning toolkit (TensorFlow, keras, scikit-learn). To read videos from disk, I use scikit-video io module, which you may need to install. Training data isn't hosted in this repo because it is quite large even after downsampling, and I don't have the express written consent of the NBA.
However, the pre-trained weights file is available in the weights directory.
Examples:
The ultimate goal is continuous video classification, on running broadcast footage. However, I didn't have access to labelled data for non-field goal events (like rebounds, free throws, players running down the court, Javale doing dumb shit, etc). As a result, these examples use 90-frame (at 8 fps, so about 11 seconds long) videos of field-goal make/miss events - the only kind the model can currently identify.
Since all data used for training and testing was from the 2017-18 season, I picked out several plays from this video of the last 5 minutes of Spurs/Rockets Game 5 in the 2017 playoffs to see how accurately plays from a completely different season are classified:
 
 
 
 
Incorrect classification examples:
...because, like most things in life, this isn't perfect:
This Danny Green and-one is best classified as an INSIDE_MAKE, but MIDRANGE_MAKE is not a terribly bad guess:
 
The following play is an offensive foul followed by a MIDRANGE_MISS, but is classified as more likely to be an INSIDE_MAKE (51%) than a MIDRANGE_MISS (27%):
 
Sometimes, the classifier flat-out fails confidently 😞 :
 
 
Note that some of these plays are quite difficult to judge properly at this resolution and frame rate, without sound. Now imagine that these videos are also black and white, and that is the kind of data that this model has been trained on. Therefore, it's unsurprising that it isn't very good, but working with higher quality videos requires significantly more computational resources 💰.
FAQ
I'll fill this out if and when people ask questions.
Reddit discussion


",Python
21,"














ncaahoopR 
Installation
Functions
Scraping Data
Win-Probability and Game-Flow Charts
Assist Networks
Shot Charts
Datasets
Examples
Win Probability Charts
Game Flow Chart
Single-Game Assist Network
Season-Long Assist Network
Circle Assist Networks
Player Highlighting
Shot Charts
Glossary





README.md




ncaahoopR 
ncaahoopR is an R package for working with NCAA Basketball Play-by-Play Data. It scrapes play-by-play data and returns it to the user in a tidy format, allowing the user to explore the data with assist networks, shot charts, and in-game win-probability charts.
For pre-scraped schedules, rosters, box scores, and play-by-play data, check out the ncaahoopR_data repository.
To see the lastest changes in version 1.5, view the change log here.
Installation
You can install ncaahoopR from GitHub with:
# install.packages(""devtools"")
devtools::install_github(""lbenz730/ncaahoopR"")
If you encounter installation issues, the following tips have helped a few users successfully install the package:

If given the option to compile any packages from source rather than installing existing binaries, choose 'No'.
Windows users with trouble installing the package should try running the following command before reinstalling the package: Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS = ""true"")
Windows users with trouble installing devtools should try first installing the backports package via install.packages(""backports"").

Functions
Several functions use ESPN game_ids. You can find the game_id in the URL for the game summary,
as shown in the URL for the summary of the UMBC-Virginia game below.

Scraping Data


get_pbp(team, season): Get entire current season's worth of play-by-play data for a given team and season. season defaults to current season, but can be specified in ""2019-20"" form.


get_pbp_game(game_ids, extra_parse):  Get play-by-play data for a specific vector of ESPN game_ids. extra_parse is a logical whether to link shot variables and attempt possesion parsing. Default =   TRUE.


get_roster(team, season): Get a particular team's roster. season defaults to current season, but can be specified in ""2019-20"" form.


get_schedule(team, season): Get a team's schedule. season defaults to current season, but can be specified in ""2019-20"" form.


get_game_ids(team, season): Get a vector of ESPN game_ids for all games involving team specified. season defaults to current season, but can be specified in ""2019-20"" form.


get_master_schedule(date): Get schedule of all games for given date. Use YYYY-MM-DD date formatting.


get_boxscore(game_id): Returns list of 2 data frames, one with each teams' box score for the game in question. Written by Jared Andrews.


season_boxscore(team, season = current_season, aggregate = 'average'): Returns (aggregated) player stats over the course of a season for a given team.
* team: team to return player stats for.
* season: of form YYYY-YY. Defaults to current season.
* aggregate: one of 'average' (per-game average statistics), 'total' (sums of season stats) or 'raw' (just return all box scores binded together). 'average' is the default. Contributed in collaboration with Kurt Wirth


The team parameter in the above functions must be a valid team name from the ids dataset built into the package. See the Datasets section below for more details.
Win-Probability and Game-Flow Charts
Win Probability Charts
The latest function for plotting win probability charts is wp_chart_new. Following the 2021-22 season other win probability chart functions will be deprecated and replaced by this function (it will be renamed to wp_chart but I don't want to break any existing pipelines during the season). It no longer requires users to input colors. For best results consider saving via ggsave(filename, height = 9/1.2, width = 16/1.2) (or some other 16/9 aspect ratio.)
wp_chart_new(game_id, home_col = NULL, away_col = NULL, include_spread = T, show_legend = T)

game_id ESPN game_id for the desired contest.
home_col Chart color for home team (if NULL will default to ncaa_colors primary_color field).
away_col: Chart color for away team (if NULL will default to ncaa_colors primary_color field).
include_spread: Logical, whether to include pre-game spread in Win Probability calculations. Default = TRUE.
show_legend: Logical, whether or not to show legend/text on chart. Default = TRUE.

A prior version of wp_chart used base R while gg_wp_chart used the ggplot2 plotting library. As of the 2020-21 season, both functions call the same ggplot2 library, and gg_wp_chart now simply aliases wp_chart
wp_chart(game_id, home_col, away_col, include_spread = T, show_legend = T)

game_id ESPN game_id for the desired contest.
home_col Chart color for home team.
away_col: Chart color for away team.
include_spread: Logical, whether to include pre-game spread in Win Probability calculations. Default = TRUE.
show_legend: Logical, whether or not to show legend/text on chart. Default = TRUE.

gg_wp_chart(game_id, home_col, away_col, show_labels = T)

game_id ESPN game_id for the desired contest.
home_col Chart color for home team.
away_col: Chart color for away team.
include_spread: Logical, whether to include pre-game spread in Win Probability calculations. Default = TRUE.
show_labels: Logical whether Game Excitement Index and Minimum Win Probability metrics should be displayed on the plot. Default = TRUE.

Game Flow Charts
game_flow(game_id, home_col, away_col)

game_id ESPN game_id for the desired contest.
home_col Chart color for home team.
away_col Chart color for away team.

Game Excitement Index
game_exciment_index(game_id, include_spread = T)

include_spread: Logical, whether to include pre-game spread in Win Probability calculations. Default = TRUE.

Returns GEI (Game Excitement Index) for given ESPN game_id. For more information about how these win-probability charts are fit and how Game Excitement Index is calculated, check out the below links

Model Methodology
Game Excitement Index

Game Control Measures
average_win_prob(game_id, include_spread = T)

ESPN game_id for which to compute time-based average win probability (from perspective of home team).
include_spread: Logical, whether to include pre-game spread in Win Probability calculations. Default = TRUE.

average_score_diff(game_id)

ESPN game_id for which to compute time-based average score differential (from perspective of home team).

Assist Networks
Traditional Assist Networks
assist_net(team, season, node_col, three_weights = T, threshold = T, message = NA, return_stats = T)

team is the ESPN team name, as listed in the ids data frame.
season Options include ""2018-19"" (for entire season), or a vector of ESPN game IDs.
node_col is the node color for the graph.
three_weights (default = TRUE): Logical. If TRUE, assisted three-point shots are given a weight of 1.5. If FALSE, assisted three-point shots are given a weight of 1. In both cases, assisted two-point shots are given a weight of 1.
threshold (default = 0) Number between 0-1 indicating minimum percentage of team's assisted baskets a player needs to be involved in to be included in network graph.
message (default = NA) Option for custom message to replace graph title when using a subset of the season (e.g. conference play).
return_stats (default = TRUE) Return Assist Network-related statistics

Circle Assist Networks and Player Highlighting
circle_assist_net(team, season, highlight_player = NA, highlight_color = NA, three_weights = T, threshold = 0, message = NA, return_stats = T)

team is the ESPN team name, as listed in the ids data frame.
season: Options include ""YYYY-YY"" (for entire season), or a vector of ESPN game IDs.
highlight_player (default = NA) Name of player to highlight in assist network. NA yields full-team assist network with no player highlighting.
highlight_color (default = NA) Color of player links to be highlighted. NA if highlight_player is NA.
three_weights (default = TRUE): Logical. If TRUE, assisted three-point shots are given a weight of 1.5. If FALSE, assisted three-point shots are given a weight of 1. In both cases, assisted two-point shots are given a weight of 1.
threshold (default = 0) Number between 0-1 indicating minimum percentage of team's assisted baskets a player needs to be involved in to be included in network graph.
message (default = NA) User-supplied plot title to overwrite default plot title, if desired.
return_stats (default = TRUE) Return Assist Network-related statistics

Shot Charts
There are currently three functions for scraping and plotting shot location data. These functions are written by Meyappan Subbaiah.
get_shot_locs(game_id): Returns data frame with shot location data when available. Note that if the extra_parse flag in get_pbp_game is set to TRUE, shot location data will already be included in the play-by-play data (if available).

game_id: ESPN game_id from which shot locations should be scraped.

game_shot_chart(game_id, heatmap = F): Plots shots for a given game.

game_id: ESPN game_id from which shot locations should be scraped.
heatmap (default = FALSE): Logical, whether to use density-heat map or plot individual points.
shot-plotting colors derived from team's primary color listed in ncaa_colors data frame.

team_shot_chart(game_ids, team, heatmap = F): Plots shots taken by team during a given set of game(s).

game_ids: Vector of ESPN game_ids from which shot locations should be scraped.
team: Which team to chart shots for.
heatmap (default = FALSE): Logical, whether to use density-heat map or plot individual points.
shot-plotting colors derived from team's primary color listed in ncaa_colors data frame.

opp_shot_chart(game_ids, team, heatmap = F): Plots shots against a team during a given set of game(s).

game_ids: Vector of ESPN game_ids from which shot locations should be scraped.
team: Which team to chart opponents' shots for.
heatmap (default = FALSE): Logical, whether to use density-heat map or plot individual points.

Datasets
dict A data frame for converting between team names from various sites.

NCAA: the name of the team, as listed on the NCAA website
ESPN: the name of the team, as listed in ESPN URLs
ESPN_PBP: the name of the team, as listed in the ESPN Play-By-Play logs
Warren_Nolan: the name of the team, as listed on WarrenNolan.com
Trank: the name of the team, as listed on barttorvik.com
name_247: the name of the team, as listed on 247Sports.com

ids A data frame for converting between team names from various sites.

team: the name of the team to be supplied to functions in ncaahoopR package
id: team id; used in ESPN URLs
link: link; used in ESPN URLs

ncaa_colors A data frame of team color hex codes, pulled from teamcolorcodes.com. Additional data coverage provided by Luke Morris.

ncaa_name: The name of the team, as listed on the NCAA website (same as dict$NCAA)
espn_name: The name of the team, as listed in ESPN URLs (same as dict$ESPN)}
primary_color: Hexcode for team's primary color.
secondary_color: Hexcode for team's secondary color, when available.
tertiary_color: Hexcode for team's tertiary color, when available.
color_4: Hexcode for team's 4th color, when available.
color_5: Hexcode for team's 5th color, when available.
color_6: Hexcode for team's 6th color, when available.


Primary and secondary colors for all 353 teams.
These datasets can be loaded by typing data(""ids""), data(""ncaa_colors""), or data(""dict""), respectively.
Examples
Win Probability Charts

wp_chart_new(401403405)

wp_chart(game_id = 401082978, home_col = ""gray"", away_col = ""orange"")

wp_chart(game_id = 401168364, home_col = ""#7BAFD4"", away_col = ""#001A57"")
Game Flow Chart

game_flow(game_id = 401082669, home_col = ""blue"", away_col = ""navy"")
Single-Game Assist Network

assist_net(team = ""Oklahoma"", node_col = ""firebrick4"", season = 400989185)
Season-Long Assist Network

assist_net(team = ""Yale"", node_col = ""royalblue4"", season = ""2017-18"")
Circle Assist Networks

circle_assist_net(team = ""UNC"", season = 401082861)
Player Highlighting

circle_assist_net(team = ""San Francisco"", season = ""2018-19"", highlight_player = ""Frankie Ferrari"", highlight_color = ""#FDBB30"")
Shot Charts

game_shot_chart(game_id = 401168364, heatmap = T)

game_shot_chart(game_id = 401168364)
Glossary
Play-by-Play files contain the following variables:

game_id: ESPN game_id for the game in question.
date: Date of game.
home: Name of the home team.
away: Name of the away team.
play_id: Unique identifier of play/event in sequence of game events.
half: Period of action in the game. 1 and 2 denote the first and second halves of play, while 3 denotes OT1, 4 denotes OT2 etc.
time_remaining_half: Time remaining in the period as it would appear on a scoreboard.
secs_remaining: Time remaining in regulation, in seconds.
secs_remaining_absolute: The time remaining until the game is over, in seconds. For example a game that goes to overtime would begin with 2700 seconds remaining (2400 for regulation and 300 for overtime), and regulation would end with 300 seconds remaining.
description: A description of the play/game event.
home_score: Home team's score.
away_score: Away team's score.
score_diff: Score differential from the home team's perspective (home_score - away_score)
play_length: Duration of the the given play, in seconds.
win_prob: Win probability for the home team.
naive_win_prob: Win probability for the home team not factoring in pre-game point spread. Useful for computation of win probability added (WPA).
home_timeout_remaining: Number of timeouts remaining for the home team.
away_timeout_remaining: Number of timeouts remaining for the away team.
home_favored_by: Number of points by which the home team is favored, prior to tip-off. If Vegas point spread is available on ESPN, that is used as the default. When not available, an attempt is made to impute the pre-game point spread from derived team strengths. Imputed point spreads are not available for games prior to the 2016-17 season or when one of the teams is not in Division 1.
total_line: Total Vegas over/under for the game, where available.
referees Referees for the game.
arena_location: City in which the game was played.
arena: Name of arena where game was played.
capacity: Capacity of arena where game was played.
attendance: Attendance of game, where available.
wrong_time: An attempt to label play-by-play events tagged at the wrong time. These are filtered out of all graphical and statistical helper functions, but may still be useful for certain analyses where time of event is of less importance.

If extra_parse = TRUE in get_pbp_game, the following variables are also included.

shot_x: The half-court x coordinate of shot.
shot_y: The half-court y coordinate of shot. (0,0) represents the bottom left corner and (50, 47) represents the top right corner (from persepective of standing under hoop).
shot_team: Name of team taking shot.
shot_outcome: Whether the shot was made or missed.
shooter: Name of player taking shot.
assist: Name of player asssisting shot (assisted shots only)
three_pt: Logical, if shot is 3-point field goal attempt.
free_throw: Logical, if shot is free throw attempt.


Stand-alone shot location data frames contain the following variables.

team_name: Name of shooting team.
shot_text: Description of shot.
color: Color hexcode used to render shot chart graphic on ESPN.
date: Date of game
outcome: Whether the shot was made or missed
shooter: Player attempting the shot
assister: Playing assisting the shot
three_pt: Logical, whether the shot is a 3-point attempt
x: x-coordinate of shot location
y: y-coordinate of shot location

The court is 50 feet by 94 feet, with (0,0) always being placed in the bottom left corner of the shot chart. Any full-court shot chart rendered using game_shot_chart() preserves ESPN shot locations as they are found online, while halfcourt charts using team_shot_chart() convert all shot locations to to a 50 feet by 47 feet halfcourt. The perspective on the halfcourt shot charts is as if one is standing under the hoop, looking toward the opposition hoop. (0,0) again represents the bottom left corner and (50, 47) represents the top right corner.


",R
22,"











LSTM with MDN for basketball trajectories
To create a model
The files





readme.md




LSTM with MDN for basketball trajectories
This is the code repository for our paper, Applying Deep Learning to Basketball Trajectories. We also have written a short interactive summary of the paper or find the full paper on arXiv.
This repo contains the data and tensorflow models we used in the paper. To run this code, it is necessary to have installed:

Tensorflow > 0.8
Numpy
Sklearn

To create a model

Unpack the seq_all.csv.tar.gz
Run main.py (This python script was designed to be run within an IDE, but will function as a standalone script.)

Within main.py there are a number of configuration settings that can be modified. These include settings for the model architecture, sequence length, distance to the basket, and performance measures. There is also an option to turn plotting on and see output at different model stages.



The files

main.py is the main file
dataloader.py contains a class to load the data

util_*.py are two files with utility functions





",Python
23,"











basketballcrawler
Requirements
Usage
Notes
TODO





README.md




basketballcrawler

This is a python module to scrape basketball-reference.com and convert various
stats into usable data structures for analysis.
Here is a link to a
sample IPython Notebook file demonstrating the library.
Requirements

Beautiful Soup >= 4.0
pandas >= 0.11
request >= 2.0

Usage
Still developing the API.  Right now you can get a list of all player overview urls, generate a list of game log urls for
a given player, and convert that list into pandas dataframe.
Notes
players.json was generated on 02/11/2016 by buildPlayerDictionary() and savePlayerDictionary().
I'd recommend building your own, fresh copy. It takes about 10 minutes to scrape from the site.
To create the most recent players.json, you can use as follows.
import basketballCrawler as bc
players = bc.buildPlayerDictionary()
bc.savePlayerDictionary(players, '/path/to/file')
You can also download generated players.json. However, note that it's a pretty large (13M) file.
players = bc.loadPlayerDictionary('/path/to/players.json')
In order to search player name, use searchForName function, for example,
searched_player = bc.searchForName(players, 'Murphey') # players is player dictionary
TODO

Local Database construction.
League-wide statistics.



",Python
24,"














Basketball Analytics
2021-22 Season
2020-21 Season
Playoffs
Regular Season
Preseason
2019-20 Season
Playoffs
2018-19 Season
2017-18 Season





README.md




Basketball Analytics
This repository and scripts in it will be focusing on the statistics revolving around NBA and basketball in general.
All code is written in Python using the Jupyter Notebooks which allow live preview of the images and thus making it nice and easy to analyze and visualize data.
Current mini ""projects"":
2021-22 Season


Simple plot which checks if there is correlation between box outs and DRB%: Notebook


Shotchart notebook with one new plot type - change of shot frequency in each zone


Finding which players get more of real assists, and which get more fake assists: notebook - also uses pbp data


Notebook which finds assist combos (in this case, alley oop partners), it uses data retrieved through Play-by-Play downloader


2020-21 Season
Playoffs


Some other stuff can be find in this FOLDER


AVERAGE PASSES PER SERIES: Notebook


Regular Season


LONG DISTANCE ANALYSIS + AVERAGE DISTANCE ARC: Analysis of long distance shooters (Notebook) and average 3pt arc


CALCULATING RIM DETERRENEC AND BLOCK EFFICIENCY: How to calculate Rim deterrence from play-by-play data + block efficiency(recovery): Notebook


GOBERT ANALYSIS: Big analysis on Gobert's dominance on defense: Notebook


ASSIST CHART: Simple assist chare with share of total shots in that area: Notebook


DENVER NUGGETS' ANALYSIS: Various charts regarding Denver Nuggets: Notebook


BIGGEST RA SHARE OF SHOTS: Table which shows Zion's dominant numbers: Notebook


CLUTCH ANALYSIS: Various tables and ""face scatters"" for clutch data: Notebook


HUSTLE landscape: Simple scatter for hustle data: Notebook


ALL SHOTS BY KOBE: Every shot generated into a gif per season level: Notebook


PACE/TS/FT per seasons: BBRef scraper plus line charts for TS%, Pace, FGA per game per seasons and for FTAs per game per season


TEAM EFFICIENCY LANDSCAPE: Goldsberry-like plot with Net rating landscape: Notebook


GAME LENGTH ANALYZER: Notebook -> checking out what part of the game lengthens the game


PLAYER's FACE IMAGE DOWNLOADER: Simple script which downloads all active players' images (based on nba_api package): Notebook


STINT FINDER: Notebook which finds the stint for player - when and how long he's on court


PLAY-BY-PLAY DOWNLOADER AND (partial) PARSER: Notebook which downloads play-by-play data and finds when player is on/off court


Biggest difference in opponent's wide open triples vs all teams and vs target teams - full post available at my website


Best offensive rebounders


LOLLIPOP CHART showing the most improved players


HIstorical results on Christmas games


Couple of charts analyzing the (d)evolution of Blake Griffin


3 Point chase for all-time record


Preseason


Preseason analysis of Atlanta Hawks


Preseason analysis of Philadelphia 76ers


Preseason analysis of Portland Blazers


2019-20 Season
Playoffs


Lakers - Nuggets Radar chart, Boston - Miami Radar Chart, and there are others as well. Basically a ""breakdown"" of their offenses through radar chart, which is a nice way to display numerical values across multiple categories.


Biggest change in unassisted Field Goals This shows how the amount of Unassisted field goal makes changed from regular season to first and 2nd round (will update this with conference finals when finished).


Westbrook's adaptation to Rockets -> Not really connected to playoffs, but it shows how Russ didn't play as other Rockets' players, but ran his own game...





Analysis of Anthony Davis' defensive performance in 2019-20


Analysis of After timeout plays


Analysis of Boston Duo of the Future


The PJ Tucker Paradox, where his average distance of 3pt shot is shorter than three on top of the key.


Waffle Chart for James Harden's shot selections


Defensive Specialists, part 3. Robert Covington


Defensive Specialists, part 2. Brook Lopez


Defensive Specialists, part 1. Rudy Gobert


Evolution of NBA through shot charts


Coby White analysis


Duncan Robinson analysis


Assist chart by Bam Adebayo


Analysis of Trae's long distance shooting


Best januaries


Analysis of offense durations


Look at Stockton's records


Analysis of Domantas Sabonis' season


Kyrie Irving Shot chart for 2010s


Bojan Bodanovic Shot Chart


Shots and assist by Doncic vs Pelicans


Mid-Range heavy Shot chart by DeMar Derozan


2018-19 Season


Evolution of Brook Lopez, a look at change of Lopez' shot charts through the seasons


Predicting MVP for 2018-19 nba season.


Here is notebook which shows players that excel in the clutch.


Big Luka Dončić analysis, notebook


James Harden analysis, notebook


2017-18 Season


Assists distribution between each NBA team for 2016/2017 season


Crawler which cleans table of assists inside team from basketball-reference site


Notebook to visualize assists distribution using heatmaps




Visualization of best 3 point shooters on very tight, tight, open and wide open defense

Notebook  to compare shooters based on closest defender



Shotcharts from past 2017 Eurobasket comparing Bogdanovics and displaying Markkanen's shooting ability


Bojan vs Bogdan comparison on shot charts


Lauri Markkanen's amazing first round shot chart




Comparison of clutch vs regular time shooting for top 20 NBA scorers in 2016/2017 season

Notebook  for FG%, FT%, TS% comparison in regular vs clutch time



Various stats analysis using Kaggle's dataset with NBA stats from 1950 season


Notebook which runs through some regular and advanced stats from last season as well as from previous seasons


Images which are results of previous notebook




Swarmplot of rookie stats for their first regular game in 2017-18 nba season, as well as comparison of Ben Simmons' and Markelle Fultz' debut with other first round picks

Notebook which takes at look at previously described tasks.



Inspired by Aaron Gordon's first 40 point game, I took a look at how other young players his age, or younger, improved during their first 40 point game (only the ones which aren't rookies)

Notebook Which visualizes players improvement in points per game during the season in which they scored 40 points or more.



A look at Russell Westbrook's 2016-17 season in which he won MVP award and averaged triple double.

Notebook with some charts displaying Westbrook's averages through season.



Radar plots which describe player's style.


Notebook with radar plots showing for Russell Westbrook and Kyrie Irving to view how they adapted to newly added teammates (Westbrook) and new team (for Kyrie).


Notebook which shows how Stephen Curry changed his scoring coming from 2015-16 MVP season to 2016-17 season and addition of Kevin Durant.




Analysis of Players of the week/month in the NBA

Notebook for week two.



James Harden's chase for three point heights

Notebook where I show the pace of James Harden's three point shooting.



Stephen Curry's chase for three point record

Notebook where Stephen Curry's progress in total three pointers made through career games in comparison with other top shooters



Free throw improvement for some centers

Here is notebook where improvements for some of the players like Clint Capela and Andre Drummond can be seen in comparison to last season



Most improved three point shooters

I analyzed which were the most improved three point shooters up to this point in season in this notebook



Fourth quarter scoring thus far

LeBron James has by far the most points thus far in current season, that can be seen here





",Python
25,"











Swish
Download
Features
Libraries Used
Resources Used
Getting Started





README.md





















Swish
An iOS and Android NBA app created with React Native. If you would like to request a feature, find a bug, have a question, or would like to leave feedback, open an issue! ⭐️ this repo to show support!
Download

iOS - Download here!
Android - Coming soon!

Features

Scores and stats for in-progress and completed games
Detailed play by play
Full team stats for a season
Full player stats for a season and over their career
Detailed player game stat graphs
Conference rankings
League leaders
Videos and highlights (coming soon)
Compare two players (coming soon)

Libraries Used
React Native
React Navigation
Redux
Redux Thunk
React-Native-SVG-Charts
React-Native-Modal-Dropdown
nba.js (custom and modified implementation to work with React Native)
Resources Used
Set Splash Screen iOS
Test your React Native App on your iPhone
How to Submit to the App Store
Getting Started


Fork (optional) and clone repo
git clone https://github.com/jbkuczma/NBAreact.git && cd NBAreact



Install and link dependencies
npm install

npm link



Run
npm run start:ios

npm run start:iphoneX

npm run start:android (an emulator must be running first)





",JavaScript
26,"



README.md




NBA_SportVu
Code for exploring the NBA SportVu motion data, more information at my blog. You can download the games from this repo.
_functions.R - Various functions that I have written.  The functions include sportvu_convert_json for importing motion data from a json to a data frame.  Other functions can extract distances players have traveled and create a matrix of player to player distances.
EDA_NBA_SportVu.Rmd - A markup document showing basic EDA on the movement data. Online.
PBP_NBA_SportVu.Rmd - A markup document showing how to merge play by play data with the SportVu movement data. Online.
Chull_NBA_SportVu.Rmd - A markup document for measuring player spacing using convex hulls with the SportVu movement data. Online.
Velocity_NBA_SportVu.RMd - A markup document for measuring player velocity, acceleration, and jerk using the NBA SportVu movement data. Online.
Traj_NBA_SportVu.Rmd - A markup document sharing a few different ways to analyzing player and ball trajectories. Online.


",HTML
27,"



README.md




Scripts to scrape and analyze basketball data.
Scripts scrape NBA.com, Sports Illustrated, etc. and analyze the resulting data.
Newest data collection scripts pull JSON (using the requests module) via the NBA API. For instance, this block of Python code saves data for the first game of the 2014-15 regular season:
import bb_tools as bb
gameid = '0021400001'
bb.write_game_json(gameid) # save to disk (not necessary, but faster)
box = bb.get_boxscore(gameid) # read from disk -- or web if not saved 
pbp = bb.get_pbp(gameid)
shots = bb.get_shots(gameid)

Data read/write paths are set in bb_tools.py.
The NBA's Game ID, 0021400001, is a 10-digit code: XXXYYGGGGG, where XXX refers to a season prefix, YY is the season year (e.g. 14 for 2014-15), and GGGGG refers to the game number (1-1230 for a full 30-team regular season).
Season prefixes are...
001 : Pre Season
002 : Regular Season
003 : All-Star
004 : Post Season

To save all data for the current season, run the following from the command line:
python nbaupdate.py

To save data from previous seasons, you can pass an entire list of games. For example, the list of regular season games from 1996-97 to 2014-15 is provided in the repo.
gamelist = bb.REPOHOME + '/data/csv/games_96-14.csv'
bb.write_gamelist_json(gamelist)

=======
Older data collection scripts parse HTML (using modules re, BeautifulSoup, etc.) into CSV and include:


nbagames.py : Given a range of dates & season code (e.g. 00214 = 2014-15 regular season), formulates a text list of all NBA games in the range. [REPLACED BY savegames.py]


nbascores.py : Given a list of games, queries NBA.com and writes box score data for each one. Also can query vegasinsider.com to get moneyline odds for each game. [REPLACED BY savejson.py]


nbaplays.py : Given a list of games, queries NBA.com and writes play-by-play data for each one. [REPLACED BY savejson.py]


nbastats.py : Given a list of play-by-play data, convert certain events (shots attempted/made, fouls, turnovers) into point process data (i.e. list of binary outcomes over time [0 0 0 0 1 ...]) [REPLACED BY parse_possession.py]


=======
Analysis scripts apply machine learning techniques to the resulting data in Python, Matlab, and R. Some simple examples are shown in IPython Notebooks.


",Python
28,"














DAG-Net: Double Attentive Graph Neural Network for Trajectory Forecasting
Model architecture
Prerequisites
Installation
Datasets
Architectures
Pre-trained models
Cite





README.md




DAG-Net: Double Attentive Graph Neural Network for Trajectory Forecasting
This repository contains the PyTorch code for ICPR 2020 paper:
DAG-Net: Double Attentive Graph Neural Network for Trajectory Forecasting
Alessio Monti,
Alessia Bertugli,
Simone Calderara,
Rita Cucchiara
Model architecture
The model is composed by three main components: the generative model (VRNN) and two graph neural networks.

The first graph network operates on agents' goals, expressed as specific areas of the environment where agents
will land in the future. The second second graph network operates instead on single agents' hidden states,
which contain past motion behavioural information. The employing of two separate graph neural networks allows to consider
and share both past and future information while generating agents' future movements.
Prerequisites

Python >= 3.8
PyTorch >= 1.5
CUDA 10.0

Installation

Clone this repo:

git clone https://github.com/alexmonti19/dagnet.git
cd dagnet


Create a new virtual environment using Conda or virtualenv.

conda create --name <envname>


Activate the environment and install the requirements:

conda activate <envname>
pip install -r requirements.txt

Datasets
Our proposal is general enough to be applied in different scenarios: the model achieves state-of-the-art results in both
urban environments (Stanford Drone Dataset) and sports applications (STATS SportVU NBA Dataset).
For complete information on where to download and how to preprocess the datasets see the relative
datasets/README.md.
Architectures
The repo contains both the final model and the two ablation architectures cited in the paper.

VRNN: the baseline generative architecture
A-VRNN: enhanced version of the baseline with a single graph (on agents' hidden states)
DAG-Net: the complete architecture with two graphs

For more information on how to train the models see the relative models/README.md.
Pre-trained models
We also ship the checkpoints to reproduce the results presented in the paper.




Offense BSK
Defense BSK
Stanford Drone



ADE
FDE
ADE
FDE
ADE
FDE


VRNN
9,41
15,56
7,16
10,50
0,58
1,17


A-VRNN
9,48
15,52
7,05
10,34
0,56
1,14


DAG-Net
8,98
14,08
6,87
9,76
0,53
1,04



For more information on how to test the models and produce the above results, see the relative
models/README.md.
Cite
If you have any questions, please contact alessio.monti@unimore.it or
alessia.bertugli@unimore.it, or open an issue on this repo.
If you find this repository useful for your research, please cite the following paper:
@proceedings{monti2020dagnet,
    title={DAG-Net: Double Attentive Graph Neural Network for Trajectory Forecasting},
    author={Alessio Monti and Alessia Bertugli and Simone Calderara and Rita Cucchiara},
    booktitle = {25th International Conference on Pattern Recognition (ICPR)},
    year={2020}
}


",Python
29,"



README.md




nba-jam


",Assembly
30,"














Shot Detection
AI Basketball Shot Detection and Analysis
Tracking and analysis performed on
Program output world coordinates:
Tracking and analysis performed on
Program output world coordinates:
Tracking and analysis performed on
Program output world coordinates:
Formats for representing video frame object bounding boxes detected
Object Line Format (OL) CSV file
Each object's bounding box in a video recoreded on an individual line
Mock 1 Frame Line Format (FLM1) CSV file
Each frame is represented on an individual line capturing only the highest score bounding box of each category detected
Mock 1 Basketball Tracking Format (BTM1) CSV file
Each line is an individual frame and contains the centerpoint coordinates of the highest scoring basketball detected as well as the radius and ""free"" column
LabelImg Annotation Format (LI) XML file
link to LabelImg
Each image has a corresponding LI.xml file containing all objects detected
Converting between Object Line Format (OL) and LabelImg Annotation Format (LI)
Clip Info Bundel Format (CIB) JSON file
output of image_evaluator
Data Directory Structure





README.md




Shot Detection
AI Basketball Shot Detection and Analysis
This program is able to detect when a shot occurs and fill in the balls flight from captured data. It calculates the balls initial velocity and launch angle. It is able to estimate the balls flight perpedicular to the camera plane (The z axis) using a single camera. The program is also able to detect when the balls flight is interupted by another object and will drop those data points.
Tracking and analysis performed on

unstable video


Program output world coordinates:

Tracking and analysis performed on

shot interrupted by person


Program output world coordinates:

Tracking and analysis performed on

shot interrupted by object
shot angled with component perpendicular to the camera plane


Program output world coordinates:

Formats for representing video frame object bounding boxes detected
Object Line Format (OL) CSV file
Each object's bounding box in a video recoreded on an individual line



clip_ID
width
height
frame
category
score
x1
x2
y1
y2
model




int
int
int
int
string
float
int
int
int
int
string



Mock 1 Frame Line Format (FLM1) CSV file
Each frame is represented on an individual line capturing only the highest score bounding box of each category detected

All frames are represented exactly once
Designed for videos containing at maximum a single basketball and a single person
Nan values are used with the absence of a detected  basketball or person in a frame




clip_ID
width
height
frame
x1_basketball
x2_basketball
y1_basketball
y2_basketball
x1_person
x2_person
y1_person
y2_person



Mock 1 Basketball Tracking Format (BTM1) CSV file
Each line is an individual frame and contains the centerpoint coordinates of the highest scoring basketball detected as well as the radius and ""free"" column

All frames are represented exactly once
The free column is True if the highest scoring basketballs bounding box has no overlap with the highest scoring persons bounding box
The radius is ((x2 - x1) + (y2 - y1))/2
Nan values are used with the absence of a detected  basketball




clip_ID
width
height
frame
x
y
radius
free




int
int
int
int
int
int
float
bool



LabelImg Annotation Format (LI) XML file
link to LabelImg
Each image has a corresponding LI.xml file containing all objects detected

This is used to verify the accuracy of the models detections
Multiple objects are possible for each image

 <annotation>
            <folder></folder>
            <filename></filename>
            <path></path>
            <source>
                <database></database>
            </source>
            <size>
                <width></width>
                <height></height>
                <depth></depth>
            </size>
            <segmented></segmented>
            <object>
                <name></name>
                <pose></pose>
                <truncated></truncated>
                <difficult></difficult>
                <bndbox>
                    <xmin></xmin>
                    <ymin></ymin>
                    <xmax></xmax>
                    <ymax></ymax>
                </bndbox>
            </object>
        </annotation>

Converting between Object Line Format (OL) and LabelImg Annotation Format (LI)



OL
LI




clip_ID
folder


frame
file


width
width


height
height


category
name


score



x1
xmin


x2
xmax


y1
ymin


y2
ymax


model





frame in this repository is the file name minus its extension
score is 100.0 if annotated by a human
model is ""human"" if annotated by a human

Clip Info Bundel Format (CIB) JSON file
output of image_evaluator
{
	""PATH/TO/FRAME/IMAGE"" : 

	{

		""image_path"" 		: ""PATH/TO/FRAME/IMAGE"",
		""image_folder"" 		: ""IMAGE_FOLDER""
		""image_filename"" 	: ""IMAGE_FILENAME"",
		""image_height"" 		: HEIGHT_IN_PIXELS (int),
		""image_width"" 		: WIDTH_IN_PIXELS (int),
		""image_items_list"" : 

			[
				""category"" : ""NAME"",
				""score"" : ACCURACY_SCORE (float),
				""box"" : [x1,x2,y1,y2] (ints),
				""model"" : ""EVALUATION_MODEL""
			]
	}
}

Data Directory Structure
data
│
└───clips
│   |
│   | CLIP_ID1.mp4
|   | CLIP_ID2.mp4
│   | ...
|
└───verified_li_annotations
│   │
│   └───CLIP_ID1
|   |   │
|   |   └───frames
|   |   |   | 1.jpg
|   |   |   | 2.jpg
|   |   |   | ...
|   |   |
|   |   └───li_annotations
|   |   |   | 1.xml
|   |   |   | 2.xml
|   |   |   | ...
|   |   
│   └───CLIP_ID2
│   ...
│   
└───ol_annotations
    │   ol_annotations.csv



",Python
31,"














pbprdf
Running pbprdf
Example: Analyze a set of games
Example: Load the ontology into RDF4J Server
Other Useful Queries
Clutch Shots
Shots made and missed at Target Center in the first five minutes
Setting up RDF4J Server
Building pbprdf
Other useful build commands





README.md




pbprdf
Generate RDF for NBA or WNBA basketball play-by-play data by reading a folder full of ESPN-style play-by-play HTML pages (eg. Pacers vs. Cavaliers, April 15, 2018 or Mystics vs. Sun, June 5, 2015), processing each play in each game file, and generating a Turtle file that contains all of the plays from each game.
Here's an article by that explains gives some more detail about the project: NBA analytics and RDF graphs: Game, data, and metadata evolution, and Occam's razor
Here's an example of an analysis that you can do with pbprdf: Analysis: 3-point shot percentage after other team makes or misses
Running pbprdf
To run pbprdf, download the latest release from the Releases page: https://github.com/andrewstellman/pbprdf/releases and make sure Java 8 or later is in your path.
The release distribution contains an archive with the following files:

pbprdf.jar - the binary
pbprdf - Mac/Unix shell script to run pbprdf
pbprdf.bat - Windows batch file to run pbprdf
shell scripts to fetch WNBA or NBA play-by-play files

Example: Analyze a set of games
Step 1: Download a set of play-by-play HTML files
$ ./fetch-wnba-play-by-plays.sh

This will create a folder called data/retrieved_* (with a timestamp at the end of the folder name) with subdirectories for various seasons and playoffs. Move the folder for a season or playoff into the current folder (in this example, the folder with the 2014 playoffs):
$ mv data/retrieved_*/wnba-2018-playoffs .

Step 2: Run pbprdf and generate the Turtle file for the 2014 WNBA playoffs
$ ./pbprdf wnba-2018-playoffs/ wnba-2018-playoffs.ttl

Step 3: Import the Turtle file into RDF4J Server
*(see instructions at the bottom for spinning up an RDF4J server, loading data into it, and connecting to it with the RDF4J console)
$ console -s http://localhost:8080/rdf4j-server pbprdf-database
Type 'help' for help.
pbprdf-database> load wnba-2014-playoffs.ttl into http://stellman-greene.com/pbprdf/wnba-2014-playoffs
Loading data...
Data has been added to the repository (20410 ms)

If your file is large, you can use zip or gzip to compress it. Make sure it has the extension .ttl.zip:
$ ./fetch-nba-play-by-plays.sh
$ ./pbprdf data/nba-2017-2018-season/ nba-2017-2018-season.ttl
$ zip nba-2017-2018-season.ttl.zip nba-2017-2018-season.ttl
$ console -s http://localhost:8080/rdf4j-server pbprdf-database
Type 'help' for help.
pbprdf-database> load nba-2017-2018-season.ttl.zip into http://stellman-greene.com/pbprdf/nba-2017-2018
Loading data...
Data has been added to the repository (427100 ms)

See 'Setting up RDF4J Server' below for details on setting up RDF4J server
Step 4: Run SPARQL queries
pbprdf-database> SPARQL
enter multi-line SPARQL query (terminate with line containing single '.')
BASE <http://stellman-greene.com/>
SELECT ?teamName (COUNT(*) AS ?foulsDrawn) WHERE { 
  ?fouledPlayer pbprdf:foulDrawnBy ?player .
  ?roster pbprdf:hasPlayer ?player .
  ?roster rdfs:label ?teamName .
}
GROUP BY ?teamName
ORDER BY ?foulsDrawn
.
Evaluating SPARQL query...
+-------------------------------------+-------------------------------------+
| teamName                            | foulsDrawn                          |
+-------------------------------------+-------------------------------------+
| ""Sparks""                            | ""10136""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Sun""                               | ""12101""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Mystics""                           | ""12882""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Lynx""                              | ""13129""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Storm""                             | ""13452""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Dream""                             | ""13457""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Stars""                             | ""13932""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Liberty""                           | ""13954""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Mercury""                           | ""13992""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Fever""                             | ""13997""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Shock""                             | ""14329""^^<http://www.w3.org/2001/XMLSchema#integer>|
| ""Sky""                               | ""14909""^^<http://www.w3.org/2001/XMLSchema#integer>|
+-------------------------------------+-------------------------------------+
12 result(s) (1033 ms)

NOTE: You may need to add BASE and PREFIX lines to the top of your query:
BASE <http://stellman-greene.com/>
PREFIX pbprdf: <#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

Example: Load the ontology into RDF4J Server
Step 1: Generate the ontology
$ ./pbprdf --ontology ontology.ttl

Step 2: Load the ontology into its own context
pbprdf-database> load ontology.ttl into http://stellman-greene.com/pbprdf/ontology
Loading data...
Data has been added to the repository (18 ms)

Step 3: Execute a query that retrieves only the data in the ontology
pbprdf-database> SPARQL
enter multi-line SPARQL query (terminate with line containing single '.')
SELECT *
FROM NAMED <http://stellman-greene.com/pbprdf/ontology>
WHERE {
  GRAPH ?graph {
    ?class a owl:Class
  }
}
.
Evaluating SPARQL query...
+-------------------------------------+-------------------------------------+
| graph                               | class                               |
+-------------------------------------+-------------------------------------+
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Block                        |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Event                        |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Play                         |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Shot                         |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Ejection                     |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:EndOfGame                    |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:EndOfPeriod                  |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Enters                       |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:FiveSecondViolation          |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Foul                         |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Game                         |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:JumpBall                     |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Player                       |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Rebound                      |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Roster                       |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Team                         |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:TechnicalFoul                |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Timeout                      |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:Turnover                     |
| <http://stellman-greene.com/pbprdf/ontology>| pbprdf:playerEjected                |
+-------------------------------------+-------------------------------------+
20 result(s) (60 ms)

Other Useful Queries
Clutch Shots
SELECT ?playerName ?shotsTaken ?shotsMade ?shotPercentage
WHERE 
{ 
  ?player a pbprdf:Player .
  ?player rdfs:label ?playerName .
  
  # Find the number of shots taken
  {
    SELECT ?player (COUNT(?shot) AS ?shotsTaken)
    WHERE 
    {
      ?shot a pbprdf:Shot .
      ?shot pbprdf:shotBy ?player .
      ?shot pbprdf:secondsLeftInPeriod ?secondsLeftInPeriod .
      FILTER (?secondsLeftInPeriod < 5)
    }
    GROUP BY ?player 
  }

  # Find the number of shots made
  {
    SELECT ?player (COUNT(?shot) AS ?shotsMade)
    WHERE 
    {
      ?shot a pbprdf:Shot .
      ?shot pbprdf:shotBy ?player .
      ?shot pbprdf:shotMade ""true""^^xsd:boolean .
      ?shot pbprdf:secondsLeftInPeriod ?secondsLeftInPeriod .
      FILTER (?secondsLeftInPeriod < 5)
    }
    GROUP BY ?player 
  }
  
  # Calculate the shot percentage
  BIND ( (round((?shotsMade / ?shotsTaken) * 10000)) / 100 AS ?shotPercentage ) .
  
  # Only match players who took more than 10 shots just before the end of the period
  FILTER (?shotsTaken >= 15) .
}
ORDER BY DESC(?shotPercentage)

Shots made and missed at Target Center in the first five minutes
SELECT ?game ?gameTime ?shotsTaken ?shotsMade ?shotsMadePercentage ?shotsMissed ?shotsMissedPercentage
WHERE 
{ 
  ?game a pbprdf:Game .
  ?game pbprdf:gameTime ?gameTime .
  ?game pbprdf:gameLocation ""Target Center, Minneapolis, MN"" .

  # Find the number of shots made per game
  {
    SELECT ?game (COUNT(?madeShot) AS ?shotsMade) {
      ?madeShot a pbprdf:Shot .
      ?madeShot pbprdf:inGame ?game .
      ?madeShot pbprdf:shotMade ?made .
      ?madeShot pbprdf:shotMade ""true""^^xsd:boolean .
      ?madeShot pbprdf:secondsIntoGame ?secondsIntoGame .
      FILTER (?secondsIntoGame < 300)
    }
    GROUP BY ?game
  }
  
  # Find the number of shots missed per game
  {
    SELECT ?game (COUNT(?missedShot) AS ?shotsMissed) {
      ?missedShot a pbprdf:Shot .
      ?missedShot pbprdf:inGame ?game .
      ?missedShot pbprdf:shotMade ?made .
      ?missedShot pbprdf:shotMade ""false""^^xsd:boolean .
      ?missedShot pbprdf:secondsIntoGame ?secondsIntoGame .
      FILTER (?secondsIntoGame < 300)
    }
    GROUP BY ?game
  }
  
  BIND ((?shotsMade + ?shotsMissed) AS ?shotsTaken) .
  BIND ( (round((?shotsMade / ?shotsTaken) * 10000)) / 100 AS ?shotsMadePercentage ) .
  BIND ( (round((?shotsMissed / ?shotsTaken) * 10000)) / 100 AS ?shotsMissedPercentage ) .
}
LIMIT 100

Setting up RDF4J Server
One effective way to execute SPARQL queries against these files is to use RDF4J Server, Workbench, and Console. RDF4J Server and its GUI, RDF Workbench, are both web applications that run in an application server like Tomcat.
Step 1: Download RDF4J
Download and extract the latest RDF4J SDK. It will contain a bin folder with the console binary, and a war folder with the rdf4j-server.war and rdf4j-workbench.war web applications.
Step 2: Install Apache Tomcat
This usually just involves downloading and extracting the Tomcat binaries, editing libexec/conf/tomcat-users.xml to add a user with tomcat and manager-gui permissions, and executing catalina run to start the server.
Step 3: Open the Apache Tomcat App Manager (http://localhost:8080/manager/html) and deploy the web applications
Use the app manager GUI to deploy the rdf4j-server.war and rdf4j-workbench.war web applications to your Tomcat installations.
Step 4: Use the RDF4J console to create a database
Create a Native database with spoc,sopc,opsc,ospc,posc, and psoc indexes. This will take disk space for the indexes, but will make your queries run much faster.
$ cd eclipse-rdf4j-2.3.2/bin/
$ ./console.sh -s http://localhost:8080/rdf4j-server 
Connected to http://localhost:8080/rdf4j-server
RDF4J Console 2.3.2+496af9c

2.3.2+496af9c
Type 'help' for help.
> create native-rdfs
Please specify values for the following variables:
Repository ID [native]: pbprdf-database
Repository title [Native store with RDF Schema inferencing]: PBPRDF Database
Query Iteration Cache size [10000]: 
Triple indexes [spoc,posc]: spoc,sopc,opsc,ospc,posc,psoc
EvaluationStrategyFactory [org.eclipse.rdf4j.query.algebra.evaluation.impl.StrictEvaluationStrategyFactory]: 
Repository created
> open pbprdf-database
Opened repository 'pbprdf-database'
pbprdf-database> 

Step 5: Import your Turtle file
You can use the instructions above to import your *.ttl or *.ttl.zip files into your newly created database. You can either use the RDF4J console or RDF4J workbench GUI to execute SPARQL queries.
Building pbprdf
Prerequisite: sbt 1.x and Java 8 or later must be in your path

Installing SBT
Install sbt 1.x on Mac
Install sbt 1.x on Unix
Install sbt 1.x on Windows

Mac or Unix:
$ git clone https://github.com/andrewstellman/pbprdf.git
$ cd pbprdf
$ sbt assembly
$ ./pbprdf

Windows:
C:\Users\Public\src>git clone https://github.com/andrewstellman/pbprdf.git
C:\Users\Public\src>cd pbprdf
C:\Users\Public\src\pbprdf>sbt assembly
C:\Users\Public\src\pbprdf>pbprdf

(The above commands use sbt-assembly to create a fat JAR.)
Other useful build commands
Compile the code and run the unit tests:
$ sbt compile test

Generate Eclipse project files (via sbteclipse:
$ sbt eclipse

Generate sample Turtle from the unit test data and print it to the console
using the script:
$ ./pbprdf src/test/resources/com/stellmangreene/pbprdf/test/htmldata/

via SBT:
$ sbt ""run src/test/resources/com/stellmangreene/pbprdf/test/htmldata/""



",HTML
32,"



README.md




March-Madness-2017
Kaggle Competition for Predicting NCAA Basketball Tourney Games. Link to the associated blog post I wrote.

March Madness 2017.ipynb - File with all the main data anaylsis and machine learning models.
Machine Learning and Data Analysis.ipynb - More for experimental models and a couple more data visualizations.
Predictions for 2017 Bracket.ipynb - Shows you how to create the prediction CSV file in a format that is suitable for Kaggle.
Applying Deep Learning.ipynb - Tried deep learning models (TLDR: They didn't really work)

Round 2 (March Madness 2018)


",Python
33,"



README




The shell script ""demo.sh"" loads scraped data alias tables
between the two data sets (NCAA and Basketball Reference)
for schools and players. It then runs sample R code that does
a simple stepwise regression to detect some NCAA features
that impact NBA playing time 1 year out from the draft.

You won't be able to run these without installing PostgreSQL,
R etc., but I've included two text files showing the results. The
first is ""script_output.txt"" which shows the output of the ""demo.sh""
script (including the total time take - about 12 seconds).

The file ""feature_selection.txt"" shows the results of the stepwise
regression.

This is the final model - no surprise, the pick number dominates
in a non-linear way. Also settled on were height, position, games,
assists per game and steals per game. I did not examine any
interaction terms, nor did I look at other measures of NBA value,
but these are straightforward given the database (up to the
limitations of my scraped data, of course).

I haven't adjusted college performance for NCAA strength of
schedule yet.


",PLpgSQL
34,"











NBA-Search
System Design
Building locally
Contributing
Dependencies





README.md




NBA-Search
This is an NBA Analytics website with multiple components such as a chatbot, blogs, and predictions. All the data for the site is being scraped from Basketball Reference. This project is made possible by the hard working members of the open source community!
System Design

Building locally


Clone the repository locally:
git clone https://github.com/skekre98/NBA-Search.git



Run the following command to set up all necessary dependencies:
./setup.sh


you will likely need to give the setup script permission to execute



Run the following command to deploy the web app on your localhost:
python main.py run







Run the following command to run the unit tests:
python main.py test

You can also add you own unit tests in test.py

Contributing
There is a lot to do so contributions are really appreciated! This is a great project for early stage developers to work with.
To begin it is recommended to start with issues labelled as good first issue.
How to get started:

Fork the NBA-Search repo.
Create a new branch in you current repo from the 'master' branch with issue label.
'Check out' the code with Git or GitHub Desktop
Check contributing.md
Push commits and create a Pull Request (PR) to NBA-Search

Dependencies

Flask - The framework used to build the web app.
Beautiful Soup - The HTML parser used for web scraping.
Sklearn - The machine learning library used to implement information retrieval.
Pandas - The python library used for data manipulation.



",Python
35,"











Judging Basketball Shots
Detected Basketball and Hoop
Basketball Trajectory Fit to Curve
Connected Basketball Detection Points





README.md




This is the pure source python version (without Flask) of the main project AI Basketball Analysis
Judging Basketball Shots

Orange: Detected hoop
Blue: Detected basketball
Purple: Undetermined shot
Red: Miss
Green: Shot went in




Detected Basketball and Hoop



Basketball Trajectory Fit to Curve



Connected Basketball Detection Points





",Python
36,"











d3.basketball-shot-chart
Setup
Examples
To use:
Options





README.md




d3.basketball-shot-chart
This visualization aims to become a generic means of generating charts on a basketball court. Currently it only supports hexbin shot charts, with lots of flexibility, but is alpha quality and will be refactored to support other binning mechanisms and other mark types on top of a basketball court.
Currently customizable:

Court dimensions/lines
Binning definition
Hexagon size range and color range
Integrating different shot chart datasets
Titles and labels

Setup

Include d3.js
Include hexbin.js d3.hexbin - NOTE: this is a fork
Include d3.chart.js - d3.chart
Include d3.chart.defaults.js d3.chart.defaults
Include d3.basketball-shot-chart.js
Include d3.basketball-shot-chart.css (or include the sass file)

Examples
This library is currently used to generate the shot charts at tothemean, and there's a blog post that walks through using this chart.
If you clone the repo, you'll also find a simple example in the example directory.
To use:
Generally, you likely have some shot chart data that's an array of data points representing shots, including the x, y position on the court, and whether the shot was made:
  var data = [{""x"":2,""y"":9,""made"":1},{""x"":2,""y"":8,""made"":1},...];

You can continue with this, or you can also self aggregate to reduce the size/complexity of the data, and capture number of makes and attempts at a location:
  var data = [{""x"":2,""y"":9,""made"":3,""attempts"":3},{""x"":2,""y"":8,""made"":0,""attempts"":4},...];

NOTE: Even in this scheme, a point for the same location can be repeated, as all points will be aggregated as part of the binning process (which is how we handle the first simple case).
Once we have our data, we can quickly chart it:
  var chart = d3.select(el)
    .append(""svg"")
    .chart(""BasketballShotChart"")
      .draw(data); 
By default, the shot chart visualization recognizes the data structure above, but that can easily be configured with the options below. Also, by default, the heat chart is based on a range of shooting 0% to 100%. Most shot charts you've probably seen compare to the average, and its up to you to calculate that, but you can use the options below to update the range of values for the heatMap, and to make the hexagon colors or radiuses based on any value from your data you want.
Options
You can pass any of these options when creating a new chart. You can change them through public setters, but the shot chart won't autoimically pick them up - yet.
These are all defined in the code, and I recommend looking there for more information on how they're actually utilized.

basketDiameter: basketball hoop diameter (ft) (default: 1.5)
basketProtrusionLength: distance from baseline to backboard (ft) (default: 4)
basketWidth: backboard width (ft) (default: 6)
colorLegendTitle: title of hexagon color legend (default: 'Efficiency')
colorLegendStartLabel: label for starting of hexagon color range (default: '< avg')
colorLegendEndLabel: label for ending of hexagon color range (default: '> avg')
courtLength: full length of basketball court (ft) (default: 94)
courtWidth: full width of basketball court (ft) (default: 50)
freeThrowLineLength: distance from baseline to free throw line (ft) (default: 19)
freeThrowCircleRadius: radius of free throw line circle (ft) (default: 6)
heatScale: d3 scale for hexagon colors (default: d3 quantize scale if [0, 1] domain and colors from Goldsberry's shot charts)
height: height of svg, specifying won't change scale of chart (default: undefined)
hexagonBin: method of aggregating points into a bin (e.g. function (point, bin) {...}) (default: bins by aggregating makes and attempts from points)
hexagonBinVisibleThreshold: how many points does a bin need to be visualized (default: 1)
hexagonFillValue: method to determine value to be used with specified heatScale (e.g. function (bin) {...}) (default: returns bin.made/bin.attempts)
hexagonRadius: bin size with regards to courth width/height (ft) (default: .75)
hexagonRadiusSizes: discrete hexagon size values that radius value is mapped to, intentionally hides low frequency points (default: [0, .4, .6, .75])
hexagonRadiusThreshold: how many points in a bin to consider it while building radius scale (default: 2)
hexagonRadiusValue: method to determine radius value to be used in radius scale (e.g. function (bin) {...}) (default: returns bin.attempts)
keyMarkWidth: width of key marks (dashes on side of the paint) (ft) (default: .5)
keyWidth: width the key (paint) (ft) (default: 16)
restrictedCircleRadius: radius of restricted circle (ft) (default: 4)
sizeLegendTitle: title of hexagon size legend (default: 'Frequency')
sizeLegendSmallLabel: label of start of hexagon size legend (default: 'low')
sizeLegendLargeLabel: label of end of hexagon size legend (default: 'high')
threePointCutoffLength: distance from baseline where three point line because circular (ft) (default: 14)
threePointRadius: distance of three point line from basket (ft) (default: 23.75)
threePointSideRadius: distance of corner three point line from basket (ft) (default: 22)
title: title of chart (default: 'Shot chart')
translateX: method to determine x position of a bin on the court (default: x value)
translateY: method to determine y position of a bin on the court (default: flips y axis to opposite side of court)
width: width of svg (default: 500)



",HTML
37,"














AI Basketball Games Video Editor
0. Environments
0.1 Get a copy
0.2 Create virtual environments
0.3 Requirements
1. Weights Download
1.1 darknet2pytorch
1.2 tensorrt
2. Use AI Basketball Games Video Editor
2.1 Prepare your basketball video
2.2 Prepare output folder
2.3 Run the demo





README.md




AI Basketball Games Video Editor




AI Basketball Games Video Editor is a command-line program to get basketball highlight video by PyTorch YOLOv4 object  detection.
Analyze basketball and basketball hoop locations collected from  object detection.
It can get shot frame index and cut video frame to merge highlight video.
├── README.md
├── video_editor.py                   demo to get basketball highlight video
├── pytorch_YOLOv4                    pytorch-YOLOv4 source code
│   ├── weights                       need to download weights
│   └── ...
├── tool
│   ├── utils_basketball.py           detect basketball shots algorithm
│   └── utils.py                  
├── dataset
│   └── your_video_name.mp4
├── result
│   ├── obj_log_name.data             save frame information and object detect result
│   └── your_output_video_name.mp4   






0. Environments
0.1 Get a copy
git clone https://github.com/OwlTing/AI_basketball_games_video_editor.git
0.2 Create virtual environments
conda create --name py36_env python=3.6
conda activate py36_env
cd AI_basketball_games_video_editor
0.3 Requirements
Debian 10
python 3.6
numpy
pandas
tqdm
cv2
pytorch 1.3.0
Please refer to the official documentation for installing pytorch https://pytorch.org/get-started/locally/
More details for different cuda version https://pytorch.org/get-started/previous-versions/
Example:
conda install pytorch==1.3.0 torchvision==0.4.1 cudatoolkit=10.0 -c pytorch
Optional (For tensorrt yolov4 object detector engine):
tensorrt 7.0.0
Please refer to the official documentation for installing tensorrt with different cuda version
https://docs.nvidia.com/deeplearning/tensorrt/install-guide/index.html
Example: (For Debian 10 cuda 10.0)

mkdir tensorrt
From https://developer.nvidia.com/tensorrt, to download
TensorRT-7.0.0.11.Ubuntu-18.04.x86_64-gnu.cuda-10.0.cudnn7.6.tar.gz
(select TensorRT 7.0) in the directory tensorrt/
tar xzvf TensorRT-7.0.0.11.Ubuntu-18.04.x86_64-gnu.cuda-10.0.cudnn7.6.tar.gz
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/<path_your_tensorrt>/TensorRT-7.0.0.11/lib
cd TensorRT-7.0.0.11/python/
pip install tensorrt-7.0.0.11-cp36-none-linux_x86_64.whl


sudo cp /<path_your_tensorrt>/TensorRT-7.0.0.11/lib/libnvinfer.so.7 /usr/lib/ ;  
sudo cp /<path_your_tensorrt>/TensorRT-7.0.0.11/lib/libnvonnxparser.so.7 /usr/lib/ ;  
sudo cp /<path_your_tensorrt>/TensorRT-7.0.0.11/lib/libnvparsers.so.7 /usr/lib/ ;  
sudo cp /<path_your_tensorrt>/TensorRT-7.0.0.11/lib/libnvinfer_plugin.so.7 /usr/lib/ ;  
sudo cp /<path_your_tensorrt>/TensorRT-7.0.0.11/lib/libmyelin.so.1 /usr/lib/  


pip install pycuda

1. Weights Download
1.1 darknet2pytorch

google(https://drive.google.com/file/d/15waE6I1odd_cR3hKKpm1uXXE41s5q1ax)
mkdir pytorch_YOLOv4/weights/
download file yolov4-basketball.weights in the directory pytorch_YOLOv4/weights/

1.2 tensorrt

google(https://drive.google.com/file/d/1_c8uhyi47Krs5gAbRR66zzYKaxGNnzEs)
mkdir pytorch_YOLOv4/weights/
download file yolov4-basketball.trt in the directory pytorch_YOLOv4/weights/

2. Use AI Basketball Games Video Editor
2.1 Prepare your basketball video

download your basketball video in the directory dataset/

2.2 Prepare output folder

mkdir result

2.3 Run the demo
python video_editor.py --video_path VIDEO_PATH --output_path OUTPUT_PATH --output_video_name OUTPUT_VIDEO_NAME [OPTIONS]

# example
python video_editor.py --video_path dataset/basketball_demo.mp4 --output_path result/demo --output_video_name out_demo.mp4


It will generate your_output_video_name.mp4 obj_log_name.data in the directory result/


If you had finished extracting features. You can use --read_flag 1 to read log for different output video mode.


If you use pytorch yolov4 object detector engine --inference_detector pytorch.
For image input size, you can select any inference_size = (height, width) in
height = 320 + 96 * n, n in {0, 1, 2, 3, ...}
width = 320 + 96 * m, m in {0, 1, 2, 3, ...}
Exmaple --inference_size (1184, 1184) or --inference_size (704, 704)
Default inference_size is (1184, 1184)


If you use tensorrt yolov4 object detector engine --inference_detector tensorrt.
For image input size, you only can select --inference_size (1184, 1184).
Tensorrt engine 3x faster than pytorch engine fps.


You can use --output_mode shot to select different output video mode.
output video mode  
full            show person basketball basketball_hoop frame_information  
basketball      show basketball basketball_hoop frame_information  
shot            show basketball shot frame_information  
standard        show frame_information  
clean           only cutting video








You can refer the command-line options.
optional arguments:
-h, --help                                       show this help message and exit

--video_path VIDEO_PATH                          input video path (default: None)
                                                 
--output_path OUTPUT_PATH                        output folder path (default: None)
                                                 
--output_video_name OUTPUT_VIDEO_NAME            output video name (default: None)
                                                 
--highlight_flag HIGHLIGHT_FLAG                  select 1 with auto-generated highlight or 
                                                 0 without auto-generated highlight (default: 1)
                                                 
--output_mode OUTPUT_MODE                        output video mode 
                                                 full       show person basketball basketball_hoop frame_information 
                                                 basketball show basketball basketball_hoop frame_information 
                                                 shot       show basketball shot frame_information 
                                                 standard   show frame_information 
                                                 clean      only cutting video (default: shot)
                                                 
--process_frame_init PROCESS_FRAME_INIT          start processing frame (default: 0)
                                                 
--process_frame_final PROCESS_FRAME_FINAL        end processing frame. If process_frame_final < 0, 
                                                 use video final frame (default: -1)
                                                 
--obj_log_name OBJ_LOG_NAME                      save frame information and obj detect result 
                                                 (default: obj_log_name.data)
                                                 
--save_step SAVE_STEP                            save obj log for each frame step (default: 2000)
                                                 
--weight_path WEIGHT_PATH                        Yolov4 weight path (default: pytorch_YOLOv4/weights/yolov4-basketball.weights)
                                                 
--cfg_path CFG_PATH                              Yolov4 cfg path (default: pytorch_YOLOv4/cfg/yolov4-basketball.cfg)

--num_classes NUM_CLASSES                        num classes = 3 (person/basketball/basketball_hoop) (default: 3)
                                                 
--namesfile_path NAMESFILE_PATH                  Yolov4 class names path (default: pytorch_YOLOv4/data/basketball_obj.names)
                                                 
--inference_detector INFERENCE_DETECTOR          object detector engine. You can select pytorch or tensorrt (default: pytorch)
                                                 
--inference_size INFERENCE_SIZE                  Image input size for inference 
                                                 If you use pytorch yolov4 object detector engine 
                                                 height = 320 + 96 * n, n in {0, 1, 2, 3, ...} 
                                                 width = 320 + 96 * m, m in {0, 1, 2, 3, ...} 
                                                 inference_size= (height, width) 
                                                 
                                                 If you use tensorrt yolov4 object detector engine Image input size for
                                                 inference only with inference_size = (1184, 1184) (default: (1184, 1184))
                                                 
--read_flag READ_FLAG                            read log mode flag If you had finished extracting features. You can use 
                                                 select 1 to read log for different output video mode. (default: 0)
                                                                                                  
--cut_frame CUT_FRAME                            cut frame range around shot frame index for highlight video (default: 50)  



Reference:


https://github.com/Tianxiaomo/pytorch-YOLOv4


https://github.com/eriklindernoren/PyTorch-YOLOv3


https://github.com/marvis/pytorch-caffe-darknet-convert


https://github.com/marvis/pytorch-yolo3


Paper Yolo v4: https://arxiv.org/abs/2004.10934


Source code Yolo v4:https://github.com/AlexeyAB/darknet


More details: http://pjreddie.com/darknet/yolo/


@article{yolov4,
  title={YOLOv4: YOLOv4: Optimal Speed and Accuracy of Object Detection},
  author={Alexey Bochkovskiy, Chien-Yao Wang, Hong-Yuan Mark Liao},
  journal = {arXiv},
  year={2020}
}

Contact:
Issues should be raised directly in the repository.
If you are very interested in this project, please feel free to contact me (george_chen@owlting.com).


",Python
38,"














bigballR
Installation
Functionality
Use
scrape_game / get_play_by_play
get_date_games
get_team_schedule
get_team_roster
get_lineups
on_off_generator
get_player_lineups
get_player_stats





README.md




bigballR
###NOTE THIS DOCUMENTATION IS SLIGHTLY OUTDATED FOLLOWING THE LATEST PACKAGE UPDATE 1/13
bigballR is an R package for working with NCAA Basketball data. This
package primarily revolves around the use of schedule, roster, and play-by-play data via stats.ncaa.com, and
additionally has features to calculate lineups, on/off results, and player game and multi-game statistics.
Installation
First install the package devtools if you haven't already
#install.packages(""devtools"")
devtools::install_github(""jflancer/bigballR"")
Functionality
Retrieving Game IDs and Other Information
Manually, game ids can be found in the url when browsing games, for example:
4674164 is the game id for https://stats.ncaa.org/game/play_by_play/4674164

get_date_games data frame with game info and game ids for a given date.
get_team_schedule data frame with game info and ids for a given team.
get_team_roster data frame with player roster information for a given team.

Game Scraping Functions

scrape_game the base function, given a game id will return a cleaned play by play file.
get_play_by_play builds off of scrape_game, allows for compiling from multiple game ids formatted in a vector.

Data Manipulation Functions

get_lineups given play-by-play data retrieved from game scraping functions, will calculate a variety of stats for all lineups.
on_off_generator calculate on/off statistics for specified players given lineup data from get_lineups().
get_player_stats calculate a variety of player stats from play-by-play data at either a game or multi-game level.
get_player_lineups acts as an easy way to filter lineup data, specifying players to exclude/include from the lineups.

Datasets

teamids dataset includes stats.ncaa team name, team conference, season, and team id for 17-18 and 18-19 seasons

Use
There are many different progressions and ways to use this package. As an example, here are some natural steps you could take.
# Get team schedule
# Note: if you don't know the proper team.name (case sensitive), you can look it up in data(""teamids"")
schedule <- get_team_schedule(season = ""2018-19"", team.name = ""Duke"")
# Get play by play for all games played so far in season
play_by_play <- get_play_by_play(schedule$Game_ID)
# Generate all lineups and stats from the play by play
lineups <- get_lineups(play_by_play_data = play_by_play, keep.dirty = T, garbage.filter = F)
# Look at Zion Williamson's on/off statistics with lineups that include Reddish and Barrett
zion_comparison <- on_off_generator(""ZION.WILLIAMSON"", lineups, Included = c(""CAM.REDDISH"",""RJ.BARRETT""))
scrape_game / get_play_by_play
Functions to retrieve play by play data. scrape_game() works for individual games while get_play_by_play can handle a vector of gameids and will aggregate into a single dataframe. Warns users of potential errors and mistakes made by the game trackers. The number of player discrepancies warning counts displays the number of events players committed when it is found they were not on the court at the time of the event. The substitution mistake warning indicates an unclean substitution was entered. (ex. 2 players enter and 1 leaves)

game_id | string made up of digits given to each unique game. This can be found in the play-by-play url for each game.
game_ids | same function as above, but can handle character vectors of any length.

get_date_games
This function returns a schedule for the given date and specified conference. Results are included if applicable, as well as the play-by-play game id

date | a character object containing a date in the format mm/dd/yyyy. Defaults is previous day (yesterday)
conference | the common name used for a conference, not sensitive to case, spacing, punctuation, etc.
conference.ID | alternatively, if the conference ID is known it replace the conference name variable.

get_team_schedule
This function returns a data frame of the schedule for the specified team. This will include game ids used for play-by-play scraping if the game has ended, along with the team scores and attendance. Note: currently, the season/team.name parameters can only be used for the 2016-17, 2017-18, 2018-19 seasons.

team.id | The unique id given to each college/team for each season. This can be found in the url of the team page.
season | Season following format yyy1-y2, ex ""2018=19""
team.name | Alternative to using the id, you can use a team name. This follows the format found in data(ids).

get_team_roster
This function returns a data frame of the roster for the specified team. This will include player names and positions as well as jersey number, height and school year. Note: currently, the season/team.name parameters can only be used for the 2016-17, 2017-18, 2018-19 seasons.

This takes the same parameters and conditions as get_team_schedule() above

get_lineups
This function takes in a play-by-play dataframe, and generates all possible lineups for both teams. It then calculates a variety of statistics/metrics at a lineup level.

play_by_play_data | play-by-play data from the functions scrape_game() or get_play_by_play()
keep.dirty | logical to specify whether or not to filter out potentially inaccurrate data. When FALSE, will remove all rows from games where the number of discrepencies is above the desired count.
garbage.filter | logical variable to specify whether or not to filter out garbage time entries.
error.thresh | lets user set their preferred discrepancy threshold with the keep.dirty variable. This means when less than the threshold occurs in a game, it will be considered clean. As defined in scrape_game(), a discrepancy occurs when a player registers an event when they are not found to be on the court.

on_off_generator
This function passes in lineup data and calculates the on/off lineup statistics for all lineup combinations of players specified. This allows users to view on/off statistics for individual players, as well as combinations of multiple players. Users can also specify if they'd like specific players to be included or excluded from all lineups in use

Players | players desired to be compared with on/off
Lineup_Data | lineups collected from the get_lineups() function
Included These Players will be on the court for every lineup considered.
Excluded These players will be off the court for every lineup considered.

get_player_lineups
This function finds all lineups from a given lineup data source that include/exclude certain players. It acts as a quick way to filter lineups for players.

Takes same parameters as on_off_generator() with exception to the Players parameter

get_player_stats
This function calculates many player stats for either individual games or aggregate to get multi-game stats.

Takes all parameters described in get_lineups() function
multi.games | When false stats will be calculated on a game level. When true all games will be aggregated.



",R
39,"











sports.py
Installation
Usage





README.md









sports.py
Gather live up-to-date sports scores. Baseball, basketball, cricket, football, handball, hockey, rugby, soccer, tennis, and volleyball currently functional
Scrapes data from:

scorespro.com
pro-football-reference.com
baseball-reference.com
basketball-reference.com
hockey-reference.com

Installation
Python >= 3.5
pip install sports.py
Usage
import sports
Valid sports:

Baseball: sports.BASEBALL
Basketball: sports.BASKETBALL
Cricket: sports.CRICKET
Football: sports.FOOTBALL
Handball: sports.HANDBALL
Hockey: sports.HOCKEY
Rugby Union: sports.RUGBY_U
Rugby League: sports.RUGBY_L
Soccer: sports.SOCCER
Tennis: sports.TENNIS
Volleyball: sports.VOLLEYBALL

Get a single match
get_match() takes three parameters:

sport: Name of sport being played (see above for a list of valid sports)
team1: Name of city or team in a match (Not case-sensitive)
team2: Name of city or team in a match (Not case-sensitive)

get_match() returns a single Match object which contains the following properties:

sport: Sport of the match
league: League of the match
home_team: Home team
away_team: Away team
home_score: Home team score
away_score: Away team score
match_time: Current match time
match_date: Date the match was played
match_link: Link to an XML file containing match data

match = sports.get_match(sports.TENNIS, 'Murray', 'Federer')
Get multiple matches
get_sport() takes one parameter:

sport: Name of sport (see above for list of valid sports)

get_sport() returns a list of Match objects which contain the same properties described above
matches = sports.get_sport(sports.BASKETBALL)
Get all live matches
all_matches() returns a dictionary of Match objects grouped by sport conatining data from all live matches.
all_matches = sports.all_matches()
baseball = all_matches['baseball']
Get extra team info
Only works with MLB, NBA, NFL, and NHL teams
Get team information including overall record, championships won and more.
get_team() takes two parameters:

sport: Sport of the team the find
team: Name of city or team to find (Not case-sensitive)

Properties available to all valid teams/sports:

name: Name of the team
seasons: Total number of seasons played
record: Overall regular season record
champs: Number of total championships (Includes pre-merger champs for NFL)
leaders: Overall team leaders for certain statistical categories
raw: Dictionary containing all gathered info

Properties available to only MLB teams:

pennants: Total number of AL/NL championships

Properties available to only NFL teams:

super_bowls: Total number of Super Bowls

Properties available to only NHL teams:

points: Total number of regular season points earned

Properties available to both NFL/NHL teams:

playoff_record: Overall playoff record

Properties available to MLB, NBA, NHL teams:

playoff_app: Total number of playoff appearances

pirates = sports.get_team(sports.BASEBALL, 'pirates')
print(pirates.pennants)

penguins = sports.get_team(sports.HOCKEY, 'penguins')
print(penguins.points)

steelers = sports.get_team(sports.FOOTBALL, 'steelers')
print(steelers.super_bowls)

sixers = sports.get_team(sports.BASKETBALL, '76ers')
print(sixers.playoff_app)


",Python
40,"



README




DEPENDENCIES:
theano: http://deeplearning.net/software/theano/
numpy
scipy
(optional) matplotlib: http://matplotlib.sourceforge.net/

Note: maccam912 reports that the link above is currently down (Feb 28, 2012) but says, ""I see you can still get it with 'easy_install Theano' or downloading it from http://pypi.python.org/pypi/Theano or the repo on github. Just a heads up. I don't use git or github often so I wasn't sure if the issues section was the place to point this out or not.""


DATA:
Right now, only the aggregate data is really being used.  To check that 
you can load the data properly, run

> python march_madness_data.py

this should output the following:
Skipped 1426 entries due to UNK
After loading simple data
2006-2007: 5125 games
2007-2008: 5248 games
2008-2009: 5332 games
2009-2010: 5363 games
After removing tournament games
2006-2007: 5047 games
2007-2008: 5161 games
2008-2009: 5237 games
2009-2010: 5269 games

So it loaded about 5000 games from each of 4 past seasons.  

If you'd like to dig into the full data, look for 

def load_full_data(self):

in march_madness_data.py.


BRACKET:
We don't have data that specifically identifies which games were a part 
of the tournament, so we do it programmatically.  Most of the code is
called automatically when you make a MarchMadnessData object.  To see the
results, you can run

> python bracket.py

This should output the filled-in tournament bracket for previous seasons.
It should look like this:

2008-2009
nav---nav---nav---nav---nav---nav
raa     |     |     |     |     |   
lav---lav     |     |     |     |   
bav           |     |     |     |   
              |     |     |     |   
gaj---gaj---gaj     |     |     |   
aac     |           |     |     |   
wao---wao           |     |     |   
iae                 |     |     |   
                    |     |     |   
oae---oae---oae---oae     |     |   
mbq     |     |           |     |   
max---max     |           |     |   
cbg           |           |     |   
              |           |     |   
sci---sci---sci           |     |   
scc     |                 |     |   
aar---aar                 |     |   
tad                       |     |   

...

The three-letter code mappings to team names are in ./data/YahooTeamCodeMapping.csv.


LEARNING:
There is also starter code for learning, but this is still in progress.

The simplest thing to try is to run

> python learn_synthetic.py

This will run learning with the simplest model, on synthetic data.  The first run
will take a bit longer at startup, because theano is doing the symbolic differentiation.


You can then move on to

> python learn_real.py

This will learn, but on the real data now.  This code is not finished, but it should be
enough structure to get you started.

In model.py, you can see three different models, of increasing level of complexity.  You
can select between these in the learn_*.py scripts.


Some TODOs for the ambitious:

- Load the full data and verify it against the aggregate data.

- Set up a proper validation/testing framework, so we can evaluate different methods
  properly.  Perhaps we want to do leave-one-out cross validation.

- Try different objective functions in the theano models -- what do we actually
  want to optimize?

- Think about how to better include pace of the game

- Improve the optimization (maybe using momentum, LBFGS, or conjugate gradients?)

",Python
41,"














BasketballGAN
Generate the ghosting defensive strategies given offensive sketch.
Paper | CGVLabVideo | Supplemental
BasketballGAN: Generating Basketball Play Simulation through Sketching
Prerequisites
Getting Stated
Download Dataset
Training
Logs/Samples/Checkpoints
Monitoring
Public Relations
Citation





README.md





BasketballGAN
Generate the ghosting defensive strategies given offensive sketch.


Paper | CGVLabVideo | Supplemental
BasketballGAN: Generating Basketball Play Simulation through Sketching
Hsin-Ying Hsieh1, Chieh-Yu Chen2, Yu-Shuen Wang1 and Jung-Hong Chuang1
1National Chiao Tung University,
2NVIDIA Corporation
Accepted paper in ACMMM 2019.
Prerequisites

OS: Linux
NVIDIA Dokcer
NVIDIA NGC Tensorflow Docker Image
NVIDIA GPU (V100 16GB)

Getting Stated
~$ git clone https://github.com/chychen/BasketballGAN.git
~$ cd BasketballGAN
BasketballGAN$ docker login nvcr.io
BasketballGAN$ docker pull nvcr.io/nvidia/tensorflow:19.06-py2
BasketballGAN$ docker run --runtime=nvidia -it --rm -v $PWD:$PWD --net host nvcr.io/nvidia/tensorflow:19.06-py2 bash
root@c63207c81408:~/BasketballGAN$ apt update
root@c63207c81408:~/BasketballGAN$ apt install ffmpeg
Download Dataset

create 'data' folder
save dataset under folder 'data'

BasketballGAN$ mkdir data
Training
BasketballGAN$ cd src
BasketballGAN/src$ python Train_Triple.py --folder_path='tmp' --data_path='data'
Logs/Samples/Checkpoints
- ""BasketballGAN/src/tmp/Log"": training summary for tensorboard.
- ""BasketballGAN/src/tmp/Samples"": generated videos sampled on different epoches.
- ""BasketballGAN/src/tmp/Checkpoints"": tensorflow checkpoints on different iterations.
Monitoring

Sampled Videos

Using Simple HTTP Server to monitor sampled videos while training.
Simple HTTP Server (http://127.0.0.1:8000)



BasketballGAN/src$ python -m http.server 8000

Training Logs

Tensorboard (127.0.0.1:6006)



BasketballGAN/src$ tensorboard --logdir='tmp/Log'

Public Relations

AAAS Science News
Deeplearning.ai FB
Deeplearning.ai The Batch
NVIDIA GTC 2020 Poster

Citation
If you find this useful for your research, please use the following.
@article{hsieh2019basketballgan,
  title={BasketballGAN: Generating Basketball Play Simulation Through Sketching},
  author={Hsieh, Hsin-Ying and Chen, Chieh-Yu and Wang, Yu-Shuen and Chuang, Jung-Hong},
  journal={arXiv preprint arXiv:1909.07088},
  year={2019}
}



",Python
42,"



README.md




2D Ball Shootout Unity3d [Source Code]
If you have any questions -> http://twitter.com/skakac

https://play.google.com/store/apps/details?id=com.skakac.bshootout
Ball Shootout game 
Super simple basketball game, using popular idea with some changes.
You can try out 2 player multiplayer mode, and compete on global leaderboard.

How to play:
1. Touch the screen.
2. Drag to change predicted path.
3. Release. 
4. You can always drag and release behind the basket to release without shooting the ball. 
5. In options menu you can change shoot power. 
Follow on twitter: http://twitter.com/skakac


",C#
43,"



README.md




BasketBallARKit
Hello Everyone, This project talks about basics of ARKit introduced by Apple in iOS11. Please note that ARKit is only capable wih
devices which use A9, A10, A11 chips and the devices that use these chips are:
a) iPhone 6s and 6s Plus
b) iPhone 7 and 7 Plus
c) iPhone SE
d) iPad Pro (9.7, 10.5 or 12.9) – both first-gen and 2nd-gen
e) iPad (2017)
f) iPhone 8 and 8 Plus
g) iPhone X
Now coming to the project, it shows how to build a basic BasketBall app using ARKit. Taking it step by step:
PS: Please note that we have to choose Augmented Reality App as template when you create the project.

Camera Permission:

This step involves asking for permission from user for his Camera access. This can be done by adding 'Privacy - Camera Usage Description : This application will use the camera for Augmented Reality' as key-value in pair in info.plist

Adding the hoop:

After you launch the app, you just see the world infront of you through phone's camera. Now you can augment a Basketball hoop by just adding the code below:
func addBackboard(){
        guard  let backboardScene = SCNScene(named:""art.scnassets/hoop.scn"") else{return}
        guard let backboardNode = backboardScene.rootNode.childNode(withName: ""backboard"", recursively: false) else{return}
        backboardNode.position = SCNVector3(x:0.0, y:0.5, z:-3)
        
        let physicsShape = SCNPhysicsShape(node: backboardNode, options: [SCNPhysicsShape.Option.type : SCNPhysicsShape.ShapeType.concavePolyhedron])
        let physicsBody = SCNPhysicsBody(type: .static, shape: physicsShape)
        backboardNode.physicsBody = physicsBody
        
        sceneView.scene.rootNode.addChildNode(backboardNode)
        currentNode = backboardNode
    }


Then we add a Tap Gesture onto the SceneView to aim the ball at the basket.
func registerTapGestureRecogniser(){
        let tap = UITapGestureRecognizer(target: self, action: #selector(handleTap(gesture:)))
        sceneView.addGestureRecognizer(tap)
    }
    
    @objc func handleTap(gesture:UIRotationGestureRecognizer){
        //scene view to be accessed
        //access the center point of the sceneview
        guard let sceneView = gesture.view as? ARSCNView else{return}
        guard let centerPoint = sceneView.pointOfView else{return}
        
        let cameraTransform = centerPoint.transform
        let cameraLocation = SCNVector3(x:cameraTransform.m41, y: cameraTransform.m42, z:cameraTransform.m43)
        let cameraOrientation = SCNVector3(x: -cameraTransform.m31, y: -cameraTransform.m32, z: -cameraTransform.m33)
        let cameraPosition = SCNVector3Make(cameraLocation.x + cameraOrientation.x, cameraLocation.y + cameraOrientation.y , cameraLocation.z + cameraOrientation.z)
        
        let ball = SCNSphere()
        let material = SCNMaterial()
        material.diffuse.contents = UIImage(named:""basketballSkin.png"")
        ball.materials = [material]
        
        let ballNode = SCNNode(geometry:ball)
        ballNode.position = cameraPosition
        
        let physcisShape = SCNPhysicsShape(geometry: ball, options: nil)
        let physicsBody = SCNPhysicsBody(type: .dynamic, shape: physcisShape)
        
        ballNode.physicsBody = physicsBody
        let forceVector:Float = 6
        ballNode.physicsBody?.applyForce(SCNVector3(x:cameraOrientation.x * forceVector, y:cameraOrientation.y * forceVector, z: cameraOrientation.z * forceVector), asImpulse:true)
        
        sceneView.scene.rootNode.addChildNode(ballNode)
        
    }


diffuse property of SCNMaterial deals with how light is rendered on the material and contents property deals with the actual parents of the material


Optional:
Moving objects in AR Space is really straight forward. Here I am posting two methods to move the hoop in XY plane in a horizontal and circuit manner:
func horizontalAction (node:SCNNode){
        let leftAction = SCNAction.move(by: SCNVector3(x:-1, y:0, z:0), duration: 2)
        let rightAction = SCNAction.move(to: SCNVector3(x:1, y:0, z:0), duration: 2)
        let actionSequence = SCNAction.sequence([leftAction , rightAction])
        node.runAction(SCNAction.repeat(actionSequence, count: 2))
    }

func roundAction(node:SCNNode){
       let upright = SCNAction.move(by: SCNVector3(x:1, y:1, z:0), duration: 2)
       let downright = SCNAction.move(to: SCNVector3(x:1, y:-1, z:0), duration: 2)
       let downLeft = SCNAction.move(by: SCNVector3(x:-1, y:-1, z:0), duration: 2)
       let upLeft = SCNAction.move(to: SCNVector3(x:-1, y:1, z:0), duration: 2)
       let actionSequence = SCNAction.sequence([upright , downright , downLeft , upLeft])
       node.runAction(SCNAction.repeat(actionSequence, count: 2))
   }



",Swift
44,"



README.md




basketball-demo


",HTML
45,"











NCAA_Hoops
Application Files:
Other Files:





README.md




NCAA_Hoops
All the code that powers my NCAA Men's Basketball R Shiny Web Application application.
Application Files:

ui.R: User Interface for web application
sever.R: Backend for web application
global.R: Pre-loads data/helper functions for web application.

Other Files:
Model_3.0.R: Control panel for everything NCAA Hoops related that the application ultimately shows:

Power Rankings
Predictions
Conference simulations and distributions
Bracketology
Ivy League simulations/playoff swing factor (not in application)

ncaa_hoop_scraper.R: An algorithim to scrape game schedule/result data from the NCAA website. This script is mostly copied (with slight modifications) from a scrape written by Prof. Jay Emerson and used in STAT 230: Introductory Data Analysis (Spring 2016).
3.0_Files/: A collection of files that are essentially the ""inner workings"" of everything done in this project. Every script in this directory contains functions. Those functions are executed in the master file, Model_3.0.R.

Ivy_Sims.R: Simulates the Ivy League Basketball season in order to estimate playoff odds and calcuates the ""Playoff Swing Factor"" of each conference game.
bracketology.R: Assembles the predicted bracket:
helpers.R: A file with miscellanious functions used throughout the project.
powerrankings.R: Computes the team rankings.
record_evaluator.R: Examines the quality of each team's resume by computing Quality Wins (as recently redefinined by the NCAA tournament selection committee), Strength of Record, and Wins Above Bubble.
rpi.R: Predictions end of season RPI for each team.
tourney_sim.R: Function for simulating college basketball tournaments with parameters left to the user. The user specifies teams (from best seed to worst seed), along with a vector of seeds. Note that after games have been played, the seeds vector must be entered in the order of highest possible seed for each given slot. For example, if we have quarterfinals where the matchups are 1 vs. 9, 2 vs. 7, 3 vs. 14, and 4 vs. 12, we'd set seeds = (1, 2, 3, 4, 12, 14, 7, 9), as 5, 6, 7, 8 are the ""chalk"" seeds occupied by 12, 14, 7, and 9 in this hypothetical 15 team tournament. The user must also enter the number of single byes, the number of double_byes, the number of simulations to run nsims, and a parameter for home court advantage, hca. If the tournament is played at a neutral site, set hca = NA. If the higher seed is always given home court advantage, set hca = ""seed"". If one team hosts the tournament (even if not the top seed), set hca = INSERT_TEAM_NAME.
Bracketology/: Collection of .csv files used in bracket creation

bids.csv: Table of tournament bids broken down by conference.
bracket.csv: The final bracket produced.
bracket_math.csv: Table of bracket metrics for all 357 Division-1 teams.
bubble.csv: Bracket metrics for the first 16 teams missing the field as at-large bids.
resumes.csv: Subset of bracket metrics (resume evaluation, strength of record, wins above bubble) produced by record_evaluator.R.
rpi.csv: Projected end of season RPI for each team. Produced by rpi.R.
historical/: A collection of files used to predict NCAA Tournament seed from the various metrics in this directory.


Info/: A collection of information used to adjust model weights and determine postseason status.

conferences.csv: List of teams with their conference, postseason eligibility status, and elimination status from automatic bid contention.
mins_YYYY.csv: Percentage of team's minutes returning during the next season. Acquired from Bart Tovrik.
recruiting.csv: 247Sports recruiting scores for each team's incoming freshman class.
transfers.csv: Data on transfers eligible to play in the 2017-18 season, pulled from http://www.barttorvik.com/trankpre.php.


History/: Some historical files of interest.
Power_Rankings/: Collection of .csv files produced by powerrankings.R.

power_rankings.csv: Ranking of all 357 teams
conf_summary.csv: Ranking of the 32 Division 1 conferences, by median ranking.
pr_by_conf.csv: Ranking of teams by YUSAG Coefficient, sorted by conference.


Predictions/:

playoffs.csv: Ivy League playoff odds.
psf.csv: Playoff Swing Factor for most recent week of Ivy League conference games.


Results/: Complete NCAA Basketball schedule/results through a given date. Sub-directories indicate the year/season, with .csv files given in NCAA_Hoops_results_day_month_year.csv format.



",R
46,"














hoopR 
Installation
Quick Start
NBA full play-by-play seasons (2002-2022) ~ 1-2 minutes
Men’s college basketball full play-by-play seasons (2006-2022) ~ 2-3 minutes
Documentation
Breaking Changes
Follow the SportsDataverse on Twitter and star this repo
Our Authors
Our Contributors (they’re awesome)
Citations





README.md





hoopR 








hoopR is an R package for
working with men’s basketball data.
The package has functions to access live play by play and box score
data from ESPN with shot locations when available. As of version 1.3.0,
hoopR is also a full NBA
Stats API wrapper with 127 functions added in this release.
It is additionally a scraping and aggregating interface for Ken
Pomeroy’s men’s college basketball statistics website,
kenpom.com. It provides users with an active
subscription the capability to scrape the website tables and analyze the
data for themselves.
Installation
You can install the CRAN version of
hoopR with:
install.packages(""hoopR"")
You can install the released version of
hoopR from
GitHub with:
# You can install using the pacman package using the following code:
if (!requireNamespace('pacman', quietly = TRUE)){
  install.packages('pacman')
}
pacman::p_load_current_gh(""sportsdataverse/hoopR"", dependencies = TRUE, update = TRUE)
Quick Start
NBA full play-by-play seasons (2002-2022) ~ 1-2 minutes
tictoc::tic()
progressr::with_progress({
  nba_pbp <- hoopR::load_nba_pbp()
})
tictoc::toc()
## 4.42 sec elapsed

## 612191 rows of NBA play-by-play data from 1312 games.

Men’s college basketball full play-by-play seasons (2006-2022) ~ 2-3 minutes
tictoc::tic()
progressr::with_progress({
  mbb_pbp <-  hoopR::load_mbb_pbp()
})
tictoc::toc()
## 12.03 sec elapsed

## 1859824 rows of men's college basketball play-by-play data from 5828 games.

Documentation
For more information on the package and function reference, please see
the hoopR documentation
website.
Breaking Changes
Full News on
Releases
Follow the SportsDataverse on Twitter and star this repo


Our Authors

Saiem Gilani



Our Contributors (they’re awesome)


Jason Lee




Billy Fryer




Citations
To cite the hoopR R package
in publications, use:
BibTex Citation
@misc{gilani_2021_hoopR,
  author = {Gilani, Saiem},
  title = {hoopR: The SportsDataverse's R Package for Men's Basketball Data.},
  url = {https://hoopR.sportsdataverse.org},
  year = {2021}
}


",R
47,"











ballr 
To install





README.md




ballr 
An R API for basketball-reference.com.  The correct pronounciation for this
package is baw-ler.






To install
(Update: It's not on CRAN as of July 2020.)
From CRAN:
install.packages(""ballr"")
The development version from GitHub:
install.packages(""devtools"")
library(devtools)
install_github(""rtelmore/ballr"")


",R
48,"











NCAA_Hoops_Play_By_Play
Examples
Assist Networks
Win Probability Charts





README.md




NCAA_Hoops_Play_By_Play
Men's College Basketball Play by Play Data
NOTE: As of 8/8/2018, the majority of functionality, including development of Play-by-Play scrapers, assist networks, and
win probability charts has moved to my new R package, ncaahoopR. Data and other miscellaneous
files will still be stored here, but core scripts whose functionally has been incorporated into the  ncaahoopR package will be updated with the package, not in this repository.
NCAA_Hoops_PBP_Scraper.R: An R file used to scrape data from ESPN. The following functions are available.

get_pbp(team): Game entire 2017-18 Season's worth of play-by-play data for a given team.
get_pbp_game(gameIDS):  Get play-by-play data for a specific vector of ESPN game ids.
get_roster(team): Get a particular team's roster.
get_schedule(team): Get a team's schedule.
get_game_ids(team): Get a vector of ESPN Game IDs for all games in which team plays in.
get_date(gameID): Gets the date of a game given an ESPN Game ID.
is.nit(gameID): Returns logical T/F whether or not the game was part of the NIT

Note that team names must adhere to ESPN naming conventions. A full dictionary of team names used by ESPN is provided in ids.csv  Note that play by play data is not available for all games.
pbp_2016_17/: A folder containing play by play csv files for each team for the 2016-17 season. Additionally, the file all_games.csv (too large for GitHub) contains all games scraped for the 2016-17 season. Each team's .csv file contains the following variables:

play_id: The index of a play in a given game
half: Overtimes denoted by 3, 4, etc.
time_remaining_half: Time left in a given period of play, as it would appear on a scoreboard.
secs_remaining: The number of seconds left in a given game.
description: A description of what happened on the given play.
home_score/away_score: Scores for the home and away teams, as denoted by ESPN. Even for neutral site games, a ""home team"" is denoted by choosing the team listed second in ESPN box scores.
away/home: Home and Away teams. See above for treatment of neutral site games.
home_favored_by: Number of points the home team is favored by, if available. (i.e. 6 corresponds with traditional Vegas line of -6.0)

pbp_2017_18/: Same as above for 2017-18 season.
Assist_Network.R: The function assist_net(team, node_col, season, rmv_bench), used to create college basketball assist networks.

team is the ESPN team name
node_col is the node color for the graph
season: Options include ""2016-17"", ""2017-18"", or a vector of ESPN game IDs.
rmv_bench: Logical. If TRUE, removes all players who aren't in the network.
tree: Logical. If TRUE, draws graph in tree structure. If FALSE, draws graph in circle
three_weights: Logical. If TRUE, assisted three point shots are given 1.5 weight. If FALSE, assisted three point shots are given weight 1. In both cases, assisted 2 point shots are given weight 1.
Message (default = NA) Option for custom message to replace graph title when using a subset of the season (e.g. conference play).

rosters_2016_17/: 2016-17 rosters for each team.
rosters_2017_18/: 2017-18 rosters for each team.
schedules_2017_18/: 2017-18 schedules for each team.
wp_model.R:/ Prepares data and builds win probability model (coefficients saved as object wp_hoops.csv). Requires all_games.csv and 2017_18_mid_season.csv.
wp_charts.R:/ Plots win probability chart for given game. Usage:wp_chart(ESPN_Game_ID, home_color, away_color, show_legend = T). The show_legend parameter is defaulted to TRUE. I recommend turning this parameter off when plotting more than one win probability charts on a single graph.
shiny_app:/ Code for the R Shiny App version of Assist Networks.
network_metric_leaders.R: A script for computing weighted/unweighted assist network metrics for all 351 Division 1 teams. The mid-season leaderboad for the 2017-18 season is stored in 1_2_2018_assist_leaderboard.csv.
kenpom_scraper.R: Scrapes data from kenpom.com main page and store results in kenpom.csv.
ncaa_color_scraper.R: Scrapes color hexcodes from http://teamcolorcodes.com for use in the ncaahoopR package.
Examples
Assist Networks


Weighted Assist Network

assist_net(""Yale"", ""royalblue1"", ""2017-18"", rmv_bench = T, tree = F, three_weights = T, message = NA)


Tree Assist Network

assist_net(""Yale"", ""royalblue1"", ""2017-18"", rmv_bench = T, tree = T, three_weights = F, message = NA)


Win Probability Charts

Texas A&M vs. Northern Iowa, March 20, 2016

wp_chart(400872229, ""maroon"", ""purple"")
Cincinnati vs. Houston, March 11, 2018 (2018 AAC Championship Game)

Update 3/13/2018: Added Game Excitement Index (GEI) to charts.



",R
49,"











NCAA Basketball Stats Scraper
Usage
Requirements
License





README.md




NCAA Basketball Stats Scraper
Author: Rodrigo Zamith
Version: 1.1
Usage
First, edit the scraper settings in scrapersettings.py. In particular, be sure to change the two variables at the top, academic_year and year_index, using the information provided in that file. You can also set what kind of data you'd like saved, and where you'd like it saved.
Then, execute either ncaab_stats_scraper.sh or ncaab_stats_scraper.bat, depending on your operating system. Alternatively, you can just execute the python files, preferably in this order:

create_team_mappings.py
create_schedule_mappings.py
create_player_mappings_and_agg_stats.py
create_ind_stats.py

Requirements
This script requires Python, as well as the urllib2 and BeautifulSoup libraries.
License
This script is licensed under the Mozilla Public License Version 2.0 (see LICENSE file in root folder). TL;DR: feel free to use it commercially, modify it, and distribute it, provided you disclose both the source code and any modifications you make to it.


",Python
50,"











BasketNet
Install
Usage
rf and erf visualize:
Network Structure
demo result
Reference





README.md




BasketNet
This is a demo of a LFFD model for a Basketball Recognition Competition.
The demo is based on SSD and LFFD.
Install
git clone https://github.com/aoru45/LFFD-Pytorch.git

Usage
Download or make your own dataset and modify the dataset.py file.
python train.py

rf and erf visualize:

The visulaization code is avaliable here: https://github.com/aoru45/LFFD-Pytorch/blob/master/visualize_demo.py
Network Structure

demo result

Reference
SSD:https://arxiv.org/abs/1512.02325
LFFD:https://arxiv.org/pdf/1904.10633.pdf


",Python
51,"



README.md




basketball-m
Men's basketball tools, data and analytics.


",Ruby
52,"











ESPN-Fantasy-Basketball
Installation
Improvements/Possible Added Features
Credits





README.md




ESPN-Fantasy-Basketball
https://espnfantasy.warrencrasta.com
An application that calculates and displays various statistics for ESPN Fantasy Basketball leagues. The code/application works for (public) leagues of any size that use H2H Most Cat. scoring. It may or may not work for other scoring systems. A Yahoo equivalent is here.
If you liked this project, please consider starring the repository.
Due to performance limitations that occur when the code is deployed on the website, there are some useful features that only exist locally but are not available through the website. To view these, run the code in the more-features branch.
Installation

Create a virtual environment using venv and Python 3.5 (optional, but highly recommended). Activate the virtual environment.
Run pip install -r requirements.txt to install the dependencies for this project.
Open your favorite IDE and configure the project so that the Python interpreter + package sources comes from your virtual environment (optional, but highly recommended).
Download ChromeDriver and put it in your path, preferably somewhere within your virtual environment. Instructions vary by OS. You might have to Google where to properly place ChromeDriver to get it working.
Run or debug the program!

Improvements/Possible Added Features
Feel free to contribute to this project! There are many improvements that can be made, both in terms of code quality and in terms of whole new ideas that can be implemented. Both the front-end and back-end are simple and can be enhanced.
If you do contribute, be advised that it may take some time to get your PR merged in. If you're interested in being a collaborator, e-mail me.
Credits
Author: Warren Crasta (warrencrasta@gmail.com)
Collaborator: Wayne Crasta (wayne.crasta@gmail.com)
Collaborator: richiehu17


",Python
53,"



README.md




betting
betting script, bet on games, football bet, soccer bet, basketball bet, add any game at any moment
This project has been written with codeigniter 2.1 php framework and mySQL database, frontend is bootstrap 2


",PHP
54,"











March Madness Tournament Outcome Prediction
A Machine Learning system to guide your March Madness bracket.





README.md




March Madness Tournament Outcome Prediction
A Machine Learning system to guide your March Madness bracket.
A Machine Learning project providing a solution to the Google Cloud & NCAA® Machine Learning Competition 2019 (https://www.kaggle.com/c/mens-machine-learning-competition-2019).
The project provides a solution to both Stage 1 and Stage 2 of the Kaggle competition, predicting the winner of historical fixtures and predicting the winners of all possible March Madness 2019 matchups respectively.
The submission files for these solutions can be found in 'SubmissionStage1.csv' and 'SubmissionStage2.csv' respectively. The project predicts the probability that the first team specified will beat the second team specified for each matchup listed in the Sample Submission file for both Stage 1 and Stage 2.
The project also creates a predicted bracket for the 2019 NCAA Men's March Madness basketball tournament based on the predictions made in Stage 2, and uses the tournament seedings and slots. This bracket can be found in the file 'output.png'.
Required Dependencies:

Numpy
Pandas
Matplotlib
Pickle
Random
Ski Kit Learn
Keras
Bracketeer

Execution Instructions:

Create dataset that holds details for each team for every season.

python createTeamDetails.py


Create dataset that contains details about every past matchup, which is used as the training dataset.

python createTrainingDataset.py


Create predictive models that can be used to predict the outcomes of future fixtures.

python createPredictionModel.py


Create dataset that holds the data used by the model for matchups that must be predicted in the Stage 1 submission.

python createStage1PredictionsDataset.py


Use the most accurate model created to create Stage 1 predictions, and write these to a submission file.

python createStage1Predictions.py


Submit the Stage 1 predictions to the Kaggle competition (requires setting up of the Kaggle library and Kaggle API).

kaggle competitions submit -c mens-machine-learning-competition-2019 -f SubmissionStage1.csv -m ""My Stage 1 submission""


Create dataset that holds the data used by the model for matchups that must be predicted in the Stage 2 submission.

python createStage2PredictionsDataset.py


Use the most accurate model created to create Stage 2 predictions, and write these to a submission file.

python createStage2Predictions.py


Create a visual representation of the predictions made for the 2019 tournament.

python createBracket.py


Submit the Stage 2 predictions to the Kaggle competition (requires setting up of the Kaggle library and Kaggle API).

kaggle competitions submit -c mens-machine-learning-competition-2019 -f SubmissionStage2.csv -m ""My Stage 2 submission""

File Details: 
Other files included or created in this repository include (in order of creation/access):

data/RegularSeasonDetailedResults.csv: Holds data from NCAA Regular Season matchups since 1985.
data/NCAATourneyDetailedResults.csv: Holds data from NCAA March Madness matchups since 2003.
data/TeamConferences.csv: Holds data regarding the team ID's of each team part of the dataset for each year.
data/all_teamData.csv: Holds per-season data for each NCAA team since 2003.
data/2019_teamData.csv: Holds regular season data for 2019 NCAA teams.
data/all_dataset.csv: Holds data for all NCAA matchups since 2003 in a format suitable for use as training data.
scaler.save: Holds the scaler that is used to preprocess data before it is used for predictions.
predictor.pkl: Holds the most accurate classifier created during the training phase.
data/stage1_dataset.csv: Holds data for matchups identified in Stage 1 in a format suitable for making predictions with.
data/stage2_dataset.csv: Holds data for matchups identified in Stage 2 in a format suitable for making predictions with.
SampleSubmissionStage1.csv: Holds details regarding which matchups should be predicted for Stage 1.
SampleSubmissionStage2.csv: Holds details regarding which matchups should be predicted for Stage 2.
SubmissionStage1.csv: Holds the submissions for Stage 1 of the Kaggle competition, as it stores the matchup predictions.
SubmissionStage2.csv: Holds the submissions for Stage 2 of the Kaggle competition, as it stores the matchup predictions.
data/Teams.csv: Holds data regarding the team name of each team based on their team ID.
data/NCAATourneySeeds.csv: Holds data regarding the NCAA seed of each team.
data/NCAATourneySlots.csv: Holds data regarding the NCAA slot of each team.
bracket.png: Holds a visual representation of the predictions made in the form of a bracket for the 2019 tournament.

Predictor Details: 
The features in an input instance for this model are:

0: Team 1 Home or Away (1: Home, 0: Neutral, -1: Away)
1: Team 1 Points per game - Team 2 Points per game
2: Team 1 Points Allowed per game - Team 2 Points Allowed per game
3: Team 1 Field Goals Made per game - Team 2 Field Goals Made per game
4: Team 1 Field Goals Attempted per game - Team 2 Field Goals Attempted per game
5: Team 1 3-Pointers Made per game - Team 2 3-Pointers Attempted per game
6: Team 1 Free-Throws Made per game - Team 2 Free-Throws Attempted per game
7: Team 1 Offensive Rebounds per game - Team 2 Offensive Rebounds per game
8: Team 1 Defensive Rebounds per game - Team 2 Defensive Rebounds per game
9: Team 1 Assists per game - Team 2 Assists per game
10: Team 1 Turnovers per game - Team 2 Turnovers per game
11: Team 1 Steals per game - Team 2 Steals per game
12: Team 1 Blocks per game - Team 2 Blocks per game
13: Team 1 Personal Fouls per game - Team 2 Personal Fouls per game

The output for an input instance for this model is the probability that Team 1 wins.
NCAA 2019 Tournament Predictions: 

Reflection on the Competition, the Model and the Results: 
With March Madness 2019 now over, I thought it would be a great time to reflect on my first time entering Google's competition, which saw entries from some of the leading universities and academic teams in the world. So, let's get to it.

In terms of its simplicity to implement, the model turned out to be decent. It predicted the right winner of each matchup that occurred in this tournament with an accuracy of about 78%, which isn't too bad. Better still, it was able to predict the correct winner of the entire tournament - the Virginia Cavaliers. This indicates that it did, to an extend, understand what was important in winning - in the case of Virginia, it seemed to be great defense and solid three-point shooting (which is probably why the model didn't even predict pre-tournament favourites Duke to make the finals).
The main flaw that I saw in the model was the fact that it did not take seedings into account. While the seeding would be the basis for most people's predictions in fixtures, as there tends to be a relatively strong correlation between the higher seed and the winning team, my model did not consider the seeding of the two teams in a matchup. This resulted in the model often making extremely risky predictions that were purely stats-based - I believe that the imposition of the seedings of the two teams will reduce the number of these risky predictions. The reason why it was difficult to incorporate seedings into the model was that the large majority of training data was from regular NCAA matches rather than the March Madness Championships. The large majority of teams playing in these NCAA matches, however, do not ever get assigned a seed - this is because they do not qualify for the Championships  itself. To get around this issue, I plan to utilize seedings in future predictive models with one slight tweak - I would assign a seeding of 16, which is the lowest possible seed in the Championships, to all teams that do not end up ever getting a seed. This indicates that they would be the weakest in the pool of teams if they qualified the Championships, which is valid given that they did not even make it.
Another shortcoming of the model, in my eyes, was that it didn't consider any of the previous matchups between the two teams considered. Head-to-head is usually a pretty good indicative of which team will win, since it is derived from experience. Adding this in future editions shouldn't be too difficult - it'll just require a data point that represents the yearly matchup details between two teams.
The project largely focused on the data side of the model, so little time was spent on optimizing the model - only a GridSearch was applied for the neural network. Optimization is, however, a clear distinguishing factor between average and great models. In order to improve on this next year, I would have to spend more time reading about about the latest advancements in the domain, and apply techniques that generate improvements which optimize the model. This may, however, require the implementation of techniques from new research papers.



",Python
55,"



README.md




Basketball-Detector
https://youtu.be/3UeoKxw8UYs


",Python
56,"











Basketball
Features





README.md




Basketball

Basketball
A remake of Facebook Messenger's basketball game! This game is a frontend browser game built with JavaScript, Phaser, and Canvas.
Features

Ball is shot in a direction based on the cursor's movement
Ball changes size to make experience 3D like
Sound effects make experience like REAL LIFE!
Ball collides with and bounces on/off rim
Motion tweens of happy or sad emojis appear based on success of the shot
Besides the first shot, ball spawns in random locations



",HTML
57,"














0. BueStats
1. Requirements
1.a. ChromeDriver
1.b. Python Dependencies
2. Interface
Scouting the whole league!
3. Output
4. Configuration Files
5. Plotting Interface
6. Data Ownership
7. Contact





README.md




0. BueStats
Advanced statistics have proven to be a crucial tool for basketball coaches in order to improve training skills. Indeed, the performance of the team can be further optimized by studying the behaviour of players under certain conditions, thus NBA teams already created highly skilled data science departments to handle tons of information, such as tracking data or the output of other advanced computer vision algorithms. However, European teams are far behind in this field, and tracking data is completely otherworldly for the 97% of them, but the worst thing is that there is not an existing culture-data tradition, which creates the need for data. Coaches have a solid point when they say that their job includes not only practice preparation, but also video sessions, individual meetings, or even physical and conditioning stuff, so they have basically no time to start digging for data for a rough analysis a posteriori.
The goal of BueStats is fulfilling these couple of gaps:

Provide coaches with a basic tool that automatically extracts advanced-statistics reports.
Help coaches understand and handle data in order to create a natural habit. Reports' data will not have complex information, but game conditioning factors and metrics that are easy to understand (tutorials are coming soon!), as it is important to establish a solid numerical basis before moving forward.

In particular, at the moment, BueStats can provide advanced statistics reports of FEB teams (Spanish Basketball Federation), which include any team/player from:

Liga Femenina Endesa (1st female Spanish division)
Leb Oro (2nd male Spanish division)
Liga Femenina 2 (2nd female Spanish division)
Leb Plata (3rd male Spanish division)
Liga EBA (4th male Spanish division)

BueStats is a non-lucrative Python-based project out of the scope of my PhD, and it has been tested with Ubuntu 16.04, MacOS 10.15.2 and Windows 10. I really hope you like it!
1. Requirements
1.a. ChromeDriver
BueStats does not only compute advanced basketball metrics, but it is also a web scraper that gets information from the HTML code of FEB websites (in a cool and legal way, of course). However, FEB's website is not that easy to scrap, given that there are dropdown menus that have to be changed, but these actions do not modify the general website link; for this reason, a remote browser controller has to be installed: Chromedriver. It is vital to install a Chromedriver version that matches your Google Chrome browser version, which can be find in Settings, and clicking About Chrome. Once installed, make sure that the downloaded chromedriver exectuable file is placed in the main BueStats folder.
1.b. Python Dependencies
As exepected, some Open-Source Python libraries have to be installed as well for a proper running of this program. This dependencies are included in Requirements.txt in case you want to build a virutal environment; otherwise, these libraries can be easily installed with pip:
pip3 install numpy
pip3 install selenium
pip3 install lxml
pip3 install pandas
pip3 install requests
pip3 install bs4

2. Interface
BueStats has a simple straight-forward interface (Stats_GUI) as seen in the following screenshot:


1. Team / Equipo: target team you want to scout or analyze. The name of the team must be a single unique word with no spaces belonging the the team original name; this is, the name of the team according to FEB. In the given example, Melilla's data will be extracted; note that Melilla is a unique team name, whereas ""Baloncesto"" or ""Club"" would not be.
2. Season / Temporada: season you want to scout; in this case, 2018 indicates the 2018-2019 season (2019 would indicate 2019-2020 and so on).
3. Division / Categoria: FEB division of the corresponding team. In order to unify groups and names, and bearing in mind that the program is case-sensitive, the following nomenclature has to be followed:

3.a. Liga Femenina Endesa can be written as Endesa or LF.
3.b. Leb Oro has to be written as ORO.
3.c. Liga Femenina 2 has to be written as LF2, but given that there are 2 groups (A or B), the group must be included in the encoding after a comma: for example, LF2,A belongs to a team compeiting in the group A of Liga Femenina 2.
3.d. Leb Plata is by far the most complex one, as it has two competition phases: the first one is geographically defined (Este / Oeste), while the second one depends on the previous results (A2). For this reason, a basic encoding has to be followed: PLATA,F1,F2 , where F1 belongs to the first phase and can be ESTE or OESTE, and F2 belongs to the second one and can be expressed as A1 and A2. An example could be: PLATA,ESTE,A1, or PLATA,OESTE,A2. However, if you want to output data just from one phase, you should encode it as: PLATA,F, where F could be one of the mentioned options (ESTE / OESTE / A1 / A2).
3.e. Liga EBA has to be written as EBA, but as happened with Liga Femenina 2, the name of the group has to be included as well after a comma with either one or two characters: for instance, if the team plays in group C, which has division CA and division CB, the encoding would be EBA,CA or EBA,CB, but if the team plays in division B, which has no subdivisions, the encoding would be EBA,B.


4. First Round / Primera Jornada is the first (included) round to be taken into account while extracting data.
5. Last Round / Última Jornada is the last (included) round to be taken into account while extracting data.
6. Top Teams / Equipos Top (optional) can be filled with the top teams of the competition, which might help to see how players perform against powerful teams. The set of teams has to be included with commas and no spaces.
7. Bottom Teams / Equipos Cola (optional) can be filled with the bottom teams of the competition. It has to be mentioned that both Top and Bottom Teams might be filled with any set of teams as well (all sizes).
8. Intervals / Intervalos will pack the performance of players/team in groups of N games, being N the number written in Intervals text box. For instance, if we split in groups of 5 the performance of a team that has played 13 games, statistics are separated for the 1-5, 5-10, and 10-13 games.
9. Players / Jugadores (optional) can be filled with a set of players that you want to scout by writting unique surnames. For example, both Josep Franch De Pablo and Felipe Dos Anjos De Paula play in Melilla; if we write FRANCH in the text box, only stats from Josep Franch will be extracted, whereas if we write DE, the performance of both players will be analyzed (De Pablo / De Paula). Again, more than one player can be added: (i.e) FRANCH, AGADA.
Extract All Rounds / Extraer Todas las Jornadas is a checkbox that (when checked) extracts the stats of the analyzed players for every single game in the given season.
Extract Team Stats / Extraer Estadísticas de Equipo is a checkbox that (when checked) extracts statistics not only at a player-level but also at a team-level.
Extract Rankings / Extraer Rankings is a checkbox that (when checked) extracts sorted rankings of the given team for each particular stat. This checkbox is related with the Textbox of Minimum Games / Minimo Partidos (optional), which can be set in order to set a threshold to include (or not to include) players in the rankings according to the games they have played; if the box is empty, this threshold is automatically set to half the number of games.
Configuration Folder / Carpeta Configuración (optional) will be explained in Section 4 (Configuration Files).
Output Folder / Carpeta Destino is the path where the output files will be stored. By default, it is a folder called ""Reports"" in the same ""BueStats"" main folder (you might create it for simplicity).
Change Language / Cambiar Idioma switches languages between Spanish and English; not only the interface will be affected, but also the output result.
Load Configuration / Cargar Configuración will be also explained in Section 4 (Configuration Files).

Finally...
Extract Statistics / Extraer Estadísticas is the main button to start gathering data from FEB. Once you press this button, you just have to be a little patient; Chromedriver will keep popping up and closing FEB sites automatically while extracting information. Don't interact with these windows, but you can keep using your computer as usual.
Scouting the whole league!
A ""hidden"" feature of BueStats (useful for scouts) is that not only teams and players can be analyzed, but also the entire league! For doing so, you just have to change the text in team for LIGA (in the given example, Melilla should be substituted by LIGA). Again, the names of players can be filtered as well. Please note that it might take a while to generate the outputs since there's much more information.
3. Output
BueStats produces quite a bunch of outputs in a .csv format, don't be overwhelmed because of that! The main reason for generating different statistic files is that the criteria to handle data changes among coaches and analysts, so there is not a best nor established way to do it! For a better visualization of the results, I would strongly suggest to mix the output files as you desire in a Google Spreadsheet file (by importing data), using different sheets and fixing the first row and the first two columns.  

All those files starting with a letter p belong to Player stats, whilst files starting with letters t and r correspond to Team and Ranking files.

The files that does NOT end with Phases.csv or Rounds.csv contain all player/team stats depending on several game-conditioning factors, such as Home / Away, Won / Lost, Initial-5 / Bench, Easy / Tough, Last3 games, and even the performance of the player against the desired teams included in Top/Bottom teams.
The files that end with Phases.csv contain the player/team stats clustered into the N-game groups indicated in the above-mentioned intervals.
The files that end with Rounds.csv contain the performance of the player/team in each round of the season.
Rankings (file that starts with r) includes the sorting of players from better to worst. 

Apart from the game conditioning factors, the following advanced statistics are included: 

Player Level: playerAST%. eFG%, TS%, GScored, Possessions, Floor Percentage, Points per Shot, %REB, %DRB, %ORB, STL%, Touches, Versatility, Usage, Win Scores, OER, DER, Net Points.
Team Level: Pace, OER, DER, eFG%, TS%,Play%, FTR%, %DRB, %ORB, %ASST, %TOV.

4. Configuration Files
The amount of filters and text boxes of BueStats is not small, and since the whole purpose of building this program is to automatize processes, configuration files might be used in order to save time. This files are simple .txt files (such as the ones included, i.e. ValoresDefectoORO.txt), where you can set a default configuration and load it in the interface with a simple click; this feature might be useful for coaches that want to analyze their own team every single week. As it can observe, the text template follows this pattern:
team=UNICAJA
season=2018
division=EBA,DA
firstRound=1
lastRound=18
topTeams=MONTETUCCI,FRAMASA,JAEN
botTeams=NOVASCHOOL,MARBELLA,INTERIOR
intervals=7
players=
outputFolder=/mnt/DATA/FCBScrapping/Reports

By clicking the Load Configuration button (and making sure the Configuration Folder is properly set), the information in the text file is loaded.
5. Plotting Interface
(NEW FEATURES! March 22nd)
As you might see, another GUI has been included in the source code (Graphics_GUI.py).
Following the same nomenclature as the one seen in the previous Sections, simple 2D graphics with team logos can be extracted for any desired statistic (in both the X and Y axes), which can be classical ones / advanced / stats of the opponents. In order to do so, just create a folder called ""Images"" inside the existing ""Reports"" one (e.g. mkdir /mnt/DATA/FCBScrapping/Reports/Images) and copy and extract the images of ""Logos.zip"", which include (thanks to FEB and Muevetebasket) all 2019 logos splitted by divisions.
Then, you just have to choose the desired rounds and statistics, and the plot will be automatically stored in your folder. Moreover, some npy files are also stored automatically to speed up the process. For instance, the first time you want to plot a specific graphic for (eg) 22 rounds, the scraper will browse around FEB website until getting all data; this process might take a while, but by storing these .npy arrays, it will be fully automatic the next time, without having to wait or whatsoever. Note that I included some default NPY files in a zip file (which are the ones corresponding to team data of some of the competitions before the covid-19 interruption - NpysGraphicAux.zip).
6. Data Ownership
All extracted BueStats' data belong to the Spanish Basketball Federation (FEB) and their corresponding boxscores, which are available online only for non-lucrative purposes. Please cite this GitHub or BueStats ifself if you are using this tool for writing scientific publications or sports articles (researchers and journalists).
7. Contact
You can reach me by email (adria.arbues@upf.edu) or by Twitter (@arbues6), and any suggestion or doubt will be kindly addressed! However, I have a thesis to finish in less than 2 years, so I won't have the chance of adding brand new features quickly. 
Executable files for Mac, Windows, and Linux, and tutorials are available in my UPF Website.


",Python
58,"



README.md




NBA Predictions
This is the repository used for our NBA Predictions project for Machine Learning 701 at Carnegie Mellon.


The final paper is displayed in the main repository, which summarizes all of our work


Our best SQLite database is located in the nba_rRegression_chi/nba.db


All of the data and code used to scrape it are located in the data/ directory


Scripts used to create our training/testing datasets as well as simulate the seasons are located in the scripts/ directory


regressionTrial_chi/nbaRegression.py has the code to create the figure which compares our algorithms




",TeX
59,"











ESPN Basketball
About
Usage





README.md




ESPN Basketball
Warning: This is a very outdated project. I would recommend you look to build
your scrapers with something like Scrapy instead.
About
As a huge fan of both basketball and BeautifulSoup 4 (currently in alpha), I
decided to rewrite an earlier module I'd been using to scrape games from ESPN.
In order to use this package, you will need lxml, mock, and bs4
installed.
I've found it parses pages and data pretty fast — around a second to
parse a game, rearrange the data into a tuple, and then spit it back out. On
average, most games normally consist of 400 to 460 individual plays (timeouts
and interruptions are counted as an Offical Play).
The tuple returned consists of the away team, home team, and a list of
dictionaries (each one represents an individual play in the game). You can
always read the source code to find out more.
Also, the library does have numerous unit tests that you can check out.
Usage
Using the datetime module.
>>> import datetime
>>> from espn import get_games
>>> yesterday = datetime.date.today() - datetime.timedelta(1)
>>> for game in get_games(yesterday, iterable=True):
...     print game

Alternatively you can just use a string in YYYYMMDD format.
>>> yesterday_string = ""20110330""
>>> for game in get_games(yesterday_string, iterable=True):
...     print game

You don't have to use the iterable=True argument — a list will be passed
back to you.
>>> april_fools_last_year = ""20100401""
>>> games = get_games(april_fools_last_year)

You can also scrape NCAA Men's Basketball games by passing in a
league='ncb' argument.
>>> march_1 = '20110301'
>>> for ncb_game in get_games(march_1, league='ncb', iterable=True):
...     print ncb_game

The daterange function can also come in handy for generating days between two
specific dates.
>>> import datetime
>>> from espn import daterange, get_games
>>> yesterday = datetime.date.today() - datetime.timedelta(1)
>>> week_ago = yesterday - datetime.timedelta(7)
>>> for day in daterange(week_ago, yesterday):
...     for game in get_games(day):
...         print game



",Python
60,"



README.md




Live_basketball_room
跟着singwa老师做的一个高性能篮球赛况直播室，主要包含实时直播模块和多人聊天模块，采用TP5整合原生swoole拓展编写。入门swoole最佳实战
高性能直播赛事平台-这是慕课swoole实战的项目,有些必要功能已完善,开发环境基于
Linux (Ubuntu 16.04LTS)
PHP-7.2.5
swoole-2.1.2
Redis-4.0.9
nginx-1.13.12
mysql-5.7.18
thinkphp-5.1
layer
本项目主要有两个版本，其中alpha测试版只包含基础功能，即只到第九章的内容，而beta测试版则有了alpha版没有的功能，包含：
1.请求访问写入日志功能
2.nginx转发功能
3.nginx多台服务器负载均衡配置
4.平滑重启脚本
5.多请求过滤
6.服务报警监控
其中的thinkphp是主要项目文件，其余的demo都是测试swoole代码用的。注释写的不少。认真的看应该都能看懂。
如何使用：
1.环境要求（基本）：项目只能运行在linux系统，并确保安装了PHP环境以及安装了swoole拓展，并且swoole开启了异步redis，还有普通的redis也要安装，因为项目中中也有同步redis，tp5的对swoole的适配已经在源码中做好，最好直接按我的开发环境来，其中你下载的在extend中如果没有ali这个文件夹，请将首页的ali放进去，不然使用不了短信服务。
2.如何调试：首先开启redis服务器端,再进入到thinkphp/script/bin/server/中,使用命令行执行：php ws_server.php,如果环境正确则不会报错。如果你使用的beta版的，因为添加了日志功能，所以每当有请求命令行会打印出日志信息，此时你应该执行一个脚本将日志输出到指定位置：
//这里可以使nohub来后台执行脚本，并且把输出的内容指定到一个文档中
//nuhub /home/xiaolu/php/bin/php  /home/xiaolu/web/swoole_imooc/thinkphp/script/monitor/server.php >/home/xiaolu/web/swoole_imooc/thinkphp/script/monitor/log.text &
websocket的默认端口为8811，监听的IP地址为127.0.0.1，在浏览器中使用地址：http://127.0.0.1:8811/live/login.html 进入了登录界面后 ，通过阿里的手机验证码可以正常的进行登录，这里是使用redis作为登录凭证的，redis存储的格式为sms_电话号码，因为我在源码中把阿里的短信验证凭证改了（文件在app\common\lib\ali\Sms类中），你需要正确配置你自己的凭证，或者直接在redis中执行 set sms_你的电话 123456,这样的话你就可以直接用123456作为你的验证码直接登录了.同样可以用这种方式这样多用户登录，多个用户登录后，可以直接测试聊天室功能，这个功能是属于不写入数据库的，因为实在没必要写这些重复性增删改查操作，你在聊天室输入内容后直接回车，其他用户便会实时收到你的信息，这时注意如果强刷页面就会消失了，实际上的聊天室是会记录到mysql数据库中的，但是这里我只是把收到的信息使用js让其显示到页面上而已。后台主持人功能使用浏览器访问：http://127.0.0.1/live/admin/live.html 界面比较粗糙，毕竟是测试版的。这里的话是默认指定了两支球队，实际上应该是从数据库进行动态显示的，写入内容选择发布即可，这时所有连接的客户端都会收到你发出的内容。核心代码都已经写好，数据库建表的文件也在那里，实际上需要完善的话只要建好数据库，把球队信息啥的录入进去，在完善一下页面，通信的模块基本不用改，需要改的都是普通的操作，懂tp5的很简单就能完成了。
这里我将安装环境所需的各类源码包也上传了。需要的话可以用。
我知道你们还是想看效果图的，那我还是放一下吧：
（客户端界面基于移动端，后台页面基于PC端）
登录界面：

登录后界面：

聊天室界面：

主持人界面：

建议环境自己搭建，不要说学swoole的PHPer连基本环境都不会搭，遇到坑就多查资料，没有过不去的坑。实在不行，没办法了，那就用我的导出虚拟机系统包把，用vmware导入即可，源码和环境都有了。最后祝大家swoole学习愉快。虚拟机导出系统分享：链接：https://pan.baidu.com/s/140PLiqkDaiPHaUHPBOit8Q 密码：95ko


",PHP
61,"











Miracle Store ID
Technology i use
Some Screenshot





README.md




Miracle Store ID
Apa itu Miracle Store ID?
Miracle Store ID adalah dalah web penjualan sepatu basket layaknya situs E-Commerce dengan fitur yang masih sangat sederhana banget.

Reminder! there is a my personal project.

View Demo
Technology i use
Jadi, teknologi yang saya gunakan untuk membangun projek ini adalah :

Vue JS 2
Vue Router
Vuex (saya sangant pemula di Vuex sebenarnya)
Firebase

Beberapa library yang saya gunakan :

Bootstrap / Bootstrap-vue
Gsap
Font Awesome
vue-toast-notification
vue-form-wizard
little bit vuesax (hanya untuk select kategori brand)

Untuk menambahkan barang ke keranjang harus sudah memiliki akun dan login terlebih dahulu. Pada bagian nomor hp dan email di form pendaftaran, boleh sembarang aja, asalkan email yang mau didaftarkan harus sesuai dengan format email.
Juga dapat reset password, dapat mengubah nama profil kamu.

Tidak dapat mengunggah foto profil

Some Screenshot
Screenshot dari profile page dan cart page :




",Vue
62,"











BasketballAnalyzeR
Developers
Installation
Warning
Links





README.md




BasketballAnalyzeR
Contains data and code to accompany the book
P. Zuccolotto and M. Manisera (2020) Basketball Data Science. Applications with R. CRC Press. ISBN 9781138600799.
Developers
Marco Sandri, Paola Zuccolotto, Marica Manisera
Big and Open Data Innovation Laboratory (BODaI-Lab)
https://bodai.unibs.it/
University of Brescia, Italy
Installation
# From CRAN:
install.packages(""BasketballAnalyzeR"")

# From Github (development version):
install.packages(""devtools"")
devtools::install_github(""sndmrc/BasketballAnalyzeR"""")

Warning
If you want to reproduce the figures contained in the book of Zuccolotto and Manisera (2020) and if the version of your R machine is >= 3.6.0, you need to type
RNGkind(sample.kind = ""Rounding"")

at the beginning of your working session.
Links
https://bdsports.unibs.it/basketballanalyzer/
https://cran.r-project.org/web/packages/BasketballAnalyzeR/


",R
63,"














sportsdataverse
Installation
Documentation
Breaking Changes
Follow the SportsDataverse on Twitter and star this repo
Our Authors
Citations
Overview of Services
API Reference
cfb.getPlayByPlay(id) ⇒
cfb.getBoxScore(id) ⇒
cfb.getSummary(id) ⇒
cfb.getPicks(id) ⇒
cfb.getPlayerRankings(year, page, group, state) ⇒
cfb.getSchoolRankings(year, page) ⇒
cfb.getSchoolCommits(year, school) ⇒
cfb.getRankings(year, week) ⇒
cfb.getSchedule(year, month, day, group, seasontype) ⇒
cfb.getScoreboard(year, month, day, group, seasontype, limit) ⇒
cfb.getConferences(year, group) ⇒
cfb.getStandings(year, group) ⇒
cfb.getTeamList(group) ⇒
cfb.getTeamInfo(id) ⇒
cfb.getTeamPlayers(id)
mbb.getPlayByPlay(id) ⇒
mbb.getBoxScore(id) ⇒
mbb.getSummary(id) ⇒
mbb.getPicks(id) ⇒
mbb.getRankings(year, week) ⇒
mbb.getPlayerRankings(year, page, group) ⇒
mbb.getSchoolRankings(year, page) ⇒
mbb.getSchoolCommits(year, school) ⇒
mbb.getSchedule(year, month, day, group, seasontype) ⇒
mbb.getScoreboard(year, month, day, group, seasontype, limit) ⇒
mbb.getConferences(year, group) ⇒
mbb.getStandings(year, group) ⇒
mbb.getTeamList(group) ⇒
mbb.getTeamInfo(id) ⇒
mbb.getTeamPlayers(id) ⇒
nba.getPlayByPlay(id) ⇒
nba.getBoxScore(id) ⇒
nba.getSummary(id) ⇒
nba.getPicks(id) ⇒
nba.getSchedule(year, month, day) ⇒
nba.getScoreboard(year, month, day, limit) ⇒
nba.getStandings(year, group) ⇒
nba.getTeamList() ⇒
nba.getTeamInfo(id) ⇒
nba.getTeamPlayers(id) ⇒
ncaa.getRedirectUrl(url) ⇒
ncaa.getInfo(game) ⇒
ncaa.getBoxScore(game) ⇒
ncaa.getPlayByPlay(game) ⇒
ncaa.getTeamStats(game) ⇒
ncaa.getScoringSummary(game) ⇒
ncaa.getScoreboard(sport, division, year, month, day) ⇒
ncaa.getSports() ⇒
ncaa.getSeasons(sport) ⇒
ncaa.getDivisions(sport, season) ⇒
ncaa.getSportDivisionData(sport, season, division, rankingPeriod, type, gameHigh, category) ⇒
ncaa.getPlayerData(sport, season, division, rankingPeriod, gameHigh, category) ⇒
ncaa.getTeamData(sport, season, division, rankingPeriod, gameHigh, category) ⇒
nfl.getPlayByPlay(id) ⇒
nfl.getBoxScore(id) ⇒
nfl.getSummary(id) ⇒
nfl.getPicks(id) ⇒
nfl.getSchedule(year, month, day) ⇒
nfl.getScoreboard(year, month, day, limit) ⇒
nfl.getStandings(year, group) ⇒
nfl.getTeamList()
nfl.getTeamInfo(id) ⇒
nfl.getTeamPlayers(id) ⇒
nhl.getPlayByPlay(id) ⇒
nhl.getBoxScore(id) ⇒
nhl.getSummary(id) ⇒
nhl.getPicks(id) ⇒
nhl.getSchedule(year, month, day) ⇒
nhl.getScoreboard(year, month, day, limit) ⇒
nhl.getStandings(year, group) ⇒
nhl.getTeamList()
nhl.getTeamInfo(id) ⇒
nhl.getTeamPlayers(id) ⇒
wbb.getPlayByPlay(id) ⇒
wbb.getBoxScore(id) ⇒
wbb.getSummary(id) ⇒
wbb.getRankings(year, week) ⇒
wbb.getSchedule(year, month, day, group, seasontype, limit) ⇒
wbb.getScoreboard(year, month, day, group, seasontype, limit) ⇒
wbb.getConferences(year, group) ⇒
wbb.getStandings(year, group) ⇒
wbb.getTeamList(group) ⇒
wbb.getTeamInfo(id) ⇒
wbb.getTeamPlayers(id) ⇒
wnba.getPlayByPlay(id) ⇒
wnba.getBoxScore(id) ⇒
wnba.getSummary(id) ⇒
wnba.getSchedule(year, month, day) ⇒
wnba.getScoreboard(year, month, day, limit) ⇒
wnba.getStandings(year, group) ⇒
wnba.getTeamList() ⇒
wnba.getTeamInfo(id) ⇒
wnba.getTeamPlayers(id) ⇒





README.md




sportsdataverse 


 
 

Installation
npm install sportsdataverse
Documentation
For more information on the package and function reference, please see the sportsdataverse node.js documentation website
Breaking Changes
Full News on Releases
Follow the SportsDataverse on Twitter and star this repo


Our Authors

Saiem Gilani



Citations
To cite the sportsdataverse Node.js package in publications, use:
BibTex Citation
@misc{gilani_2021_sportsdataverse_js,
  author = {Gilani, Saiem},
  title = {sportsdataverse-js: The SportsDataverse's Node.js Package for Sports Data.},
  url = {https://js.sportsdataverse.org},
  year = {2021}
}
Overview of Services
Support for the following data from ESPN's endpoints:

play-by-play (including shot location data when available)
scores
schedule
standings
rankings (not available for professional sports)

Recruiting data from 247Sports available for:

men's college basketball
college football

The following sports are available from ESPN:

Men's College Basketball
Women's College Basketball
College Football
WNBA
NBA
NFL
NHL
All team sports on the NCAA website:

'football'
'basketball-men'
'basketball-women'
'soccer-men'
'soccer-women'
'fieldhockey'
'volleyball-women'
'icehockey-men'
'icehockey-women'
'baseball'
'beach-volleyball'
'lacrosse-men'
'lacrosse-women'
'volleyball-men'



API Reference
Operations for College Football.
Kind: global namespace

cfb : object

.getPlayByPlay(id) ⇒
.getBoxScore(id) ⇒
.getSummary(id) ⇒
.getPicks(id) ⇒
.getPlayerRankings(year, page, group, state) ⇒
.getSchoolRankings(year, page) ⇒
.getSchoolCommits(year, school) ⇒
.getRankings(year, week) ⇒
.getSchedule(year, month, day, group, seasontype) ⇒
.getScoreboard(year, month, day, group, seasontype, limit) ⇒
.getConferences(year, group) ⇒
.getStandings(year, group) ⇒
.getTeamList(group) ⇒
.getTeamInfo(id) ⇒
.getTeamPlayers(id)




cfb.getPlayByPlay(id) ⇒
Gets the College Football game play-by-play data for a specified game.
Kind: static method of cfb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.cfb.getPlayByPlay(401256194);

cfb.getBoxScore(id) ⇒
Gets the College Football game box score data for a specified game.
Kind: static method of cfb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.cfb.getBoxScore(401256194);

cfb.getSummary(id) ⇒
Gets the College Football game summary data for a specified game.
Kind: static method of cfb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.cfb.getSummary(401256194);

cfb.getPicks(id) ⇒
Gets the College Football PickCenter data for a specified game.
Kind: static method of cfb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.cfb.getPicks(401256194);

cfb.getPlayerRankings(year, page, group, state) ⇒
Gets the College Football Player recruiting data for a specified year, page, position, state and institution type if available.
Kind: static method of cfb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


page
number
Page (50 per page)


group
""HighSchool"" | ""JuniorCollege"" | ""PrepSchool""
Institution Type


state
string
State of recruit



Example
const result = await sdv.cfb.getPlayerRankings({year: 2016});

cfb.getSchoolRankings(year, page) ⇒
Gets the College Football School recruiting data for a specified year and page if available.
Kind: static method of cfb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


page
number
Page (50 per page)



Example
const result = await sdv.cfb.getSchoolRankings({year: 2016});

cfb.getSchoolCommits(year, school) ⇒
Gets the College Football School commitment data for a specified school and year.
Kind: static method of cfb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


school
string
School



Example
const result = await sdv.cfb.getSchoolCommits({school: 'Florida State', year: 2021});

cfb.getRankings(year, week) ⇒
Gets the CFB rankings data for a specified year and week if available.
Kind: static method of cfb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


week
*
Week



Example
const result = await sdv.cfb.getRankings(year = 2020, week = 4)

cfb.getSchedule(year, month, day, group, seasontype) ⇒
Gets the College Football schedule data for a specified date if available.
Kind: static method of cfb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


group
number
Group is 80 for FBS, 81 for FCS


seasontype
number
Pre-Season: 1, Regular Season: 2, Postseason: 3, Off-season: 4



Example
const result = await sdv.cfb.getSchedule(year = 2019, month = 11, day = 16, group=80)

cfb.getScoreboard(year, month, day, group, seasontype, limit) ⇒
Gets the College Football scoreboard data for a specified date if available.
Kind: static method of cfb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


group
number
Group is 80 for FBS, 81 for FCS


seasontype
number
Pre-Season: 1, Regular Season: 2, Postseason: 3, Off-season: 4


limit
number
Limit on the number of results @default 300



Example
const result = await sdv.cfb.getScoreboard(
year = 2019, month = 11, day = 16, group=80
)

cfb.getConferences(year, group) ⇒
Gets the list of all College Football conferences and their identification info for ESPN.
Kind: static method of cfb
Returns: json



Param
Type
Description




year
number
Season


group
number
Group is 80 for FBS, 81 for FCS



Example
const yr = 2021;
const result = await sdv.cfb.getConferences(year = yr, group = 80);

cfb.getStandings(year, group) ⇒
Gets the team standings for College Football.
Kind: static method of cfb
Returns: json



Param
Type
Description




year
number
Season


group
number
Group is 80 for FBS, 81 for FCS



Example
const yr = 2020;
const result = await sdv.cfb.getStandings(year = yr);

cfb.getTeamList(group) ⇒
Gets the list of all College Football teams their identification info for ESPN.
Kind: static method of cfb
Returns: json



Param
Type
Description




group
number
Group is 80 for FBS, 81 for FCS



Example
const result = await sdv.cfb.getTeamList(group=80);

cfb.getTeamInfo(id) ⇒
Gets the team info for a specific College Football team.
Kind: static method of cfb
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 52;
const result = await sdv.cfb.getTeamInfo(teamId);

cfb.getTeamPlayers(id)
Gets the team roster information for a specific College Football team.
Kind: static method of cfb



Param
Type
Description




id
number
Team Id



Example
const teamId = 52;
const result = await sdv.cfb.getTeamPlayers(teamId);
Operations for Men's College Basketball.
Kind: global namespace

mbb : object

.getPlayByPlay(id) ⇒
.getBoxScore(id) ⇒
.getSummary(id) ⇒
.getPicks(id) ⇒
.getRankings(year, week) ⇒
.getPlayerRankings(year, page, group) ⇒
.getSchoolRankings(year, page) ⇒
.getSchoolCommits(year, school) ⇒
.getSchedule(year, month, day, group, seasontype) ⇒
.getScoreboard(year, month, day, group, seasontype, limit) ⇒
.getConferences(year, group) ⇒
.getStandings(year, group) ⇒
.getTeamList(group) ⇒
.getTeamInfo(id) ⇒
.getTeamPlayers(id) ⇒




mbb.getPlayByPlay(id) ⇒
Gets the Men's College Basketball game play-by-play data for a specified game.
Kind: static method of mbb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.mbb.getPlayByPlay(401260281);

mbb.getBoxScore(id) ⇒
Gets the Men's College Basketball game box score data for a specified game.
Kind: static method of mbb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.mbb.getBoxScore(401260281);

mbb.getSummary(id) ⇒
Gets the Men's College Basketball game summary data for a specified game.
Kind: static method of mbb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.mbb.getSummary(401260281);

mbb.getPicks(id) ⇒
Gets the Men's College Basketball game PickCenter data for a specified game.
Kind: static method of mbb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.mbb.getPicks(401260281);

mbb.getRankings(year, week) ⇒
Gets the Men's College Basketball rankings data for a specified year and week if available.
Kind: static method of mbb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


week
*
Week



Example
const result = await sdv.mbb.getRankings(
year = 2020, week = 15
)

mbb.getPlayerRankings(year, page, group) ⇒
Gets the Men's College Basketball Player recruiting data for a specified year, page, position and institution type if available.
Kind: static method of mbb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


page
number
Page (50 per page)


group
""HighSchool"" | ""JuniorCollege"" | ""PrepSchool""
Institution Type



Example
const result = await sdv.mbb.getPlayerRankings({year: 2016});

mbb.getSchoolRankings(year, page) ⇒
Gets the Men's College Basketball School recruiting data for a specified year, page, position and institution type if available.
Kind: static method of mbb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


page
number
Page (50 per page)



Example
const result = await sdv.mbb.getSchoolRankings({year: 2016});

mbb.getSchoolCommits(year, school) ⇒
Gets the Men's College Basketball School commitment data for a specified school and year.
Kind: static method of mbb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


school
string
School



Example
const result = await sdv.mbb.getSchoolCommits({school: 'Clemson', year: 2016});

mbb.getSchedule(year, month, day, group, seasontype) ⇒
Gets the Men's College Basketball schedule data for a specified date if available.
Kind: static method of mbb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


group
number
Group is 50 for Division-I, 51 for Division-II, 52 for Division-III


seasontype
number
Pre-Season: 1, Regular Season: 2, Postseason: 3, Off-season: 4



Example
const result = await sdv.mbb.getSchedule(
year = 2021, month = 02, day = 15, group=50
)

mbb.getScoreboard(year, month, day, group, seasontype, limit) ⇒
Gets the Men's College Basketball scoreboard data for a specified date if available.
Kind: static method of mbb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


group
number
Group is 50 for Division-I, 51 for Division-II, 52 for Division-III


seasontype
number
Pre-Season: 1, Regular Season: 2, Postseason: 3, Off-season: 4


limit
number
Limit on the number of results @default 300



Example
const result = await sdv.mbb.getScoreboard(
year = 2021, month = 02, day = 15, group=50
)

mbb.getConferences(year, group) ⇒
Gets the Men's College Basketball Conferences.
Kind: static method of mbb
Returns: json



Param
Type
Description




year
number
Season


group
number
Group is 50 for Division-I, 51 for Division-II, 52 for Division-III



Example
const yr = 2021;
const result = await sdv.mbb.getConferences(year = yr, group = 50);

mbb.getStandings(year, group) ⇒
Gets the team standings for Men's College Basketball.
Kind: static method of mbb
Returns: json



Param
Type
Description




year
number
Season


group
number
Group is 50 for Division-I, 51 for Division-II, 52 for Division-III, see wbb.getConferences() for more info



Example
const yr = 2020;
const result = await sdv.mbb.getStandings(year = yr);

mbb.getTeamList(group) ⇒
Gets the list of all College Football teams their identification info for ESPN.
Kind: static method of mbb
Returns: json



Param
Type
Description




group
number
Group is 50 for Division-I, 51 for Division-II, 52 for Division-III



Example
const result = await sdv.mbb.getTeamList(group=50);

mbb.getTeamInfo(id) ⇒
Gets the team info for a specific College Basketball team.
Kind: static method of mbb
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 52;
const result = await sdv.mbb.getTeamInfo(teamId);

mbb.getTeamPlayers(id) ⇒
Gets the team roster information for a specific Men's College Basketball team.
Kind: static method of mbb
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 52;
const result = await sdv.mbb.getTeamPlayers(teamId);
Operations for NBA.
Kind: global namespace

nba : object

.getPlayByPlay(id) ⇒
.getBoxScore(id) ⇒
.getSummary(id) ⇒
.getPicks(id) ⇒
.getSchedule(year, month, day) ⇒
.getScoreboard(year, month, day, limit) ⇒
.getStandings(year, group) ⇒
.getTeamList() ⇒
.getTeamInfo(id) ⇒
.getTeamPlayers(id) ⇒




nba.getPlayByPlay(id) ⇒
Gets the NBA game play-by-play data for a specified game.
Kind: static method of nba
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nba.getPlayByPlay(401283399);

nba.getBoxScore(id) ⇒
Gets the NBA game box score data for a specified game.
Kind: static method of nba
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nba.getBoxScore(401283399);

nba.getSummary(id) ⇒
Gets the NBA game summary data for a specified game.
Kind: static method of nba
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nba.getSummary(401283399);

nba.getPicks(id) ⇒
Gets the NBA game PickCenter data for a specified game.
Kind: static method of nba
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nba.getPicks(401283399);

nba.getSchedule(year, month, day) ⇒
Gets the NBA schedule data for a specified date if available.
Kind: static method of nba
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)



Example
const result = await sdv.nba.getSchedule(
year = 2016, month = 04, day = 15
)

nba.getScoreboard(year, month, day, limit) ⇒
Gets the NBA scoreboard data for a specified date if available.
Kind: static method of nba
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


limit
number
Limit on the number of results @default 300



Example
const result = await sdv.nba.getScoreboard(
year = 2019, month = 11, day = 16
)

nba.getStandings(year, group) ⇒
Gets the team standings for the NBA.
Kind: static method of nba
Returns: json



Param
Type
Description




year
number
Season


group
string
acceptable group names: 'league','conference','division'



Example
const yr = 2016;
const result = await sdv.nba.getStandings(year = yr);

nba.getTeamList() ⇒
Gets the list of all NBA teams their identification info for ESPN.
Kind: static method of nba
Returns: json
Example
const result = await sdv.nba.getTeamList();

nba.getTeamInfo(id) ⇒
Gets the team info for a specific NBA team.
Kind: static method of nba
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 16;
const result = await sdv.nba.getTeamInfo(teamId);

nba.getTeamPlayers(id) ⇒
Gets the team roster information for a specific NBA team.
Kind: static method of nba
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 16;
const result = await sdv.nba.getTeamPlayers(teamId);
Operations for NCAA Sports.
Kind: global namespace

ncaa : object

.getRedirectUrl(url) ⇒
.getInfo(game) ⇒
.getBoxScore(game) ⇒
.getPlayByPlay(game) ⇒
.getTeamStats(game) ⇒
.getScoringSummary(game) ⇒
.getScoreboard(sport, division, year, month, day) ⇒
.getSports() ⇒
.getSeasons(sport) ⇒
.getDivisions(sport, season) ⇒
.getSportDivisionData(sport, season, division, rankingPeriod, type, gameHigh, category) ⇒
.getPlayerData(sport, season, division, rankingPeriod, gameHigh, category) ⇒
.getTeamData(sport, season, division, rankingPeriod, gameHigh, category) ⇒




ncaa.getRedirectUrl(url) ⇒
Gets the gameId for older games whose url redirects to the current url pattern using the
game url fragment (relative to https://ncaa.com) pulled from ncaaScoreboard
Kind: static method of ncaa
Returns: json



Param
Type
Description




url
string
Game url as pulled from ncaaScoreboard.getNcaaScoreboard.



Example
const result = await sdv.ncaaScoreboard.getNcaaScoreboard(
sport = 'basketball-men', division = 'd3', year = 2019, month = 02, day = 15
)
const urlGame = result[""games""][16][""game""][""url""]
const gameId = await sdv.ncaa.getRedirectUrl(url=urlGame);

ncaa.getInfo(game) ⇒
Gets the gameInfo data for a specified game.
Kind: static method of ncaa
Returns: json



Param
Type
Description




game
number
Game id.



Example
const result = await sdv.ncaa.getInfo(5764053);

ncaa.getBoxScore(game) ⇒
Gets the box score data for a specified game if available.
Kind: static method of ncaa
Returns: json



Param
Type
Description




game
number
Game id.



Example
const result = await sdv.ncaa.getBoxScore(5764053);

ncaa.getPlayByPlay(game) ⇒
Gets the play-by-play data for a specified game if available.
Kind: static method of ncaa
Returns: json



Param
Type
Description




game
number
Game id.



Example
const result = await sdv.ncaa.getPlayByPlay(5764053);

ncaa.getTeamStats(game) ⇒
Gets the team stats data for a specified game if available.
Kind: static method of ncaa
Returns: json



Param
Type
Description




game
number
Game id.



Example
const result = await sdv.ncaa.getTeamStats(5764053);

ncaa.getScoringSummary(game) ⇒
Gets the scoring summary data for a specified game if available.
Kind: static method of ncaa
Returns: json



Param
Type
Description




game
number
Game id.



Example
const result = await sdv.ncaa.getScoringSummary(5764053);

ncaa.getScoreboard(sport, division, year, month, day) ⇒
Gets the scoreboard data for a specified date and team sport if available.
Kind: static method of ncaa
Returns: json



Param
Type
Description




sport
string
Sport name. Acceptable values: 'football','basketball-men', 'basketball-women', 'baseball', 'softball', 'soccer-men','soccer-women', 'fieldhockey', 'icehockey-men','icehockey-women', 'lacrosse-men','lacrosse-women', 'beach-volleyball', 'volleyball-women', 'volleyball-men'


division
string
Division of teams desired.  Acceptable values: Football - ['fbs','fcs','d2','d3'] All others - ['d1','d2','d3']


year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)



Example
const result = await sdv.ncaa.getScoreboard(
sport = 'basketball-men', division = 'd3', year = 2019, month = 02, day = 15
)

ncaa.getSports() ⇒
Retrieves the set of sports and their abbreviations.
Kind: static method of ncaa
Returns: json
Example
const result = sdv.ncaa.getSports();

ncaa.getSeasons(sport) ⇒
Retrieves the seasons for the selected sport.
Kind: static method of ncaa
Returns: json



Param
Type
Description




sport
string
Sport abbreviation. Acceptable values: 'MBA' = Baseball, 'MBB' = Men's basketball, 'MFB' = Men's Football, 'MIH' = Men's Ice-hockey, 'MLA' = Men's Lacrosse', 'MSO' = Men's Soccer, 'MTE' = Men's Tennis, 'MVB' = Men's Volleyball, 'MWP' = Men's Water Polo, 'WBB' = Women's Basketball, 'WBW' = Women's Bowling, 'WFH' = Field Hockey, 'WIH' = Women's Ice-Hockey, 'WLA' = Women's Lacrosse, 'WSB' = Women's Softball, 'WSO' = Women's Soccer, 'WSV' = Women's Beach Volleyball, 'WTE' = Women's Tennis, 'WVB' = Women's Volleyball, 'WWP' = Women's Water Polo



Example
const result = sdv.ncaa.getSeasons(sport='MBB');

ncaa.getDivisions(sport, season) ⇒
Retrieves the Divisions for the selected sport and season.
Kind: static method of ncaa
Returns: json



Param
Type
Description




sport
string
Sport abbreviation. Acceptable values: 'MBA' = Baseball, 'MBB' = Men's basketball, 'MFB' = Men's Football, 'MIH' = Men's Ice-hockey, 'MLA' = Men's Lacrosse', 'MSO' = Men's Soccer, 'MTE' = Men's Tennis, 'MVB' = Men's Volleyball, 'MWP' = Men's Water Polo, 'WBB' = Women's Basketball, 'WBW' = Women's Bowling, 'WFH' = Field Hockey, 'WIH' = Women's Ice-Hockey, 'WLA' = Women's Lacrosse, 'WSB' = Women's Softball, 'WSO' = Women's Soccer, 'WSV' = Women's Beach Volleyball, 'WTE' = Women's Tennis, 'WVB' = Women's Volleyball, 'WWP' = Women's Water Polo


season
string
Season for sport



Example
const result = sdv.ncaa.getDivisions(sport='MBB', season='2017');

ncaa.getSportDivisionData(sport, season, division, rankingPeriod, type, gameHigh, category) ⇒
Request the data from the NCAA Stats website.
Kind: static method of ncaa
Returns: json



Param
Description




sport
Sport abbreviation. Acceptable values: 'MBA' = Baseball, 'MBB' = Men's basketball, 'MFB' = Men's Football, 'MIH' = Men's Ice-hockey, 'MLA' = Men's Lacrosse', 'MSO' = Men's Soccer, 'MTE' = Men's Tennis, 'MVB' = Men's Volleyball, 'MWP' = Men's Water Polo, 'WBB' = Women's Basketball, 'WBW' = Women's Bowling, 'WFH' = Field Hockey, 'WIH' = Women's Ice-Hockey, 'WLA' = Women's Lacrosse, 'WSB' = Women's Softball, 'WSO' = Women's Soccer, 'WSV' = Women's Beach Volleyball, 'WTE' = Women's Tennis, 'WVB' = Women's Volleyball, 'WWP' = Women's Water Polo


season
Season of query, value for 2016-2017 season would be 2017.


division
Division, for college football: 11 for FBS, 12 for FCS, otherwise 1 for Division-I, 2 for Division-II, 3 for Division-III.


rankingPeriod
Integer value indicating the ranking period, options can be found from using the @function ncaa.getSportDivisionData function.


type
Individual or Team type of statistics


gameHigh
logical, indicating whether the statistic desired is of the game-high variety


category
Value for the stat category, can also be found using the @function ncaa.getSportDivisionData



Example
const sportDivisionData = sdv.ncaa.getSportDivisionData(sport='MFB',season='2016',division=12,type='team',gameHigh=true);

ncaa.getPlayerData(sport, season, division, rankingPeriod, gameHigh, category) ⇒
Get the Player Data from the NCAA Stats website.
Kind: static method of ncaa
Returns: json



Param
Type
Description




sport

Sport abbreviation. Acceptable values: 'MBA' = Baseball, 'MBB' = Men's basketball, 'MFB' = Men's Football, 'MIH' = Men's Ice-hockey, 'MLA' = Men's Lacrosse', 'MSO' = Men's Soccer, 'MTE' = Men's Tennis, 'MVB' = Men's Volleyball, 'MWP' = Men's Water Polo, 'WBB' = Women's Basketball, 'WBW' = Women's Bowling, 'WFH' = Field Hockey, 'WIH' = Women's Ice-Hockey, 'WLA' = Women's Lacrosse, 'WSB' = Women's Softball, 'WSO' = Women's Soccer, 'WSV' = Women's Beach Volleyball, 'WTE' = Women's Tennis, 'WVB' = Women's Volleyball, 'WWP' = Women's Water Polo


season

Season of query, value for 2016-2017 season would be 2017.


division

Division, for college football: 11 for FBS, 12 for FCS, otherwise 1 for Division-I, 2 for Division-II, 3 for Division-III.


rankingPeriod

Integer value indicating the ranking period, options can be found from using the @function ncaa.getSportDivisionData function.


gameHigh
'Y' | 'N'
logical, indicating whether the statistic desired is of the game-high variety


category

Value for the stat category, can also be found using the @function ncaa.getSportDivisionData



Example
const players =  await sdv.ncaa.getPlayerData(sport = 'MFB', year = '2017', division = '11',rankingPeriod = '52', gameHigh='N', category = '20')

ncaa.getTeamData(sport, season, division, rankingPeriod, gameHigh, category) ⇒
Get the Team Data from the NCAA Stats website.
Kind: static method of ncaa
Returns: json



Param
Type
Description




sport

Sport abbreviation. Acceptable values: 'MBA' = Baseball, 'MBB' = Men's basketball, 'MFB' = Men's Football, 'MIH' = Men's Ice-hockey, 'MLA' = Men's Lacrosse', 'MSO' = Men's Soccer, 'MTE' = Men's Tennis, 'MVB' = Men's Volleyball, 'MWP' = Men's Water Polo, 'WBB' = Women's Basketball, 'WBW' = Women's Bowling, 'WFH' = Field Hockey, 'WIH' = Women's Ice-Hockey, 'WLA' = Women's Lacrosse, 'WSB' = Women's Softball, 'WSO' = Women's Soccer, 'WSV' = Women's Beach Volleyball, 'WTE' = Women's Tennis, 'WVB' = Women's Volleyball, 'WWP' = Women's Water Polo


season

Season of query, value for 2016-2017 season would be 2017.


division

Division, for college football: 11 for FBS, 12 for FCS, otherwise 1 for Division-I, 2 for Division-II, 3 for Division-III.


rankingPeriod

Integer value indicating the ranking period, options can be found from using the @function ncaaSports.getSportDivisionData function.


gameHigh
'Y' | 'N'
logical, indicating whether the statistic desired is of the game-high variety


category

Value for the stat category, can also be found using the @function ncaaSports.getSportDivisionData



Example
const teams =  await sdv.ncaa.getTeamData(sport = 'MFB', year = '2017', division = '11', rankingPeriod = '52', gameHigh='N', category = '20')
Operations for NFL.
Kind: global namespace

nfl : object

.getPlayByPlay(id) ⇒
.getBoxScore(id) ⇒
.getSummary(id) ⇒
.getPicks(id) ⇒
.getSchedule(year, month, day) ⇒
.getScoreboard(year, month, day, limit) ⇒
.getStandings(year, group) ⇒
.getTeamList()
.getTeamInfo(id) ⇒
.getTeamPlayers(id) ⇒




nfl.getPlayByPlay(id) ⇒
Gets the NFL game play-by-play data for a specified game.
Kind: static method of nfl
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nfl.getPlayByPlay(401220403);

nfl.getBoxScore(id) ⇒
Gets the NFL game box score data for a specified game.
Kind: static method of nfl
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nfl.getBoxScore(401220403);

nfl.getSummary(id) ⇒
Gets the NFL game summary data for a specified game.
Kind: static method of nfl
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nfl.getSummary(401220403);

nfl.getPicks(id) ⇒
Gets the NFL PickCenter data for a specified game.
Kind: static method of nfl
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nfl.getPicks(401220403);

nfl.getSchedule(year, month, day) ⇒
Gets the NFL schedule data for a specified date if available.
Kind: static method of nfl
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)



Example
const result = await sdv.nfl.getSchedule(
year = 2019, month = 11, day = 17
)

nfl.getScoreboard(year, month, day, limit) ⇒
Gets the NFL scoreboard data for a specified date if available.
Kind: static method of nfl
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


limit
number
Limit on the number of results @default 300



Example
const result = await sdv.nfl.getScoreboard(
year = 2019, month = 11, day = 17
)

nfl.getStandings(year, group) ⇒
Gets the team standings for the NFL.
Kind: static method of nfl
Returns: json



Param
Type
Description




year
number
Season


group
string
acceptable group names: 'league','conference','division'



Example
const yr = 2021;
const result = await sdv.nfl.getStandings(year = yr);

nfl.getTeamList()
Gets the list of all NFL teams their identification info for ESPN.
Kind: static method of nfl
Example
const result = await sdv.nfl.getTeamList();

nfl.getTeamInfo(id) ⇒
Gets the team info for a specific NFL team.
Kind: static method of nfl
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 16;
const result = await sdv.nfl.getTeamInfo(teamId);

nfl.getTeamPlayers(id) ⇒
Gets the team roster information for a specific NFL team.
Kind: static method of nfl
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 16;
const result = await sdv.nfl.getTeamPlayers(teamId);
Operations for NHL.
Kind: global namespace

nhl : object

.getPlayByPlay(id) ⇒
.getBoxScore(id) ⇒
.getSummary(id) ⇒
.getPicks(id) ⇒
.getSchedule(year, month, day) ⇒
.getScoreboard(year, month, day, limit) ⇒
.getStandings(year, group) ⇒
.getTeamList()
.getTeamInfo(id) ⇒
.getTeamPlayers(id) ⇒




nhl.getPlayByPlay(id) ⇒
Gets the NHL game play-by-play data for a specified game.
Kind: static method of nhl
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nhl.getPlayByPlay(401272446);

nhl.getBoxScore(id) ⇒
Gets the NHL game box score data for a specified game.
Kind: static method of nhl
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nhl.getBoxScore(401272446);

nhl.getSummary(id) ⇒
Gets the NHL game summary data for a specified game.
Kind: static method of nhl
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nhl.getSummary(401272446);

nhl.getPicks(id) ⇒
Gets the NHL PickCenter data for a specified game.
Kind: static method of nhl
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.nhl.getPicks(401272446);

nhl.getSchedule(year, month, day) ⇒
Gets the NHL schedule data for a specified date if available.
Kind: static method of nhl
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)



Example
const result = await sdv.nhl.getSchedule(
year = 2019, month = 11, day = 17
)

nhl.getScoreboard(year, month, day, limit) ⇒
Gets the NHL scoreboard data for a specified date if available.
Kind: static method of nhl
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


limit
number
Limit on the number of results @default 300



Example
const result = await sdv.nhl.getScoreboard(
year = 2019, month = 11, day = 16
)

nhl.getStandings(year, group) ⇒
Gets the team standings for the NHL.
Kind: static method of nhl
Returns: json



Param
Type
Description




year
number
Season


group
string
acceptable group names: 'league','conference','division'



Example
const yr = 2016;
const result = await sdv.nhl.getStandings(year = yr);

nhl.getTeamList()
Gets the list of all NHL teams their identification info for ESPN.
Kind: static method of nhl
Example
const result = await sdv.nhl.getTeamList();

nhl.getTeamInfo(id) ⇒
Gets the team info for a specific NHL team.
Kind: static method of nhl
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 16;
const result = await sdv.nhl.getTeamInfo(teamId);

nhl.getTeamPlayers(id) ⇒
Gets the team roster information for a specific NHL team.
Kind: static method of nhl
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 16;
const result = await sdv.nhl.getTeamPlayers(teamId);
Operations for WBB.
Kind: global namespace

wbb : object

.getPlayByPlay(id) ⇒
.getBoxScore(id) ⇒
.getSummary(id) ⇒
.getRankings(year, week) ⇒
.getSchedule(year, month, day, group, seasontype, limit) ⇒
.getScoreboard(year, month, day, group, seasontype, limit) ⇒
.getConferences(year, group) ⇒
.getStandings(year, group) ⇒
.getTeamList(group) ⇒
.getTeamInfo(id) ⇒
.getTeamPlayers(id) ⇒




wbb.getPlayByPlay(id) ⇒
Gets the Women's College Basketball game play-by-play data for a specified game.
Kind: static method of wbb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.wbb.getPlayByPlay(401260565);

wbb.getBoxScore(id) ⇒
Gets the Women's College Basketball game box score data for a specified game.
Kind: static method of wbb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.wbb.getBoxScore(401260565);

wbb.getSummary(id) ⇒
Gets the Women's College Basketball game summary data for a specified game.
Kind: static method of wbb
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.wbb.getSummary(401260565);

wbb.getRankings(year, week) ⇒
Gets the WBB rankings data for a specified year and week if available.
Kind: static method of wbb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


week
*
Week



Example
const result = await sdv.wbb.getRankings(
year = 2021, week = 4
)

wbb.getSchedule(year, month, day, group, seasontype, limit) ⇒
Gets the Women's College Basketball schedule data for a specified date if available.
Kind: static method of wbb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


group
number
Group is 50 for Division-I, 51 for Division-II, 52 for Division-III


seasontype
number
Pre-Season: 1, Regular Season: 2, Postseason: 3, Off-season: 4


limit
number
Limit on the number of results @default 300



Example
const result = await sdv.wbb.getSchedule(
year = 2021, month = 02, day = 15, group=50
)

wbb.getScoreboard(year, month, day, group, seasontype, limit) ⇒
Gets the Women's College Basketball scoreboard data for a specified date if available.
Kind: static method of wbb
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


group
number
Group is 50 for Division-I, 51 for Division-II, 52 for Division-III


seasontype
number
Pre-Season: 1, Regular Season: 2, Postseason: 3, Off-season: 4


limit
number
Limit on the number of results @default 300



Example
const result = await sdv.wbb.getScoreboard(
year = 2019, month = 02, day = 15, group=50
)

wbb.getConferences(year, group) ⇒
Gets the list of all Women's College Basketball conferences and their identification info for ESPN.
Kind: static method of wbb
Returns: json



Param
Type
Description




year
number
Season


group
number
Group is 50 for Division-I, 51 for Division-II, 52 for Division-III



Example
const yr = 2021;
const result = await sdv.wbb.getConferences(year = yr, group = 50);

wbb.getStandings(year, group) ⇒
Gets the team standings for Women's College Basketball.
Kind: static method of wbb
Returns: json



Param
Type
Description




year
number
Season


group
number
Group is 50 for Division-I, 51 for Division-II, 52 for Division-III, see wbb.getConferences() for more info



Example
const yr = 2020;
const result = await sdv.wbb.getStandings(year = yr);

wbb.getTeamList(group) ⇒
Gets the list of all Women's College Basketball teams their identification info for ESPN.
Kind: static method of wbb
Returns: json



Param
Type
Description




group
number
Group is 50 for Division I, 51 for Division II, 52 for Division III



Example
get list of teams
const result = await sdv.wbb.getTeamList(group=50);

wbb.getTeamInfo(id) ⇒
Gets the team info for a specific WBB team.
Kind: static method of wbb
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 52;
const result = await sdv.wbb.getTeamInfo(teamId);

wbb.getTeamPlayers(id) ⇒
Gets the team roster information for a specific WBB team.
Kind: static method of wbb
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 52;
const result = await sdv.wbb.getTeamPlayers(teamId);
Operations for WNBA.
Kind: global namespace

wnba : object

.getPlayByPlay(id) ⇒
.getBoxScore(id) ⇒
.getSummary(id) ⇒
.getSchedule(year, month, day) ⇒
.getScoreboard(year, month, day, limit) ⇒
.getStandings(year, group) ⇒
.getTeamList() ⇒
.getTeamInfo(id) ⇒
.getTeamPlayers(id) ⇒




wnba.getPlayByPlay(id) ⇒
Gets the WNBA game play-by-play data for a specified game.
Kind: static method of wnba
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.wnba.getPlayByPlay(401244185);

wnba.getBoxScore(id) ⇒
Gets the WNBA game box score data for a specified game.
Kind: static method of wnba
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.wnba.getBoxScore(401244185);

wnba.getSummary(id) ⇒
Gets the WNBA game summary data for a specified game.
Kind: static method of wnba
Returns: json



Param
Type
Description




id
number
Game id.



Example
const result = await sdv.wnba.getSummary(401244185);

wnba.getSchedule(year, month, day) ⇒
Gets the WNBA schedule data for a specified date if available.
Kind: static method of wnba
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)



Example
const result = await sdv.wnba.getSchedule(
year = 2019, month = 07, day = 15
)

wnba.getScoreboard(year, month, day, limit) ⇒
Gets the WNBA scoreboard data for a specified date if available.
Kind: static method of wnba
Returns: json



Param
Type
Description




year
*
Year (YYYY)


month
*
Month (MM)


day
*
Day (DD)


limit
number
Limit on the number of results @default 300



Example
const result = await sdv.wnba.getScoreboard(
year = 2019, month = 07, day = 15
)

wnba.getStandings(year, group) ⇒
Gets the team standings for the WNBA.
Kind: static method of wnba
Returns: json



Param
Type
Description




year
number
Season


group
string
acceptable group names: 'league','conference'



Example
const yr = 2016;
const result = await sdv.wnba.getStandings(year = yr);

wnba.getTeamList() ⇒
Gets the list of all WNBA teams their identification info for ESPN.
Kind: static method of wnba
Returns: json
Example
const result = await sdv.wnba.getTeamList();

wnba.getTeamInfo(id) ⇒
Gets the team info for a specific WNBA team.
Kind: static method of wnba
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 16;
const result = await sdv.wnba.getTeamInfo(teamId);

wnba.getTeamPlayers(id) ⇒
Gets the team roster information for a specific WNBA team.
Kind: static method of wnba
Returns: json



Param
Type
Description




id
number
Team Id



Example
const teamId = 16;
const result = await sdv.wnba.getTeamPlayers(teamId);

© 2020-21 sportsdataverse.js, developed by Saiem Gilani, part of the SportsDataverse


",JavaScript
64,"











eurolig
Overview
Installation
Example





README.md





eurolig

The eurolig package provides a set of tools to obtain and analyze
basketball generated data from the Euroleague.
Overview


API wrapper around the official website of the
Euroleague.


Functions to obtain stats, play-by-play data and shot location data
in a tidy format within R.


Tools to analyze and visualize the data.


Installation
# install.packages(""devtools"")
devtools::install_github(""solmos/eurolig"")
Example
Let’s say we want to analyze play-by-play data from the Championship
game of the 2017-2018 season between Real Madrid and Fenerbache Dogus
Istanbul. We can obtain the data by entering the game code and the
season to the function extractPbp(). The game code for the game can be
found in the game’s
URL.
library(eurolig)
pbp <- extractPbp(game_code = 260, season = 2017)
pbp
#> # A tibble: 583 x 29
#>    season game_code play_number team_code player_name play_type
#>     <int>     <dbl>       <int> <chr>     <chr>       <chr>    
#>  1   2017       260           2 <NA>      <NA>        BP       
#>  2   2017       260           3 MAD       AYON, GUST… TPOFF    
#>  3   2017       260           4 ULK       GUDURIC, M… TPOFF    
#>  4   2017       260           5 ULK       DUVERIOGLU… 2FGM     
#>  5   2017       260           6 ULK       GUDURIC, M… AST      
#>  6   2017       260           7 ULK       VESELY, JAN CPF      
#>  7   2017       260           8 MAD       REYES, FEL… RPF      
#>  8   2017       260           9 MAD       AYON, GUST… 2FGA     
#>  9   2017       260          10 MAD       AYON, GUST… ORB      
#> 10   2017       260          11 ULK       GUDURIC, M… CPF      
#> # … with 573 more rows, and 23 more variables: time_remaining <chr>,
#> #   quarter <dbl>, points_home <dbl>, points_away <dbl>, play_info <chr>,
#> #   seconds <dbl>, home_team <chr>, away_team <chr>, home <lgl>,
#> #   team_name <chr>, last_ft <lgl>, and1 <lgl>, home_player1 <chr>,
#> #   home_player2 <chr>, home_player3 <chr>, home_player4 <chr>,
#> #   home_player5 <chr>, away_player1 <chr>, away_player2 <chr>,
#> #   away_player3 <chr>, away_player4 <chr>, away_player5 <chr>,
#> #   lineups <chr>
From these data we can extract information about the assists in that
game from, say, Real Madrid (MAD):
assists <- getAssists(pbp, team = ""MAD"")
assists
#> # A tibble: 16 x 13
#>    season game_code team_code passer shooter shot_type points
#>     <int>     <dbl> <chr>     <chr>  <chr>   <chr>      <dbl>
#>  1   2017       260 MAD       FERNA… LLULL,… 3FG            3
#>  2   2017       260 MAD       LLULL… RANDOL… 3FG            3
#>  3   2017       260 MAD       FERNA… TAYLOR… 2FG            2
#>  4   2017       260 MAD       LLULL… TAVARE… 2FG            2
#>  5   2017       260 MAD       DONCI… CARROL… 2FG            2
#>  6   2017       260 MAD       TAYLO… THOMPK… 2FG            2
#>  7   2017       260 MAD       DONCI… TAVARE… 2FG            2
#>  8   2017       260 MAD       DONCI… CARROL… 3FG            3
#>  9   2017       260 MAD       AYON,… CAUSEU… 3FG            3
#> 10   2017       260 MAD       CAUSE… REYES,… 2FG            2
#> 11   2017       260 MAD       DONCI… CAUSEU… 3FG            3
#> 12   2017       260 MAD       CAUSE… REYES,… 2FG            2
#> 13   2017       260 MAD       FERNA… DONCIC… 3FG            3
#> 14   2017       260 MAD       TAVAR… LLULL,… <NA>           0
#> 15   2017       260 MAD       TAVAR… CARROL… 3FG            3
#> 16   2017       260 MAD       THOMP… TAVARE… 2FG            2
#> # … with 6 more variables: time_remaining <chr>, quarter <dbl>,
#> #   seconds <int>, foul <lgl>, and1 <lgl>, ftm <dbl>
Shot location data can also be retrieved and visualized:
shots <- extractShots(260, 2017)
plotShotchart(shots)



",R
65,"











basketball_trajectory_prediction
Setup
The files
Run
Contact me





README.md




basketball_trajectory_prediction
This repo is an open source of paper : Applying bidirectional LSTM and Mixture Density Network for Basketball Trajectory Prediction.
I strongly recommend you to review Rajiv and Rob's repo at first.  the URL is https://github.com/RobRomijnders/RNN_basketball.
I think they made cool job and details about basketball prediction. Also you can find their paper and referrences in the repo.
Based on their contribution, I set up a new repo, which proposed Bidirectional LSTM and Mixture Density Network (BLSTM-MDN) for the same prediction problem.
I did 2 jobs in the main, Hit or miss classification and trajecotry generating.
In the first job, users can choose one of models, including CNN, LSTM, BLSTM, LSTM-MDN and BLSTM-MDN. And trajectory genarating only works for LSTM-MDN and BLSTM-MDN.
Setup

TesnsorFlow 1.0 
sklearn 
hyperopt 

The files

data: the original data is in 'seq_all.csv.tar.gz', and the 'seq_all.csv' is the unziped dataset.
plot_staff: the scripts and final figures based on the models
dataloader.py: data pre-process
model.py: build model by TensorFlow
util_MDN: utility functions for building model
sample.py: functions used for generating trajectory
main.py: main steps for classification and generating

Run
Simply run file ""main.py"" in terminal with default argpases: python main.py
Here is the explanation of each argpase.
  paser.add_argument(""--hidden_layers"", type=int,
                     default=2, help=""number of hidden layer "")
  paser.add_argument(""--seq_len"", type=int, default=12,
                     help=""sequence length"")
  paser.add_argument(""--dist"", type=float, default=5.0,
                     help=""distance from point to center"")
  paser.add_argument(""--hidden_size"", type=int, default=64,
                     help=""units num in each hidden layer"")
  paser.add_argument(""--drop_out"", type=float, default=0.7,
                     help=""drop out probability"")
  paser.add_argument('--learning_rate', type=float, default=0.005,
                     help=""learning_rate"")
  paser.add_argument('--epoch', type=int, default=1,
                     help=""epoch"")
  paser.add_argument('--batch_size', type=int, default=64,
                     help=""batch size"")
  paser.add_argument('--model_type', type=str, default='BLSTM_MDN_model',
                     help='the model type should be LSTM_model, \
                       bidir_LSTM_model, CNN_model, Conv_LSTM_model, \
                       LSTM_MDN_model or BLSTM_MDN_model.')
If you want to generate some trajetories, please set ""generate_trajectory"" as True in code. Because it is False in default.
It should be noted that it only generates traejctory with BLSTM-MDN or LSTM-MDN.
Contact me
Be free the ust the code for studying. But please contact me if you want for commercial applying. 
You are welcome to pull requests or issues. 
E-mail: zhaoyuafeu@gmail.com 
Facebook: zhaoyuafeu 


",Python
66,"











basketball_data_science
Agenda





README.md




basketball_data_science
Working through Basketball Data Science using py_ball and Python
Agenda
My goal is to work through the book Basketball Data Science with Applications in R (BDS) by Zuccolotto and Manisera. The twist is that this repository will leverage py_ball to source all of the data and the analysis will be done in Python. The hope is that this effort will expose a wider audience to the work presented in BDS and the available data. This repository will work through the following chapters:

Chapter 2: Data and Basic Statistical Analyses

Pace and Ratings
Inequality Analysis
Shot Charts


Chapter 3: Discovering Patterns in Data

Assist Networks
Shot Density


Chapter 4: Finding Groups in Data

Shot Clustering


Chapter 5: Modeling Relationships in Data

Each chapter is decently long, so there may be multiple Jupyter notebooks per chapter, depending on how things shake out.
Feel free to reach out with any questions by opening an issue here or tweeting me.


",Python
67,"



README.md




Activity-Recognition



",Python
68,"



README.md




nba-jam-tournament-edition


",Assembly
69,"











bbr: basketball-reference data in R
Installation
Example usage





README.md




bbr: basketball-reference data in R
    
The bbr package is designed to quickly fetch tidy data from www.basketball-reference.com. This package is actively under development and the interface will change as new features are added.
Installation
devtools::install_github(""mbjoseph/bbr"")
Example usage
The get_season function retrieves season summary data for one season.
library(bbr)

ninetyone <- get_season(1991)
str(ninetyone)
## 'data.frame':    441 obs. of  31 variables:
##  $ player     : chr  ""Alaa Abdelnaby"" ""Mahmoud Abdul-Rauf"" ""Mark Acres"" ""Michael Adams"" ...
##  $ pos        : chr  ""PF"" ""PG"" ""C"" ""PG"" ...
##  $ age        : num  22 21 28 28 31 31 27 26 26 26 ...
##  $ tm         : chr  ""POR"" ""DEN"" ""ORL"" ""DEN"" ...
##  $ g          : num  43 67 68 66 78 80 42 34 68 26 ...
##  $ gs         : num  0 19 0 66 13 0 1 0 2 0 ...
##  $ mp         : num  290 1505 1313 2346 2006 ...
##  $ fg         : num  55 417 109 560 420 337 99 59 116 27 ...
##  $ fga        : num  116 1009 214 1421 909 ...
##  $ fg_pct     : num  0.474 0.413 0.509 0.394 0.462 0.472 0.44 0.504 0.43 0.37 ...
##  $ three_p    : num  0 24 1 167 24 102 5 7 0 0 ...
##  $ three_pa   : num  0 100 3 564 78 251 21 23 1 1 ...
##  $ three_p_pct: num  NA 0.24 0.333 0.296 0.308 0.406 0.238 0.304 0 0 ...
##  $ two_p      : num  55 393 108 393 396 235 94 52 116 27 ...
##  $ two_pa     : num  116 909 211 857 831 463 204 94 269 72 ...
##  $ two_p_pct  : num  0.474 0.432 0.512 0.459 0.477 0.508 0.461 0.553 0.431 0.375 ...
##  $ efg_pct    : num  0.474 0.425 0.512 0.453 0.475 0.543 0.451 0.534 0.43 0.37 ...
##  $ ft         : num  25 84 66 465 240 114 41 26 60 16 ...
##  $ fta        : num  44 98 101 529 317 138 48 31 115 28 ...
##  $ ft_pct     : num  0.568 0.857 0.653 0.879 0.757 0.826 0.854 0.839 0.522 0.571 ...
##  $ orb        : num  27 34 140 58 134 45 41 10 97 26 ...
##  $ drb        : num  62 87 219 198 240 160 76 14 221 49 ...
##  $ trb        : num  89 121 359 256 374 205 117 24 318 75 ...
##  $ ast        : num  12 206 25 693 139 285 45 22 16 3 ...
##  $ stl        : num  4 55 25 147 47 63 15 8 35 8 ...
##  $ blk        : num  12 4 25 6 20 13 8 1 45 9 ...
##  $ tov        : num  22 110 42 240 128 100 40 16 84 22 ...
##  $ pf         : num  39 149 218 162 209 195 88 11 140 29 ...
##  $ pts        : num  135 942 285 1752 1104 ...
##  $ start_year : num  1990 1990 1990 1990 1990 1990 1990 1990 1990 1990 ...
##  $ end_year   : num  1991 1991 1991 1991 1991 ...

The get_players function gets player data for individuals by last initial.
a_data <- get_players(""A"")
str(a_data)
## 'data.frame':    158 obs. of  9 variables:
##  $ player    : chr  ""Alaa Abdelnaby"" ""Zaid Abdul-Aziz"" ""Kareem Abdul-Jabbar"" ""Mahmoud Abdul-Rauf"" ...
##  $ from      : int  1991 1969 1970 1991 1998 1997 1977 1957 1947 2017 ...
##  $ to        : int  1995 1978 1989 2001 2003 2008 1981 1957 1948 2018 ...
##  $ pos       : chr  ""F-C"" ""C-F"" ""C"" ""G"" ...
##  $ ht        : chr  ""6-10"" ""6-9"" ""7-2"" ""6-1"" ...
##  $ wt        : int  240 235 225 162 223 225 220 180 195 190 ...
##  $ birth_date: chr  ""June 24, 1968"" ""April 7, 1946"" ""April 16, 1947"" ""March 9, 1969"" ...
##  $ college   : chr  ""Duke University"" ""Iowa State University"" ""University of California, Los Angeles"" ""Louisiana State University"" ...
##  $ slug      : chr  ""abdelal01"" ""abdulza01"" ""abdulka01"" ""abdulma02"" ...

The get_player_data function returns data for each season that a player played. As an argument, this function takes a slug for the player you're interested in. This can be found using the get_players() function, and is part of the URL to the data of a player, e.g., if the URL is https://www.basketball-reference.com/players/a/abdelal01.html then the slug is abdelal01.
abdelnaby_d <- get_player_data('abdelal01')
str(abdelnaby_d)
## 'data.frame':    9 obs. of  32 variables:
##  $ player     : chr  ""Alaa Abdelnaby"" ""Alaa Abdelnaby"" ""Alaa Abdelnaby"" ""Alaa Abdelnaby"" ...
##  $ season     : chr  ""1990-91"" ""1991-92"" ""1992-93"" ""1992-93"" ...
##  $ age        : int  22 23 24 24 24 25 26 26 26
##  $ tm         : chr  ""POR"" ""POR"" ""TOT"" ""MIL"" ...
##  $ lg         : chr  ""NBA"" ""NBA"" ""NBA"" ""NBA"" ...
##  $ pos        : chr  ""PF"" ""PF"" ""PF"" ""PF"" ...
##  $ g          : int  43 71 75 12 63 13 54 51 3
##  $ gs         : int  0 1 52 0 52 0 0 0 0
##  $ mp         : num  6.7 13.2 17.5 13.3 18.3 12.2 9.4 9.3 10
##  $ fg         : num  1.3 2.5 3.3 2.2 3.5 1.8 2.2 2.3 0.3
##  $ fga        : num  2.7 5.1 6.3 4.7 6.6 4.2 4.3 4.3 3.7
##  $ fg_pct     : num  0.474 0.493 0.518 0.464 0.525 0.436 0.511 0.532 0.091
##  $ three_p    : num  0 0 0 0 0 0 0 0 0
##  $ three_pa   : num  0 0 0 0.1 0 0 0 0 0
##  $ three_p_pct: num  NA NA 0 0 NA NA 0 0 NA
##  $ two_p      : num  1.3 2.5 3.3 2.2 3.5 1.8 2.2 2.3 0.3
##  $ two_pa     : num  2.7 5.1 6.3 4.6 6.6 4.2 4.2 4.3 3.7
##  $ two_p_pct  : num  0.474 0.493 0.519 0.473 0.525 0.436 0.515 0.537 0.091
##  $ efg_pct    : num  0.474 0.493 0.518 0.464 0.525 0.436 0.511 0.532 0.091
##  $ ft         : num  0.6 1.1 1.2 1 1.2 1.2 0.4 0.4 0
##  $ fta        : num  1 1.4 1.5 1.3 1.6 1.9 0.6 0.7 0
##  $ ft_pct     : num  0.568 0.752 0.759 0.75 0.76 0.64 0.571 0.571 NA
##  $ orb        : num  0.6 1.1 1.7 1 1.8 0.9 0.7 0.7 1
##  $ drb        : num  1.4 2.5 2.8 2.1 3 2.6 1.4 1.4 1.7
##  $ trb        : num  2.1 3.7 4.5 3.1 4.8 3.5 2.1 2.1 2.7
##  $ ast        : num  0.3 0.4 0.4 0.8 0.3 0.2 0.2 0.3 0
##  $ stl        : num  0.1 0.4 0.3 0.5 0.3 0.2 0.3 0.3 0
##  $ blk        : num  0.3 0.2 0.3 0.3 0.3 0.2 0.2 0.2 0
##  $ tov        : num  0.5 0.9 1.3 1.1 1.3 1.3 0.8 0.8 1.7
##  $ pf         : num  0.9 1.9 2.5 2 2.6 1.5 1.9 2 0.7
##  $ pts        : num  3.1 6.1 7.7 5.3 8.2 4.9 4.7 5 0.7
##  $ slug       : chr  ""abdelal01"" ""abdelal01"" ""abdelal01"" ""abdelal01"" ...



",R
70,"











The Porzingis Project
How to Run
Requires:





README.md




The Porzingis Project
A script that scrapes stats for each player in the NBA from Basketball Reference, TeamRankings, and Rotowire, and generates an expected points value for each player. These expected points are then fed to a greedy algorithm that maximizes the total expected fantasy points while staying under a salary cap using a heuristic of preferencing undervalued players.
How to Run
Clone the repo and run
python NBAFantasyStats.py

Requires:

BeautifulSoup

Shoutout to Kristaps Porzingis for being the algorithm MVP


",Python
71,"














Bounce - Basketball Court Finder
What is Bounce?
Home Page
Courts Page
Contributing
Visit Contributing.md
Features
Next Steps
Future Plans!
Tech
Setup
Docker
Troubleshooting





README.md




Bounce - Basketball Court Finder
What is Bounce?
Bounce is a web app built in Django that locates and displays the nearest basketball courts in the area. With over 48,000 documented basketball across North America, there is bound to be one near you. The goal of this project is to build a community for basketball and other sports enthusiasts.
Home Page

Courts Page

Contributing
Visit Contributing.md
Features

Basketball court listing of outdoor courts near specified address/location
Light and Dark Theme for Maps
GraphQL / REST API endpoint

Next Steps

Implement more testing and test coverage (API, Model, End to End Testing with Cypress.io
Building CI/CD pipeline and linting for better code reviewing and deployment
Interfaces for User Feedback
Ensure pages are mobile friendly

Future Plans!

Load courts through REST / GraphQL API
User Accounts

Court Ratings
Save frequently visited courts
Submit Court to be added to Map


Decouple front and backend

Tech
Bounce uses a number of open source projects and APIs to work properly:

Heroku - PAAS to Host Bounce
Django - Python Web Framework
LocationIQ API - used to get reverse geocoding results for markers
Mapbox API - used to provide forward-geocoding results and mapping
PostgreSQL - SQL database for scalability, modularity, and geoquerying support

Setup
Docker


Install Docker and Docker Compose


Make docker_entrypoint.sh executable
# Linux
chmod +x docker_entrypoint.sh


Start and build the 2 containers

--build builds the images defined in the docker-compose.yml file.
-d dettaches the terminal from the building process.
Finally the script from (docker_entrypoint.sh) is executed.

# In the same directory as `docker-compose.yml`
docker-compose up -d --build

If there are errors you can see the logs

docker-compose logs


Load Initial Database Models

It's also necessary to load in the fixtures when setting up the database:

docker-compose exec web python manage.py loaddata bounce_data.json


Go to http://localhost:8000

You should see the frontend of the project




Enter a shell within the Docker container

To enter an interactive shell (in this case for the ""web"" service), you can use

docker-compose exec web bash


Create a superuser (Optional)

You may enter an interactive shell within the Docker container
(in this case the container corresponding to the ""web"" service)
In the same directory as docker-compose.yml run

# This open a bash shell inside the container
docker-compose exec web bash


Then run python manage.py createsuperuser


Run exit to exit the container. It will keep running.




To stop the containers run docker-compose stop

⚠️ Be careful with docker-compose down which stops the container but also removes them.
=======



Troubleshooting
Ensure that your .env file is present and the required variables are set.
Sometimes starting fresh can help, since things like volumes will persist
even after a container is removed, which can cause issues. You can remove all
docker containers and volumes using the command:
docker-compose down && docker rm -f $(docker ps -a -q) && docker volume rm $(docker volume ls -q)
and then trying the above steps again.


",CSS
72,"











React + Remotion basketball tracker
Commands
Docs
Help
Issues
License





README.md




React + Remotion basketball tracker

See tutorial (8min): https://youtu.be/A8miHLSf_BI
Since this is a fun project, no issues / pull requests are accepted.
Commands
Install Dependencies
npm i
Start Preview
npm start
Render video
npm run build
Upgrade Remotion
npm run upgrade
Docs
Get started with Remotion by reading the fundamentals page.
Help
We provide help on our Discord server.
Issues
Found an issue with Remotion? File an issue here.
License
Notice that for some entities a company license is needed. Read the terms here.


",TypeScript
73,"














Shot Plotter
How to Use and Additional Information
Event Details
Customizing Setup
Playing Area
Table
Download/Upload Table
Running Locally





README.md




Shot Plotter

09/13/22: Soccer (NCAA) has been added as a playing area
A web application for plotting events on a sport's playing area with a single click, while keeping track of any other details. The application supports download and upload of .csv files to retrieve that plotted data.
Currently 13 different playing areas across 9 different sports are supported: ice hockey (NHL, IIHF), floorball (IFF), handball (IHF), volleyball (NCAA), basketball (NBA, NCAA, WNBA), men's lacrosse (NCAA), women's lacrosse (NCAA), American football (NFL, NCAA), and soccer (NCAA).

The web application is primarily built using D3.js.
How to Use and Additional Information
From the main page, click on the sport/playing area you want. Each option has information about the specifications that describe that particular playing area, and its dimensions, which correspond to the coordinates.
Event Details
By default, four pieces of information can be specified for each event.
The period of the event can be logged through radio buttons.
The team can be specified through radio buttons and a text field that allows custom team names to be entered. The first team, which defaults to Home, corresponds to teal dots, and the second team, which defaults to Away, corresponds to orange dots. The legend below the rink clarifies which color corresponds to which team.
The player can be specified through a text field. If the player entry is 2 characters or less (for a player number, say), the player will appear on the event dot on the playing area.
The type of event can be specified, under Type or Outcome.Additional options can be specified by typing in the dropdown and selecting the new option that appears by clicking or pressing Enter. Each option corresponds to a different dot shape, as indicated by the legend below the rink.
Details logged for each event can be customized by clicking on the Customize Details button at the bottom of the details panel. Details can only be customized when there are noevents recorded.
Customizing Setup
Clicking the Customize Setup button will bring up a modal with a list of the current details. Drag-and-drop detail names to reorder them. Click on the eye icon to toggle whether it is visible. Click on the trash can icon to delete details. For created details, click on the pencil-in-a-square icon to edit those details. Reordering details changes their position in both the details panel and the table. The X and Y details cannot be hidden or deleted.
Special details can be added, which are details that do not take inputs but are specially calculated. Currently there a 3 types of special details:

2-Location Events: Using the Enable 2-Location Events toggle, the ability to have 2-location events can be enabled. When enabled, X2 and Y2 details are added to the list of details. Like the X and Y details, the X2 and Y2 details cannot be hidden or deleted. When 2-location events are enabled, 2-location events can be plotted by either holding down the SHIFT button and clicking on two points in the playing area or by switching between 1-location and 2-location mode using the toggle above the playing area. This option is incompatible with Heat Map View.
Distance: For 1-location events, this detail will be the distance between the event and the closest net/hoop/end zone line center/etc. For 2-location events, this detail will be the be the distance between the two indicated locations.
Shot Value (basketball only): This detail is the number of points (2 or 3) a shot from the indicated location would be worth. For 2-location events, it will be the number of points for the second location.

There are several appearance options, which modify the appearance of the application but do not impact the data tracked. There are currently 3 appearance options:

Widgets per Panel Row: The number of widgets can be changed from its default value of 2 to 1 or 3 by choosing a new value in the dropdown labelled Widgets per Panel Row.
Rows per Table Page: The default number of events per table page can be modified by changing the number in the field labelled Rows Per Table Page. The default number is 10; the number must be an integer between 1 and 999 (inclusive).
Heat Map View: By toggling on the option labelled Heat Map View, the option for heat maps (2D density plots) view is enabled. This adds a toggle above the playing area that allows switching between the traditional view with event dots and view that shows the location density of events per team (if Team is a current detail). Two checkboxes below the toggle allow hiding and showing the heat map for each team. This option is incompatible with 2-Location Events.

Default details can be restored by clicking on the Reset to Defaults button.
Details configurations can be saved or restored through download/upload. When a detail configuration is downloaded, it stores the current order and visibility of details, as well as any newly created details. Also, currently selected/entered options in the details panel are made the default options when the configuration is uploaded; if a detail is not visible, it preserves its original default value.
Clicking on the Add Details Button allows creation of new details. There are four options for types of new details: radio buttons, text field, dropdown, and time widget. The name of all details must be 1-16 characters.
Radio buttons are limited to at most 5 options; each option must be between 1-32 characters and all options must be unique. The default value can be selected by checking the appropriate radio button.
For a text field, a default value can be entered and can be up to 32 characters.
For a dropdown, options are entered in a text area, with each option on a new line. Each option must be between 1-50 characters. The first option is the default selection. Unlike with the Type detail, new options cannot be added from the details panel, though options can still be searched.
A time widget is a timer you can choose to have count up or countdown. The starting time can be inputted when creating the detail; times must be in the format MM:SS or M:SS, where (M)M is minutes and SS is seconds. When using the time widget in the details panel, the time can be edited any time the time widget is paused. The timer can be paused/started by clicking on the button next to the time.
Playing Area
To plot events, simply click on the playin area where the event happened. When clicked, a dot will be added of the appropriate color based on team, shape based on type, and text based on player, and a row will be made in the table.
The playing area matches the specifications from the governing body as specified on the main page. For all playing areas, the center of the playing area has coordinates (0,0), the positive x-axis is to the right, and the positive y-axis is upward.
Credit to Bill Tran's guide on creating the NHL rink using TidyVerse for aid in interpreting the rule descriptions for the ice hockey rink and for the hex codes for the colors.
Massive credit to the sportyR package created by Ross Drucker, using which the American Football fields (NFL and NCAA) were constructed.
The playing area size is not pinned to the window size. This allows you to zoom in and place the event exactly where you want it, but does mean the layout can become strange if you change your window size. Refreshing will readjust the size to match the current window size.
Table
The table logs the information for each event, as well as the row number of the event in the table. Events can be highlighted by clicking on the check box for the appropriate row. This will highlight the row in the matching team color, and both enlarge the dot on the rink and move it to the front if it was previously covered by other dots. Multiple events can be highlighted at once. Events can be deleted by clicking on the trash can in the appropriate row. All events can be deleted by clicking on the trash can in the header of the table; a prompt will confirm this choice.
The table, by default, shows the last page, which has the last 10 events recorded. Pages can be navigated using the Prev(ious) and Next buttons at the lower-right of the table. The currently shown events and the total number of events recorded can be seen in the bottom-left of the table.
By click on the funnel icon in the header of the table, the filters become visible beneath the table headers and apply to the column in question. Multiple filters can be active at once; if there are multiple filters, only events that fit the criteria of all filters are visible. Events are filtered from both the table and playing area - in other words, events that do not fit the filter criteria are not visible as a row in the table or as a dot in the playing area. The form of the filter varies by the detail type:

Numeric/Time (e.g. X, Y, #): Numeric or time details will have a filter that takes a minimum and a maximum value and filters out any events with values for that detail not in the range specified. The range is inclusive of the minimum and maximum. If no value is specified for either the minimum or maximum, it is treated as if there is no limit in that direction. For example, if the minimum is indicated to be 4 and there is no maximum value indicated, only rows with a value of 4 or greater will be visible.
Radio Buttons/Dropdown (e.g. Period, Team, Type): Radio button and dropdown details will have a filter that takes the form of a dropdown and filters out any events with values not selected in the dropdown. If the dropdown has no selected options, it is as if the filter does not exist. It is possible to select multiple options in the dropdown filter; in this case, events with values corresponding to any currently selected in the dropdown will be visible. For example, if a dropdown filter currently has the values Shot and Goal selected, events with the value Shot OR the value Goal for that detail will be visible.
Text (e.g. Player): Text details will have a filter that is just a text box: any string that contains the string in the text box filter will satisfy the filter. If the string is surrounded in quote marks, double or single, instead only exact matches for the string satisfy the filter. For example, for the filter value hat, both hate and chat will be visible, but for the filter value 'hat' only the value 'hat' will suffice. It is also possible to use regular expressions in the text box filter for more complex text queries.

Clicking on the funnel icon will toggle whether the filters are visible. Filters are applied regardless of whether the filters are visible or not; hiding them does not remove all filters. When at least one filter is active and the filters are visible, a small X-in-a-square icon will appear near the funnel icon; clicking this X icon will clear all filters.
The number of currently filtered rows is also visible in the bottom left of the table.
Download/Upload Table
The event table information can be downloaded by pressing the Download button. There is a text-field to customize the name of the file; otherwise, it defaults to the day and time when the web app was opened. Files are in .csv format, using comma separators, with the header row as it appears on the table, excluding #, included in the file. When filters are active, only currently visible events that satisfy the filters are included in the file; this is indicated by the text of the button saying Download Filter rather than just Download.
To initialize the table, a .csv file can be uploaded using the Choose File button next to the Upload label. Only .csv files are permitted. The header row must exactly match the header row of the table, excluding #, including order. Any custom shot types will be added in shot order. Custom teams will be added in order as they appear, alternating between the teal and orange team. This means if a shot by the orange team is logged first, when the file is downloaded and later uploaded, the team will be blue, but besides color there is no impact to the web app. When a file is uploaded, any shots previously in the table are erased.
Running Locally
To run the application locally, any method of running an HTTP server is needed to prevent browser issues with CORS (cross-origin requests - essentially not allowing the JS files to be loaded using the file:// protocol). Some methods include http-server in Node.js, http.server in Python, or even some browser-based options like the Web Server for Chrome extension, but any option will do.
Then, clone this repository; for most methods, it is sufficient to navigate into the repository folder and run the server, but check the exact way of starting a server for the chosen method. No additional packages need to be installed; additional packages are automatically acquired using CDNs.


",HTML
74,"











Ball-Fall-Android-game
Aptoide store link:
screenshots:
Tools used:
Contributing
Team:





README.md




Ball-Fall-Android-game


Ball Fall is an addictive catch game. Keep your eyes open and your fingers ready.
Aptoide store link:
Download here
screenshots:
 
Tools used:

Visual studio (IDE)
C# (logic)
Unity (game engine)
Paint.Net (Image editting)

Contributing
Feel free to fork this project and add whatever you like. If you have any suggestions or any comments please feel free to contact me or to open an issue.
Team:
Jetlighters having fun.


",C#
75,"











NCAA Bracket Randomizer
No randomness
Some
Lots of randomness
Calculating the Odds





README.md




NCAA Bracket Randomizer
Generates a reasonable bracket for you, based on Ken Pomeroy's
college basketball ratings.
This code was a hack when I first wrote it 14 years ago, another hack when I
re-wrote it 8 years ago, and even worse today. I use it once a year though, and
it works just fine even though it's still using jQuery and an ancient d3.
For each matchup, it compares the two teams in the game, calculates the odds of the favorite
winning the game, and chooses the winner. There are three settings that determine how it
does so:
No randomness
Always picks the favorite
Some
Picks the underdog if they win twice in a row.
If team A has a 75% chance of beating team B, the program will generate two random numbers
between 0 and 100; if both of them are greater than 75, team B will advance. Otherwise,
team A will advance.
Lots of randomness
Picks the underdog if they win once
If team A has a 75% chance of beating team B, the program will generate a random number
between 0 and 100; if it's greater than 75, team B will advance. Otherwise,
team A will advance.
Calculating the Odds
This ipython notebook shows how I fit a very simple exponential curve to kenpom's predictions to reverse-engineer his win percentages. I then use the curve that fitted his predctions to decide how likely one team is to beat another, based on the difference between their kenpom ratings.


",Python
76,"











Basketball Tracking 🏀⛹🏻‍♀️⛹🏿‍♂️
Overview
Requirements
Usage
Forward Pass Only
Track Backwards + Forwards
References / Credit





README.md




Basketball Tracking 🏀⛹🏻‍♀️⛹🏿‍♂️
Created by Brett Fazio and William Chen


Overview
Read our paper here.
Requirements
The libraries to run the code are cv2, numpy, pandas, and h5py (if trying to run/evaluate on the A2D dataset).
An extended version of cv2, opencv-contrib-python, is required. Make sure this is the only cv2 package installed. opencv-python is a different package that does not include support for the trackers. Do not install multiple different opencv packages in the same environment.
pip install opencv-contrib-python

Additionally access to the YOLO tracker is required but this is already included in the /src/yolo folder. However, you must download the weights for the YOLO model. It can be done as follows:
cd src/yolo/weights/
bash download_weights.sh

If you wish to use the GOTURN tracker instead of the CSRT tracker (we recommend CSRT) you must download the GOTURN model here and place it within the src folder.
To run on the A2D dataset, the Release of the dataset itself is also required. It is available here and the unzipped folder entitled Release should be placed in the /a2d directory.
Usage
The main entry point for this project is main.py. To avoid errors, please run it from the src directory.
The most basic usage for the project would be to run on a single input video. It can be done as follows:
python3 main.py --video PATH

Where PATH is a path to a video file, for example:
python3 main.py --video ../sample_data/lebron_on_court.mp4

Adding the --fast flag only tracks the ball in frames after the first detection.
python3 main.py --video ../sample_data/lebron_on_court.mp4 --fast

Adding the --live flag allows for real-time tracking. Live tracking is only available when used with the --fast flag.
Note: performance may be vary depending on CPU/GPU.
python3 main.py --video ../sample_data/lebron_on_court.mp4 --fast --live

To run A2D add the --a2d flag, and then to specify the number of samples use --a2d_amt. For example:
python3 main.py --a2d --a2d_amt 5

Forward Pass Only

Track Backwards + Forwards

References / Credit
This project builds on the work of eriklindernoren's PyTorch Yolo implementation as a base, specifically the pre-trained model. The repository can be found here.


",Python
77,"














joi-router
Todo List
How to install
Get Started
Input Validaiton
Output Validation
Node compatibility
Performance
LICENSE





README.md




joi-router
🏀 Input & Output validated routing for Express
   
Todo List

✅ Input Validated Routing
✅ Output Validated Routing
✅ Examples to show how to use joi-router
✅ Self-contained Test
✅ Continuous integration
✅ Code coverage
☑️ Joi-router to api documents

How to install
yarn add joi-router
Get Started
Input Validaiton
const express = require('express')
const Joi = require('joi')
require('joi-router')
const app = express()

app.get('/foo', {query: {
  userId: Joi.string().alphanum().min(3).max(30).required()
}}, function (req, res, next) {
  res.json({
    result: 'success'
  })
})

Output Validation
app.get('/foo', {
  output: {
    '200': { content: Joi.string().alphanum().min(3).max(30).required() }
  }
}, function (req, res, next) {
  res.json({
    content: 'Lorem'
  })
})

app.listen(3000, () => {
  console.log('Server Run!')
})

Node compatibility
NodeJS >= 6.0 is required.
Performance
Joi-router only run once to add validation middleware when express start, so it does not make express slow.
LICENSE



",JavaScript
78,"











Kodi Magenta Sport Addon (ehem. Telekom Sport)
Über
Installation
About
Installation





README.md




Kodi Magenta Sport Addon (ehem. Telekom Sport)
Über
Mit diesem Addon kann man die Sportstreams von Magenta Sport (ehem.
Telekom Sport) ansehen.
Installation
Das zipfile von der Releases Seite downloaden und in Kodi unter Addons
installieren.
Bei Problemen gerne ein Github-Issue aufmachen oder eine E-Mail an
hubsif@gmx.de.
About
This addon let's you watch the sports streams from Magenta Sport
(formerly Telekom Sport).
Installation
Download the addon zipfile from the releases page and install it in
Kodi -> Addons.


",Python
79,"











Hoop
Requirements
Screenshots





README.md




Hoop
An NBA sporting app built with flutter(Googles UI framework) and the NBA-API.
Requirements
Note: Its important to get your API Key, the below steps explain how you can acheive this. Always take care to keeping your Api keys a secret.

log on to https://rapidapi.com/ and register an account if you don't have one.
After registering your account, go to the Api marketplace and subscribe to the Api-NBA @ https://rapidapi.com/api-sports/api/api-nba
Select a free plan which allows you to make a 100 calls per day.
Once subscribed to the Api on a free plan, get your API key.
Now Navigate to this file path on this project repo i.e lib/services/apikey
create a new dart file called ""key.dart""
paste below code in the dart file:

class NbaApi {
  static final key = ""YOUR-API-KEY-GOES-HERE"";
}


Save the file, you should now be able to run the app on your device.

Screenshots







",Dart
80,"



README.md




##1 搭建项目开发环境
1.1 安装 CocosCreator
##2 打开项目
2.1 选择打开其他项目，然后选择本项目目录
2.2 项目初始化后你会看到

##3 运行项目
3.1 可以选择浏览器和模拟器运行项目

3.2 点击小三角运行项目

浏览器运行

模拟器运行



",JavaScript
81,"











Scoreboard
Usage
Screenshots
Contact





README.md




Scoreboard

Scoreboard is a simple, secure and easy to use Scoreboard application built on Node.js and Socket.io.
Scoreboard uses Socket.io's real time bidirectional event based communication system to integrate the scoreboard to the mobile-ready remote in real time.
Usage
Clone the repository from GitHub by running the following in the terminal.
$ git clone https://github.com/rukmal/Scoreboard.git
All of the Scoreboard configuration is stored in the config.json file. It must have the following data:
{
	""_comment"": ""All times must be in milliseconds"",
	""tournament_logo"": """",
	""team_home"": """",
	""team_away"": """",
	""password"": """",
	""half_length"": 0,
	""timeout_length"": 0,
	""halftime_length"": """",
	""shot_clock_length"": 0
}
Note: all fields filled with a '0' must be numbers. Also note that the configuration file is loaded when the application starts, so if any changes are made, the app must be restarted.
Next, install all dependencies using npm (the Node.js package manager) and run the application.
$ cd Scoreboard
$ npm install
$ node app.js
Navigate to localhost:3000 in your browser and enjoy!
Screenshots


Main scoreboard



Remote on an iPhone 5



Contact
This is an open source project released under the MIT License. Contact me if you want to suggest an improvement, or fork and send a pull request!
Follow me on Twitter (@rukmal) and GitHub.
http://rukmal.me


",JavaScript
82,"



README.md




Tagging Basketball Events with HMM
This case study shows how to implement Hidden Markov Models (HMM) in Stan using basketball player tracking data for the purpose of tagging events. The document doc/hmm.html discusses what a HMM is, how we fit HMMs in Stan, and how we apply this class of models to basketball data. We used a small sample of historical NBA player tracking data (see https://github.com/sealneaward/nba-movement-data for the raw data).
The workflow is separated into three parts (or model types):

Example HMM
Tagging a Drive Event
Defensive Assignment

An outline of the project directory is provided below.

hmm_example_fit.R

Simple HMM with 2 states and 1 output


hmm_example_bad_fit.R

Above model without enforced ordering of parameters


drive_0.R

Drive HMM with exponential likelihood


drive_1.R

Drive HMM with normal likelihood


defense_0a.R

Defensive assignment HMM example with fixed convex combination parameters


defense_0b.R

Defensive assignment HMM example with estimated convex combination parameters


defense_1_low_res.R

Defensive assignment HMM on player tracking data with estimated convex combination parameters


defense_2_low_res.R

Defensive assignment HMM on player tracking data with fixed convex combination parameters


graphics.R

Functions for plotting court/players/etc


data/

Data scripts and data files


doc/

Documentation


media/

Video clips and plots of model output


models/

Stan models


results/

Stan model fits





",R
83,"











Kawhi : stats.NBA.com library 🏀
Jump Ball





README.md




Kawhi : stats.NBA.com library 🏀

 
A Haskell library for working with NBA Stats data. NBA Stats contains rich data, but accessing it is difficult and tedious. Kawhi helps to automate the data retrieval, allowing users to focus on statistics.
It's named after Kawhi Leonard.
Jump Ball
To get started:

Get Haskell. If you've never done any computer programming, this could be challenging. Never give up!
Read the guide.
Check out the example.



",Haskell
84,"



README.md




boxscorereplay.com
This is the source code for boxscorereplay.com, a dynamic, replayable box score for the NBA. It's not very good, but apparently people love the product.


",Ruby
85,"



README.md




Yahoo Fantasy Basketball Analyzer


Description

Average stats and Z-scores for teams in your Yahoo Fantasy Basketball league.
Average stats and Z-scores for NBA players.
Trade Analyzer for your Yahoo Fantasy Basketball league.



Requires

python3.7



Installation
git clone https://github.com/elwan9880/Yahoo_fantasy_basketball_analyzer.git
cd Yahoo_fantasy_basketball_analyzer
python setup.py install



How to use

Create oauth2.json (https://yahoo-fantasy-api.readthedocs.io/en/latest/authentication.html).

Apply Yahoo API key (https://developer.yahoo.com/apps/create/). Select all read/write permission. It will give you consumer_key and consumer_secret.
Create oauth.json under the same directory with yahoo_fantasy_basketball_analyzer.py with your api key:
{""consumer_key"": <your consumer_key>, ""consumer_secret"": <your consumer_secret>}




Run the script: python yahoo_fantasy_basketball_analyzer.py.

It will pop a web browser window with your verifier. Enter the verifier in terminal.
Enter the year and the league_id you would like to reference.


Choose the mode for analysis:

Fantasy Team Performance Analyzer: Create <season>_<league_name>_teams.csv: Team performance with average stats and z-scores in your league
Fantasy Trade Analyzer: create <season>_<league_name>_<team_A>_<team_B>.csv: Trade Analysis
NBA Players Performance Analyzer: create <season>_players.csv: Players performance with average stats and z-scores


Import CSV files to google sheet or excel as CSV format (comma separated) to see the results.



Example:
Chun-Tses-MacBook-Pro:Yahoo_fantasy_basketball_analyzer cshao$ python3 yahoo_fantasy_basketball_analyzer.py
? Please choose a mode:  NBA Players Performance Analyzer
? And a NBA season:  2018-2019
? Select categories for analysis (default 9CAT):  done (9 selections)
Parsing Basketball Reference NBA players total stats ... Done
Calculating player performace ... Done
Finished! please import ""2018-2019_players.csv"" to excel as CSV format to see the results.





",Python
86,"














NBA REST API

Open Source REST API for the best league in the world!


    We are not affiliated, associated, authorized, endorsed by, or in any way officially connected with NBA, or any of its subsidiaries or its affiliates. The names NBA as well as related names, marks, emblems and images are registered trademarks of their respective owners.
  
Documentation
Players
Get All Players
HTTP Request:
Query parameters
Post Player
HTTP Request
Body example
Headers
Delete Player
HTTP Request
URL Parameters
Headers
Teams
Get All Teams
HTTP Request
Get Specific Team
HTTP Request
URL Parameters





README.md





NBA REST API

Open Source REST API for the best league in the world!








    We are not affiliated, associated, authorized, endorsed by, or in any way officially connected with NBA, or any of its subsidiaries or its affiliates. The names NBA as well as related names, marks, emblems and images are registered trademarks of their respective owners.
  




Technologies used in this project: 











Documentation



Players
Get All Players
This endpoint retrieves all players from all seasons.


HTTP Request:


GET https://klqn0hf9bk.execute-api.us-east-1.amazonaws.com/prod/v1/players


Query parameters





Parameter
Default
Description




page
1
The page number used for pagination


limit
20
the number of results returned per call, used for pagination. Max 100


search

Used to filter players based on their name. For example, ?search=davis will return players that have 'davis' in their first or last name.



Post Player
This endpoint let´s you post a new player (for example to upload a new draft class) - You need a special API-KEY to do this.


HTTP Request


POST https://klqn0hf9bk.execute-api.us-east-1.amazonaws.com/prod/v1/players


Body example





Headers


x-api-key: secretValue
Delete Player
This endpoint let's you delete a player (for example a player retires) - You need a special API-KEY to do this.


HTTP Request


DELETE https://klqn0hf9bk.execute-api.us-east-1.amazonaws.com/prod/v1/players/<ID>


URL Parameters





Parameter
Description




ID
ID of the player to Delete





Headers


x-api-key: secretValue
Teams
Get All Teams
This endpoint retrieves all teams for the current season.


HTTP Request


GET https://klqn0hf9bk.execute-api.us-east-1.amazonaws.com/prod/v1/teams
Get Specific Team


HTTP Request


GET https://klqn0hf9bk.execute-api.us-east-1.amazonaws.com/prod/v1/teams/<ID>


URL Parameters





Parameter
Description




ID
ID of the team to retrieve





",JavaScript
87,"











Euroleague-ML
Required Dependencies
Other Interesting Links and Resources





README.md




Euroleague-ML
The aim of this repository is to publish several Python Notebooks to see how Machine Learning (ML) can be applied to basketball-based European Datasets. Although the given examples are quite simple (build-in scikit-learn functions), I expect these models to provide coaches/analysts/GM's with concrete baseline examples.
In particular, at the moment (January 12th 2020), three tutorials about ML gold-standards have been included:

Clustering, where K-Means is used to group similar types of shooters based on shotchart-based features.
Classification, where SVM is used to build a model able to classify player positions.
Regression, where linear models are used in order to predict several statistics, as well as suggesting potentially interesting players for a given lineup.

I really hope you find it useful. If you have any questions / suggestions, feel free to send me an email (adria.arbues@upf.edu) or a Twitter DM (@arbues6).
Big shoutout also to Nacho Gámez (@ngamezj), who provided me with a notable dataset to get started.
Required Dependencies
All code has been written in Python (3.7); the following libraries should be installed (all of the are included in pip3):
pip3 install numpy
pip3 install opencv-python
pip3 install pandas
pip3 install matplotlib
pip3 install scikit-learn

Other Interesting Links and Resources

Andrew Patton's Repository ""Basic NBA Tutorials"": https://github.com/anpatton/basic-nba-tutorials
Talk ""Beyond the 4 Factors"" with Seth Partnow, Todd Whitehead and Justin Jacobs: https://www.youtube.com/watch?v=DKv-1n5OHEc&&ab_channel=Adri%C3%A0Arbu%C3%A9s
Some non-technical deep Euroleague reports: https://medium.com/@adria.arbues



",Python
88,"











ncaa-basketball
Maintainer
Special Credits
License





README.md




ncaa-basketball

R Code + R Notebook on how to process and visualize NCAA basketball data.
This repository is the complement to my blog post Visualizing One Million NCAA Basketball Shots.
Maintainer
Max Woolf (@minimaxir)
Max's open-source projects are supported by his Patreon. If you found this project helpful, any monetary contributions to the Patreon are appreciated and will be put to good creative use.
Special Credits
Ewen Gallic, for his implementation of a basketball court in ggplot2, which saved me a lot of time.
License
MIT


",R
89,"











PLAY BY PLAY AND BOX SCORE SCRAPING LIBRARY
Requirements
Instructions





README.md




PLAY BY PLAY AND BOX SCORE SCRAPING LIBRARY
Requirements
This library was created on a Mac, so the setup instructions are geared toward a *nix environment (sorry Windows users)

Python 2.5 or greater
BeautifulSoup4 (pip install beautifulsoup4)
lxml (used within BeautifulSoup) (pip install lxml)

Instructions

Clone the repository to your local machine (change your_folder_path to whatever folder you want to put the repo)

cd your_folder_path
git clone git@github.com:kpascual/basketball-data-scraper.git


Add this new directory to your PYTHONPATH in ~/.bash_profile

PYTHONPATH=""/your_folder_path/basketball-data-scraper:$PYTHONPATH""
export PYTHONPATH


Run the build.sh script

sh build.sh database_username database_password database_name

To actually do scraping, run the scrape.py file. You will be asked what league you want to run.
python scrape.py



",PLpgSQL
90,"














MASK R-CNN  sport actions fine tuning
Aims of this repo
Dataset
but:
Getting Started
Results
Requirements
MS COCO Requirements:
Installation





README.md




MASK R-CNN  sport actions fine tuning
Mask R-CNN is a powerful framework developed by facebook (here more), main features are:

General and flexible for object instance segmentation
Part of Detectron, a state-of-the-art object detection algorithm collection
Powered in python and natively Coffe2
Also available a Keras + TensorFlow version (here you can find all the requirements)

Aims of this repo
Address the network towards Sport activities detection using fine tuning technique.
We want that the new will be able to detect only main subjects labelled as activity name (i.e. only people)

Dataset
Dataset used is ucf24 (subset of ucf101): a set for Action Recognition that consists of 3194 videos from 4 kind of action. Resolution of each video is 320x240 px.
We intending to work frame-by-frame, and also need an annotated groundtruth:
A frame annotated version of this dataset it's available from this repo by Gurkit
but:
Not whole dataset is annotated, only “frame of interest”: this produces the 70% of useless data.
Only bboxes groundtruth is available and no masks are annotated: so we produced a mask gt by ourselves.

Getting Started
Here we propose a bief explenation of the files and their usages (we strongly refer to ucf24 dataset above mentioned!):
Coco weights used are available here

actionCLSS_config.py: extends and override net configuration.
actionCLSS_dataset.py and actionCLSS_dataset_partitioned.py: offers two dataset classes: the first can be instantiated specifying the number of samples which compose it, the second read the samples from testList.txt and validationList.txt.
actionCLSS_training.py: obviouslly, is the routine that manage the train.
evaluation.py : evaluate the model on the whole testSet and iteratively save local results.
printPR.py: use results produced by evaluation.py to compute Precision and Recall for each class.
createMasks.py: produce person masks for each frame of the dataset, like exposed below.


Results
A brief argue can be over the divergence between a quantitative and a qualitative analysis on the maks and bb produced.
Below an example is showed: predictedion surclass the groundtruth, but numerically this means a penalization!


mAP without considering masks:  84.5%
mAP considering masks IoU=25: 37.4%
mAP considering masks IoU=50:  28.7%




Class
No Mask
IoU = 25
IoU = 50




WalkingWithDog
85.8%
57.2%
48.9%


BasketballDunk
62.1%
1.7%
0.2%


Biking
92.4%
38.3%
27.5%


CliffDiving
22.7%
3.2%
0.0%


CricketBowling
47.2%
3.8%
2.7%


Diving
83.0%
2.3%
1.4%


Fencing
97.9%
19.5%
14.0%


FloorGymnastics
64.8%
34.0%
28.5%


GolfSwing
81.0%
71.8%
67.6%


HorseRiding
95.3%
27.7%
16.2%


IceDancing
93.7%
68.8%
64.3%


LongJump
59.9%
25.1%
22.1%


PoleVault
54.7%
2.6%
1.6%


RopeClimbing
90.6%
30.8%
20.5%


SalsaSpin
86.4%
48.5%
22.7%


SkateBoarding
86.7%
46.9%
34.2%


Skiing
80.7%
46.3%
37.2%


Skijet
87.8%
21.9%
13.0%


SoccerJuggling
85.8%
58.3%
52.8%


Surfing
78.2%
18.1%
12.7%


TennisSwing
64.9%
59.3%
56.1%


TrampolineJumping
83.5%
16.3%
13.8%


VolleyballSpiking
39.5%
0.7%
0.3%



Requirements
Python 3.4, TensorFlow 1.3, Keras 2.0.8 and other common packages listed in requirements.txt.
MS COCO Requirements:
To train or test on MS COCO, you'll also need:

pycocotools (installation instructions below)
MS COCO Dataset
Download the 5K minival
and the 35K validation-minus-minival
subsets. More details in the original Faster R-CNN implementation.

If you use Docker, the code has been verified to work on
this Docker container.
Installation


Install dependencies
pip3 install -r requirements.txt


Clone this repository


Run setup from the repository root directory
python3 setup.py install


Download pre-trained COCO weights (mask_rcnn_coco.h5) from the releases page.


(Optional) To train or test on MS COCO install pycocotools from one of these repos. They are forks of the original pycocotools with fixes for Python3 and Windows (the official repo doesn't seem to be active anymore).

Linux: https://github.com/waleedka/coco
Windows: https://github.com/philferriere/cocoapi.
You must have the Visual C++ 2015 build tools on your path (see the repo for additional details)





",Python
91,"



README.md




Repository for dsscollection submission ""Modeling Offensive Player Movement in Professional Basketball"" by Steven Wu and Luke Bornn.
Below are descriptions of the subdirectories of this repo:

analysis: contains all code and materials required to create the PDF of the paper submission. To create the PDF, you will need knitr, dplyr, ggplot2, raster, grid, gridExtra installed. Then, either (1) open 'article.Rnw' in RStudio and click 'File -> Preview' or (2) open up a Terminal and type


Rscript -e ""library(knitr); knit('./EPV_demo.Rnw')"".


data: contains .Rdata files of intermediate data that is helpful for testing changes to the implementation of functions
plots: contains static plots that the article uses, namely plots that were generated over a season's worth of data

We would like to acknowledge STATS, LLC for consenting the inclusion of a full-game data sample.


",R
92,"














sport an R package for Online Ranking Methods
sport 
About
Package Usage
Installation
Available Data
Estimate dynamic ratings
Output





README.md




sport an R package for Online Ranking Methods
sport 





About
Name sport is an abbreviation for Sequential Pairwise Online Rating
Techniques. Package contains functions calculating ratings for
two-player or multi-player matchups. Methods included in package are
able to estimate ratings (players strengths) and their evolution in
time, also able to predict output of challenge. Algorithms are based on
Bayesian Approximation Method, and they don’t involve any matrix
inversions nor likelihood estimation. sport incorporates methods such
glicko, glicko2, bayesian Bradley-Terry, dynamic logistic regression.
Parameters are updated sequentially, and computation doesn’t require any
additional RAM to make estimation feasible. Additionally, base of the
package is written in C++ what makes sport computation even faster.
Package Usage
Installation
Install package from CRAN or development version from github.
devtools::install_github(""gogonzo/sport"")
install.packages(""sport"",repos = ""https://cloud.r-project.org/"")
Available Data
Package contains actual data from Speedway Grand-Prix. There are two
data.frames:

gpheats - results SGP heats. Column rank is a numeric version of
column position - rider position in race.
gpsquads - summarized results of the events, with sum of point and
final position.

library(sport) 
str(gpheats)
#> 'data.frame':    21932 obs. of  11 variables:
#>  $ id      : num  1 1 1 1 2 2 2 2 3 3 ...
#>  $ season  : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
#>  $ date    : POSIXct, format: ""1995-05-20 19:00:00"" ""1995-05-20 19:00:00"" ...
#>  $ round   : int  1 1 1 1 1 1 1 1 1 1 ...
#>  $ name    : chr  ""Speedway Grand Prix of Poland"" ""Speedway Grand Prix of Poland"" ""Speedway Grand Prix of Poland"" ""Speedway Grand Prix of Poland"" ...
#>  $ heat    : int  1 1 1 1 2 2 2 2 3 3 ...
#>  $ field   : int  1 2 3 4 1 2 3 4 1 2 ...
#>  $ rider   : chr  ""Tomasz GOLLOB"" ""Gary HAVELOCK"" ""Chris LOUIS"" ""Tony RICKARDSSON"" ...
#>  $ points  : int  2 0 3 1 3 0 1 2 0 2 ...
#>  $ position: chr  ""2"" ""4"" ""1"" ""3"" ...
#>  $ rank    : num  2 4 1 3 1 4 3 2 4 2 ...
Data used in sport package must be in so called long format. Typically
data.frame contains at least id, name and rank, with one row for
one player within specific match. Package allows for any number of
players within event and allows ties also. For all games, output needs
to be a rank/position in event. Don’t mix up rank output with typical
1-win, 0-lost. In sport package output for two player game is 1-winner
2-looser. Below example of two matches with 4 players each.
#>   id             rider rank
#> 1  1     Tomasz GOLLOB    2
#> 2  1     Gary HAVELOCK    4
#> 3  1       Chris LOUIS    1
#> 4  1  Tony RICKARDSSON    3
#> 5  2     Sam ERMOLENKO    1
#> 6  2    Jan STAECHMANN    4
#> 7  2     Tommy KNUDSEN    3
#> 8  2 Henrik GUSTAFSSON    2

Estimate dynamic ratings
To compute ratings using each algorithms one has to specify formula.
Form rank | id ~ name is required, which estimates name - rating of
a player, by observing outputs - rank, nested within particular event

id. Variable names in formula are unrestricted, but model structure
remains the same. All methods are named method_run. formula = rank|id ~ name

glicko  <- glicko_run(formula = rank|id ~ player(rider), data = gpheats)
glicko2 <- glicko2_run(formula = rank|id ~ player(rider), data = gpheats)
bbt     <- bbt_run(formula = rank|id ~ player(rider), data = gpheats)
dbl     <- dbl_run(formula = rank|id ~ player(rider), data = gpheats)

print(dbl)
#> 
#> Call: rank | id ~ player(rider)
#> 
#> Number of unique pairs: 33003
#> 
#> Accuracy of the model: 0.61
#> 
#> True probabilities and Accuracy in predicted intervals:
#>      Interval Model probability True probability Accuracy     n
#>  1:   [0,0.1]             0.075            0.211    0.788   562
#>  2: (0.1,0.2]             0.156            0.258    0.741  2229
#>  3: (0.2,0.3]             0.258            0.316    0.683  5246
#>  4: (0.3,0.4]             0.354            0.379    0.619 10887
#>  5: (0.4,0.5]             0.451            0.460    0.539 14122
#>  6: (0.5,0.6]             0.549            0.540    0.539 14036
#>  7: (0.6,0.7]             0.646            0.621    0.619 10887
#>  8: (0.7,0.8]             0.742            0.684    0.683  5246
#>  9: (0.8,0.9]             0.844            0.742    0.741  2229
#> 10:   (0.9,1]             0.925            0.789    0.788   562
Output
Objects returned by method_run are of class rating and have their
own print summary which provides most important informations.
-print.sport shows condensed informations about model performance like
accuracy and consistency of model predictions with observed
probabilities. More profound summary are given by summary by showing
ratings, ratings deviations and comparing model win probabilities with
observed.
summary(dbl)
#> $formula
#> rank | id ~ player(rider)
#> 
#> $method
#> [1] ""dbl""
#> 
#> $`Overall Accuracy`
#> [1] 0.6062934
#> 
#> $`Number of pairs`
#> [1] 66006
#> 
#> $r
#>                            rider      r    rd
#>   1:         rider=Tomasz GOLLOB  0.965 0.002
#>   2:         rider=Gary HAVELOCK  0.865 0.116
#>   3:           rider=Chris LOUIS  0.351 0.009
#>   4:      rider=Tony RICKARDSSON  1.516 0.004
#>   5:         rider=Sam ERMOLENKO  0.479 0.037
#>  ---                                         
#> 213:        rider=Szymon WOŹNIAK  0.173 0.774
#> 214:        rider=Kevin WOELBERT  0.318 0.815
#> 215: rider=Igor KOPEĆ-SOBCZYŃSKI -0.377 0.950
#> 216:          rider=Zdenek HOLUB -0.409 0.950
#> 217:        rider=Charles WRIGHT -0.655 0.774
To visualize top n ratings with their 95% confidence interval one can
use dedicated plot.rating function. For DBL method top coefficients
are presented not necessarily ratings. It’s also possible to examine
ratings evolution in time, by specifying players argument.
plot(glicko, n = 15)
plot(glicko, 
     players = c(""Greg HANCOCK"",""Tomasz GOLLOB"",""Tony RICKARDSSON""))

Except dedicated print,summary and plot there is possibility to
extract more detailed information to be analyzed. rating object
contains following elements:
names(glicko)
#> [1] ""final_r""  ""final_rd"" ""r""        ""pairs""

rating$final_r and rating$final_rd contains ratings and ratings
deviations estimations.
r contains data.frame with sequential ratings estimations from
first event to the last. Number of rows in r equals number of rows
in input data.
pairs pairwise combinations of players in analyzed events with
prior probability and result of a challenge.

tail(glicko$r)
#>      id                  rider        r        rd
#> 1: 5476       Fredrik LINDGREN 1595.713  7.815778
#> 2: 5476          Tai WOFFINDEN 1675.975  9.294484
#> 3: 5477            Leon MADSEN 1640.216 21.792118
#> 4: 5477       Bartosz ZMARZLIK 1698.159 12.272463
#> 5: 5477 Niels Kristian IVERSEN 1580.907  9.192937
#> 6: 5477       Emil SAJFUTDINOW 1666.851  9.764087
tail(glicko$pairs)
#>      id                  rider               opponent Y         P
#> 1: 5477 Niels Kristian IVERSEN            Leon MADSEN 0 0.4156996
#> 2: 5477 Niels Kristian IVERSEN       Bartosz ZMARZLIK 1 0.3375662
#> 3: 5477 Niels Kristian IVERSEN       Emil SAJFUTDINOW 0 0.3788837
#> 4: 5477       Emil SAJFUTDINOW            Leon MADSEN 0 0.5381477
#> 5: 5477       Emil SAJFUTDINOW       Bartosz ZMARZLIK 1 0.4551217
#> 6: 5477       Emil SAJFUTDINOW Niels Kristian IVERSEN 1 0.6211163


",R
93,"














Basketball GM 4.0.0
Development Info
License and Contributor License Agreement
Step 1 - Installing
Step 2 - Building
Step 3 - Running
1. Node.js (easiest)
2. Apache
Step 4 - Testing
Code Overview
Git Workflow
Less Important Development Info
Bootstrap
Basketball stuff
Cordova
Thank you BrowserStack





README.md




Basketball GM 4.0.0
A single-player basketball simulation game. Make trades, set rosters, draft
players, and try to build the next dynasty, all from within your web browser.
The game is implemented entirely in client-side JavaScript, backed by IndexedDB.
Copyright (C) Jeremy Scheff. All rights reserved.

Email: commissioner@basketball-gm.com
Website: https://basketball-gm.com/
Development: https://github.com/dumbmatter/basketball-gm
Discussion: http://www.reddit.com/r/BasketballGM/

Basketball GM is NOT open source, but it is also not completely closed. Please
see LICENSE.md for details.
Development Info
If you just want to play the game, go to http://basketball-gm.com/.
Instructions below are for developers who want to run a copy locally so they can
make changes to the code.
If you want to contribute but get stuck somewhere, please contact me! I'm happy
to help.
License and Contributor License Agreement
Basketball GM is NOT open source, but it is also not completely closed. Please
see LICENSE.md for details.
If you want to contribute code to Basketball GM, you must sign a contributor
license agreement. There are separate forms for individuals and entities (such
as corporations):

Individual CLA (this is probably what you want)
Entity CLA

Make a copy of the form, fill in your information at the bottom, and send an
email to commissioner@basketball-gm.com with the subject line, ""Contributor
License Agreement from YOUR_NAME_HERE (GITHUB_USERNAME_HERE)"".
Step 1 - Installing
First, make sure you're using Node.js v6 or higher, older
versions probably won't work. Then, all of the tooling used in development can
be set up by simply installing npm and running
npm install

from within this folder.
Step 2 - Building
Basketball GM uses Browserify for JS minification and clean-css for
CSS minification. To build the app along with all its assets, run
npm run build

However during development, you probably would rather do
npm run start-watch

which will start the server and watch JS and CSS files for changes and
recompile. This simply runs both npm start and npm run watch together, which
alternatively can be run separately if you wish.
Open package.json to see all available scripts.
Step 3 - Running
To run the game locally, you need some way of running a web server to display
the content. There are currently two ways to do it. It doesn't matter which
you use as long as you can get it to run on your computer.
1. Node.js (easiest)
Run
npm start

and point your browser to http://localhost:3000/. If you use the command
npm run start-watch from above, then running the command npm start is not
necessary.
2. Apache
The mod_rewrite rules in .htaccess can be used to make Apache run Basketball
GM. Everything should work if you point it at the build folder with
mod_rewrite enabled. That's how it's done on play.basketball-gm.com.
Step 4 - Testing
ESLint, Flow, and, stylelint are used to enforce some coding standards. To run
them on the entire codebase, run
npm run lint

Integration and unit tests are bunched together in the js/test folder.
Coverage is not great. They can be run from the command line in Karma with
npm test

or
npm run test-watch

or manually within a web browser by running npm run build-test (or
npm run watch-test) and going to http://localhost:3000/test (this might be
broken currently).
Code Overview
Basketball GM is a single-page app that runs almost entirely client-side by
storing data in IndexedDB. The core of the game runs inside a Shared Worker (or
a Web Worker in crappy browsers that don't support Shared Workers), and then
each open tab runs only UI code that talks to the worker. The UI code is in the
src/js/ui folder and the core game code is in the src/js/worker folder. They
communicate through the toUI and toWorker functions.
The UI is built with React and Bootstrap.
In the worker, data is ultimately stored in IndexedDB, but for performance and
cross-browser compatibility reasons, a cache (implemented in
src/js/worker/db/Cache.js) sits on top of the database containing all commonly
accessed data. The idea is that IndexedDB should only be accessed for uncommon
situations, like viewing stats from past seasons. For simulating games and
viewing current data, only the cache should be necessary.
The cache is overly complicated because (1) the values it returns are mutable,
so you better not mess with them accidentally, and (2) when you do purposely
mutate a value (like updating a player's stats), you need to remember to always
write it back to the cache manually by calling idb.cache.*.put.
Also in the worker, there is a global variable self.bbgm which gives you
access to many of the internal functions of Basketball GM from within your
browser.
Git Workflow
If you want to contribute changes back to the project, first create a fork on
GitHub. Then make your changes in a new branch. Confirm that the tests
(hopefully including new ones you wrote!) and ESLint all pass. Finally, send me
a pull request.
It's also probably a good idea to create an issue on
GitHub before you start
working on something to keep me in the loop.
Less Important Development Info
Bootstrap
Basketball GM's layout is currently based on Bootstrap 3.1.1 with the following
options:

@font-size-base set to 13px

Basketball stuff
Abbreviations of stats should be done like basketball-reference.com stat pages.
For instance, ""defensive rebounds"" is ""drb"".
Cordova
The game runs equally well within a web browser and within Cordova (Android
4.4+). The codebase is designed to handle both situations (the main difference
is absolute vs relative paths, governed by window.inCordova in index.html).
Warning: This hasn't been tested in a while and is probably broken by now.
Thank you BrowserStack
Shout out to BrowserStack for helping with
cross-browser testing.


",JavaScript
94,"














SportSett:Basketball
Denormalized Tables
Quick Start
Dimensions
Playoff / Preseason Games
A Note on Generated Files
This is a work in progress
UML DIagram





README.md




SportSett:Basketball
This resource is designed to allow for research into Natural Language Generation.  In particular, with neural data-to-text approaches although it is not limited to these.  This page will be updated with more detail, as soon as I have time and am able to post examples of other work I am doing with this.  For the moment, see our IntelLanG2020 paper SportSett:Basketball - A robust and maintainabledataset for Natural Language Generation.
Denormalized Tables
To make things easier for people, I have uploaded on Google Drive a SQL script which will add some denormalized tables created from the core tables.  This provides things like:

Per player/team on game/period statistics, with each player/time-period on one row.
The same, except for some name information about each row.

On the statistics tables, each stat has a count, then also a ""_double"" column, which is one if it is ""double digits"", zero otherwise.  There are also columns at the end for whether the player had a ""double-double"" or ""triple-double"" etc.  These columns are included for teams, and per-period data as well, even though it does not always make sense to use it that way.
These have not been thoroughly tested yet, and I will at some point release the SQL scripts I used to make these tables.  I know the underlying table structure can seem daunting/obtuse.  It has been designed to allow for multiple sports and leagues whilst maintaining a high level of normalization.  It is like this, because I find it easier to work with, although I acknowledge that not everyone does.  For NLG research I am looking at simpler ways this data can be made available, and these 8 new tables are a first step in that direction.  You should be bale to just run the sql file with the psql command and write these tables atop your existing database.
Quick Start
You will need a working PostgreSQL installation, as well as a working Ruby environment if you want to use the ORM.  I suggest using RVM, you will also need Bundler.  The ORM are written in Ruby Sequel rather than ActiveRecord.  Whilst this is all in a Rails app, there is no front-end implemented, it is just a convenient way for me to create scripts using rake tasks.  Note that this resource is not meant to be efficient.  If you require high data throughput for some reason, you can use the raw SQL.  The Ruby code is meant to provide a simple way to write scripts to export data, this might take an hour or two to run but it is simple to code and the training of models takes way longer than that anyway, so I find it to be acceptable.
You will need to set the password etc in config/database.yml
development:
	adapter: postgresql
	database: sport_sett_development
	user: postgres # Also accept 'username' as key, if both are present 'username' is used
	password: postgrespassword
	host: 127.0.0.1 # Optional
	port: 5432 # Optional


ATTENTION!
The original SQL file contained a but where the team_in_games.winner column was often wrong.  This was a convenience column, the scores appear to all be correct.  The file has now been updated, using the score fields to derive then correct the winner column.
Then navigate to root directory of repo, download database archive file, and ensure you have the correct ruby environment set (if using something like RVM).  Large files can be found in Google Drive.
bundle install
tar -xvjpf db_after_statistics_2018.sql.tar.bz2
psql -U postgres -d sport_sett_development < db_after_statistics_2018.sql

You can now generate output files in the format required for the system of Rebuffel et al..  This takes about 1 hour to run.  The result of the below command has been uploaded to Google Drive if you just want the OpenNMT training data without changing anything.
rake export:rebuffel

This will place several files in the ./exported_files directory.  In order to create the partitions from these files as per our paper you need to combine the yearly files.  The yearly files contain data for just one season.
cd ./exported_files
cat D1_2014_data.txt D1_2015_data.txt D1_2016_data.txt > D1_training_data.txt
cat D1_2014_text.txt D1_2015_text.txt D1_2016_text.txt > D1_training_text.txt
cp D1_2017_data.txt D1_valid_data.txt
cp D1_2017_text.txt D1_valid_text.txt
cp D1_2018_data.txt D1_test_data.txt
cp D1_2018_text.txt D1_test_text.txt

or run
sh combine.sh

You can of course combine these in other ways.  This is just the partition scheme we used in our paper.
Dimensions
Please see app/models/rebuffel_open_nmt_record.rb for code which creates this data.  If you wanted to change the data for each input sample, this is where you would do it, either by editing this file or creating your own similar class which is used in the rake script.
Notice how the class names follow the dimensions highlighted in our paper.  The UML diagram shows these relationships.
WARNING:  There are some issues with the play-by-play statistics.  Sometimes, they do not line up with what is reported in the box score.  I am working on scripts to automatically resolve these, although early investigation suggests there is only about 1 mistake every other game.  A mistake is commonly just one basket being attributed to the wrong player.  You can use the play-by-play, there is a lot of data there, but there are discrepancies.  Given this is such a large dataset, with original data entry likely by humans, it will not be 100% perfect.  My current plan for this is to take the game data, game period data, and play-by-play, then resolve discrepancies automatically where 2/3 of the sources agree on a correct answer, and the error can be resolved a net-zero effect (same team totals, points etc).
Playoff / Preseason Games
Whilst some of these games are in the original Rotowire dataset, they are not yet included here.  The database is designed in such a way that they can be added later.  There are several reasons for not including them yet.  Firstly, it takes time to import this stuff.  Secondly, just doing regular season games makes the machine learning problem simpler (and it is still very, very difficult).  Finally, preseason games are played in all kinds of places, even against teams from different leagues.
A Note on Generated Files
Some functions in Ruby such as sort_by are not deterministic beyond their given arguments.  This means that items which are of equal value when sorted are not always presented in the same order (just together).  The code has also been changed slightly to make it simpler (it used to be several different functions doing similar things).  I only mention this here so you know that the dataset generated is not the exact one used in the paper.  This is no bad thing, running on the exact same dataset over and over again is a bad idea.
This is a work in progress
This is code from an academic research project, trying to get us closer to a sensible data solution in this domain.  It is not finished, it is not a commercial product.  I am happy to answer questions if you are doing research, but please have reasonable expectations.
UML DIagram
Some attributes are missing for this and it needs a general update and tidy, but it is mostly right.  You can find all attributes by looking at the SQL tables.  Rails Sequel naming conventions have been followed.



",Ruby
95,"














Artificial Curiosity
Adaptive Reinforcement Learning of curious AI basketball agents
Part 1 - Bayesian Inference and Information Gain
Part 2 - Neural Network Learning and Optimization
Extra:
Part 3 - Curiosity Loop with Adaptive Reinforcement Learning
The Curiosity Loop:
Project Presentation:
More Links:





README.md




Artificial Curiosity
Adaptive Reinforcement Learning of curious AI basketball agents

A machine learning project of learning NBA shots success ratio based on  410,000 records of NBA players shots stats.
The project implements various ML techniques in order to create a ""Curious"" AI agent, which learns success ratios and implements the knowledge in exploration-exploitaition game simulation enviroment.
Part 1 - Bayesian Inference and Information Gain
After an EDA stage and preprocessing of shots data into categorical features we implemented a bayesian inference algorithm and evaluated the feature selection with Expected Information Gain criteria.
Part 2 - Neural Network Learning and Optimization
Manual Neural Network implementation with numpy and SGD method. This part required new preprocess methods (to continuous features) and network structure optimization by improving prediction AUC to 70%.
Extra:


Genetic algorithm optimization
Implementation of a genetic algorithm for network structure optimization.


Random Forest, SVM and PCA methods
Benchmarks methods for accuracy estimation and feature selection.


Part 3 - Curiosity Loop with Adaptive Reinforcement Learning
Implementaion of a Curosity Loop, using Actor-Critic Method and Bayesian Inference.
The Curiosity Loop:

A ""new-born"" AI agent takes shots from different positions and learns the success of each shot, while trying to both learn the environment and score as much as possible.
Project Presentation:
Link to project presentation (pdf)

More Links:

Big Data Lab @ TAU
Curiosity Lab @ TAU



",Python
96,"











BasketballRecLeague
About
Tech
How To
Website





README.md




BasketballRecLeague
About
The purpose of this project is to demonstrate a combination of programming strategies we've learned over the duration of the bootcamp. The app will be basketball themed, and it will display a list of leagues, teams, and members registered with the site. Users will also be able to register, edit, and delete new teams or members.
Tech
The webpage will be written in HTML, CSS, and JavaScript. Additionally, the page will utilize a server file to dynamically pull data from a local JSON file.
How To
To launch the server, navigate to the parent folder BasketballRecLeague in your file directory. Drag that folder into your command line and change to that directory. Once there, perform a 'node server.js' to initialize the webserver. Then, enter 'http://localhost:8081/' in your browser's address bar.
Website



",JavaScript
97,"



README.md




nba-start-active-players-bot
What
Python Selenium script that logs into your Yahoo fantasy basketball account and starts active players for today and upcoming days. Accepts arguments username, password, the number of days you would like the bot to process into the future and whether you want to see what the browser is running (useful for debugging) or run in headless mode.
Why

Never leave a player on the bench because you forgot to set your lineup
Why not

Dependencies

Python 2.7
Click
Selenium WebDriver
ChromeDriver
PhantomJS

How

Download script
Install dependencies

pip install selenium click 
brew install node
curl https://www.npmjs.org/install.sh | sh
npm install phantomjs
You'll have to grab ChromeDriver manually.

Run the program

To run the program
python start-active-players.py
You will be prompted to enter the number of days you want the script to process, your Yahoo credentials and whether you want the script to run in headless mode (you can't watch what it's doing in the browser).
You can include these details as options to avoid having to fill them in each time. For example to start active players for the next week including today.
python start-active-players.py --days=7 --username=YahooUsername@yahoo.com.au --password=Y0urYah00Passw0rd --headless=False
use --help for help documentation.
To-Do

 Try / Except for missing command line argv.
 Add headless support for PhantomJS
 Try / Excepts for key UI elements to ensure Selenium can find them before we click them.
 Put more asserts in places to tighten it all up
 Include confirmations for each date as they are processed

Contribute
If you think this is a cool idea, but kind of inefficient, please submit a PR and let's make this better.
© 2015, Devin Mancuso · MIT License you know the deal


",Python
98,"











Shoot For Teams
Description
Install
Usage
License
Contribute





README.md




Shoot For Teams
App designed to find nearby basketball courts for pick-up games. Starting off as an Austin-based project with plans for expansion to other areas as development continues.
Description
Shoot For Teams is designed to take the hassle out of finding nearby basketball courts. With user-generated information about courts, you get a much more detailed experience than traditional search sites. We make it easy to find the place so you can get out and play.
Install
When accessing the page with your Android smartphone, you may select the ""Add to Home Screen"" button on the Chrome menu to access it as a regular app. For desktop Chrome you may go to Menu and then ""Install Shoot For Teams"" to add it to your desktop. As for iOS support, it is still just starting out, but you may access the site, then go to the menu, then ""Share"", and ""Add to Homescreen"" and you will be good to go.
Usage
Just click on the ""Find a Court"" button, enable location access, and see the courts nearby you. The orange ball represents courts with scheduled games, the black ones represents free courts. Clicking on the ball let you see photos, location, current weather and future games. You may signin or login to be able to submit new court entries and schedule matches.
License
Contribute
I'd love to have your help with this project. The steps here should get you going. If not, make a contribution by updating the docs!


",JavaScript
99,"














PandasBasketball
Installation
Requirements
Usage
🏀 Players
Example
Optional Arguments
Considerations
🏀 Player Game Logs
Example
Optional Arguments
Considerations
🏀 Last n days
Example
Optional arguments
Considerations
🏀 Teams
Example
🏀 Generate player code
Example
Future
Contributions & Known Issues





README.md




PandasBasketball
PandasBasketball is a small module intended to scrape data from basketball-reference and convert it to useful pandas data structures, such as data frames, for future analytical purposes. The use of jupyter notebooks is encouraged.
Installation
pip install PandasBasketball

After installation you can then import it to your environment like this:
from PandasBasketball import pandasbasketball as pb

Requirements
Please make sure you meet the following rquirements:

Python 3.6+
requests
pandas
Beautiful Soup 4

All the requirements can easily be met with the installation of the Anaconda distribution.
Usage
🏀 Players
Inside a player's page on the basketball-reference website you can find several tables, and most of these tables can be obtained as a pandas data frame by calling get_player(player, stat). The 'player' refers to the name of the html file used by basketball-reference inside the url, and the 'stat' means the type of table.
The currently supported tables are:

Per Game (per_game)
Totals (totals)
Per 36 Minutes (per_minute)
Per 100 Poss (per_poss)
Advanced (advanced)
Playoffs Per Game (playoffs_per_game)
Playoffs Totals (playoffs_totals)
Playoffs Per 36 Minutes (playoffs_per_minute)
Playoffs Per 100 Poss (playoffs_per_poss)
Playoffs Advanced (playoffs_advanced)

The rest of the tables will come in the future.
Example
To get the 'Per Game' table for LeBron James you would do something like this:
df = pb.get_player(""jamesle01"", ""per_game"")

Optional Arguments
The get_player() method supports two optional arguments:

numeric - returns the data frame with its columns alreay converted to numeric
s_index - returns the data frame with its column 'Season' as the index

Both are set to False by deault.
Considerations

The resulting data frame does not include the table's footer.
The resulting data frame will have the same column names as the table's header but it will not have a set index. To set the 'Season' column as index set the argument s_index to True.
The columns will be of type 'object', so in order to perform arithmetic functions on them you will need to convert them to numeric. You can do something like this:

lbj_pg = pb.get_player(""jamesle01"", ""per_game"")
lbj_pg[lbj_pg.columns] = lbj_pg[lbj_pg.columns].apply(pd.to_numeric, errors=""ignore"")

Or you cant set the optional argument numeric to True.
🏀 Player Game Logs
You can get all of a player's games in a season by calling get_player_gamelog(player, season). The season argument must be the last year in which the season took place.
Example
To get all of Kawhi Leonard's games during the 2017-2018 season:
df = pb.get_player_gamelog(""leonaka01"", ""2018"")

Optional Arguments
The function get_player_gamelog supports one optional argument:

playoffs - returns only the playoffs games if set to True

Set to False by default.
Considerations

The resulting data frame will use the 'Rk' column as its index
The data frame does not include those rows which are just the header again
If the player missed a game, the row will be filled with blanks ("""")

🏀 Last n days
Get a data frame with all the season's available players stats over the last n days by calling get_n_days(days).
Example
df = pb.get_n_days(10)

Optional arguments
get_n_days supports one optional argument:

player - returns a pandas series with the stats of the specifed player

player is set to all by default.
Considerations

The resulting data frame will have the column 'Players' as its index by default
The data frame is in descending order by GmSc

🏀 Teams
You can call a team's seasons table with get_team(name). The argument name is the team's three-letter abbreviation (e.g. OKC, MAV).
Example
To get OKC's table:
df = pb.get_team(""OKC"")

🏀 Generate player code
Baskteball-reference uses a special code to build each player's unique html page. As of now, almost all functions in PandasBasketball expect that code to get the stats for the specified athlete. If you don't want to copy and paste the code from the URL into the function you can try calling pb.generate_code(player).
Note: this is not fully tested, so it is possible to get an incorrect code.
Example
To get the player code for LeBronJames:
pb.generate_code(""LeBron James"")

This will output 'jamesle01'
Using it with other functions:
df = pb.get_player(pb.generate_code(""Donovan Mitchell""), ""per_game"")

Future

Make this project pip-installable
Add support for the rest of tables on a player's page
Implement function to obtain team stats per season
Implement function to get the last n days stats
Implement function to obtain game results by date

Contributions & Known Issues
If you notice an issue or want to contribute open an issue over at the issues section.


",Python
100,"



README.md




this is a basketball game demo, base on OpenGL for grapic render,
some simple AI technology.
now this is the first version, it is just an framework,
later I will add some funny things.
Programming language: C++
lib file related:
glu, glut, glui.
TODO list:
1 More detailed AI in game, more real than now.
2 Read some parameters from conf file, this is going to be implemented through Lua.
3 User control from keyboard, so user can play with computer.
4 ...
#snapshot



",C++
101,"











2019 FIBA Basketball World Cup
R
Data
TODO
Figures





README.md




2019 FIBA Basketball World Cup
Data from the 18th tournament of the FIBA Basketball World Cup for men's national basketball teams
Spanish translation by Julio Spairani
R
scrape.R: Code for scraping and cleaning rosters
scrape-results.R: Code for scraping and cleaning results
scrape-playerstats.R: Code for scraping and cleaning player stats

height.R: Height distribution
height-dist.R: Height distribution
age-dist.R: Age distribution
shooting-stats.R: First round shooting percentages
teampoints-perc.R: Players with most team points
teampoints-game.R: Team points in all the games before the final
Data
FIBA-WBC19-rosters.csv: Rosters scraped from Wikipedia (accessed 2019-08-31)
FIBA-WBC19-results.csv: Results scraped from Basketball reference (accessed 2019-09-18)
FIBA-WBC19-totalteamstats.csv: Total team statistics saved as csv from Basketball reference (accessed 2019-09-18)
FIBA-WBC19-playerstats.csv: Player statistics saved as csv from Basketball reference (accessed 2019-09-18)
FIBA-WBC19-venues.csv: Venues of the 2019 Tournament
FIBA-WBC19-history.csv: Winners of previous tournaments
TODO
create data dictionary
Figures









",R
102,"











Dunkman
Play Online





README.md




Dunkman
🏀A minigame of slam dunk for TIC-80
Play Online

Compo game for Ludum Dare 46: https://ldjam.com/events/ludum-dare/46/dunkman


",MoonScript
103,"











Hoopr is a place where basketball enthusiasts can find parks and gyms to play the sport they love. Know before you go: Hoopr allows users to write reviews and check if a park or gym meets their needs.
Hoopr: https://hoopr.herokuapp.com/#/
Technologies:
User Authentication:
Reviews:
Search:





README.md





Hoopr is a place where basketball enthusiasts can find parks and gyms to play the sport they love. Know before you go: Hoopr allows users to write reviews and check if a park or gym meets their needs.
Only available in the NYC area.
Hoopr: https://hoopr.herokuapp.com/#/
Technologies:


Ruby on Rails: used to set up Hoopr's backend structure.


PostgreSQL: used to host our database.


Javascript: primary language used for our front-end logic.


jQuery/Ajax: used primarily to make requests to our database.


React/Redux: used to create functional rendering / displays of our data to users.


CSS: used to style HTML elements.


User Authentication:

Implemented a multi-step login process that allows Hoopr users to create profiles securely without having to worry about their personal and sensitive information being leaked. We do this through the encryption of passwords and never storing any of their passwords directly into our database.

Reviews:

Modal that allows users that are logged in to create a review and rate a basketball court. The rating system temporarily sets the state as users choose their rating. The rating then persists and is automatically added to the profile of the basketball court.


render(){
    const basketballs = [];

    for (let i = 1; i <= 5; i++) {
      let klass = 'ball-icon';
      if (this.state.temp_rating >= i && this.state.temp_rating != null) {
          klass += ' is-selected';
      }
      const icon = 
        <img 
          className={klass}
          src={window.ballicon}
          onClick={this.rate(i)}
          key={i}
          onMouseOver={this.ball_over(i)} 
        />;
      basketballs.push(icon);
    }

    const { currentBiz } = this.props;
    if (this.props)
    return(
      <div>
        <div className=""review-form-container"">
          <Link to={`/businesses/${currentBiz.id}`}><h1>{currentBiz.name}</h1></Link>
            <form onSubmit={this.handleSubmit}>
            <section className=""form-wrapper"">
              <div className=""ball-rating modal"">
                  {basketballs}
              </div>
              <label>
                
                <textarea
                  placeholder=""I decided to stop by the park. Perfect opportunity to sweat out last night's tacos and cerveza. The gang was all there shooting hoops. One of the best spots to play pick up in nyc. 4/5 Would come back.""
                  // maxlength=""5000""
                  value={this.state.body}
                  onChange={this.update('body')}
                  className=""review-body""
                  rows=""10""
                  cols=""65"">
                </textarea>
              </label>
            </section>
            <input className=""review-submit"" type=""submit"" value=""Post Review"" />
            </form>
        </div>
Search:

Hoopr's search function allows users to search by borough, neighborhood, or park name. It also displays a map that is relevant to the user's query.




",JavaScript
104,"














""NBA-MyTeam"" Scriptable iOS widget  🏀
Table of Content
Features 💡
Getting started with the widget 🚀
1. Install with ScriptDude
2. Manual Installation
Register for updates 📥
Frequently Asked Questions (FAQs) ❓
Support the project 💪 / Buy me a coffee ☕
Bugs 🐞
References 🏆
Disclaimer





README.md




""NBA-MyTeam"" Scriptable iOS widget  🏀
I created a widget for iOS and the Scriptable.app to always see on the homescreen of my iPhone when the next games are up for my favorite NBA team.
Table of Content

Features 💡
Getting started with the widget 🚀
Register for updates 📥
Frequently Asked Questions (FAQs) ❓
Support the project 💪 / Buy me a coffee ☕
Bugs 🐞
References 🏆
Disclaimer

Features 💡



Currently small (2x2) and medium (4x2) sized widgets are supported. Some features are not available in the small widget. I have written in the brackets after the features in which variant it is available.

Shows date and time of next game (local timezone) (Small + Medium)
Shows city where the next game takes place (Small + Medium)
Show live score of next game. ""Live"" depends on how often the widget on the homescreen updates itself. It is not possible to say exactly, when it updates. (Medium)
Shows stats of both teams (wins, losses) (Small + Medium)
Shows standings of both teams (Small + Medium)
Shows top scorer of your team and the opponent (Small + Medium)
Shows next 4 games with date (Medium)
Caches logos to save data volume (Small + Medium)
Supports light- and dark-mode (Small + Medium)
Supports no-background.js (Medium)

Note: I don't know how the api displays the games when it comes to playoffs. I'll have to check again when the season is at this point.
You want to have more information on the releases? Check the changelog.
Getting started with the widget 🚀
There are 2 options to install this widget. For both options, make sure to download Scriptable from the AppStore before starting with the installation of the widget. Click here to get to AppStore.
1. Install with ScriptDude

2. Manual Installation

Click the ""+""-Icon in the Scriptable-app.
Copy all the text from the NBA-MyTeam-Widget.js-file. Click here to get to the file.
Step through the user settings in the script.
Add a Scriptable-widget to your homescreen.

Add it with size ""medium"".
Make sure to choose ""Run script"" for ""When Interacting"".



Having troubles with installing? Check the detailed installation guide here.
Register for updates 📥
Don't want to miss a update for this widget? Just head over to this GoogleForm, type your email address and I'll send you an email when a new update is released.
Frequently Asked Questions (FAQs) ❓
All Frequently Asked Question are collected here.
Support the project 💪 / Buy me a coffee ☕
As some users asked how to donate to the project I created this section:
Of course I won't take anything for the widget, but if you really want to donate, feel free to buy me a coffee via paypal.



Bugs 🐞
Found a bug? Feel free to create a issue.
References 🏆
I used the publicly accessible NBA api which is documented by kashav. The logos are taken from thesportsdb.com.
Disclaimer
This is a project developed by myself. It is not an official widget of the NBA. I have no relationship with the NBA.


",JavaScript
105,"



README.md




BasketballBoard
##篮球战术画板
    体育学院的一个老师做一个创新教学的课题，找我们实验室的老师做一个篮球战术画板，由于我们实验室主要是做硬件嵌入式的，所以
    
老师就让我和另一个同学用DE1-SOC-MTL2开发平台的FPGA做。我们用基于FPGA的Nios II软核搭一个CPU，然后用C语言写裸机程序。

由没有操作系统、Nios II 软核实现的CPU的性能也非常差，而且用C语言写起来也非常复杂，所以我们只实现了非常简单的功能。过年

来了后另一个同学复习考研了，所以我就打算用Android写一个App, 在这之前我写过一些非常简单的小程序，如wifi小车App和视频

监控App等，而且自己也对Android开发比较感兴趣，平时有空时也看了一些Android知识，也想今后往这方面发展，自己也比较有热情，

整个过程也还算比较顺利。

    里面的资源图片是找的别人的App里的解压出来的，整个框架只是用的AndroidStudio自带的Navigation Drawer Activity, 然后去

掉了Toolbar等，自己重新添加了TitleBar，侧边栏也做了一些修改。

###功能：



分段画战术轨迹，最后合成播放




多次重复播放




改变轨迹颜色和宽度




战术保存




战术库读取播放，删除战术




###演示gif
              	          	    
                         


",Java
106,"











ncaa-bracket
What is this?
Contributors
Assumptions
What's in here?
How to use this
License





README.md




ncaa-bracket
What is this?
Interactive and printable bracket for the annual NCAA March Madness basketball tournament. You can use this to publish the first round matchups, and it lets people pick their winners then print out their brackets. You can also use this to publish the current state of the tournament all the way down to the championship, ala this 2015 NCAA Tournament men's results bracket
This is not responsive, but please feel free to fork this and make it so. We accept pull requests! Demo: http://www.bracketadvisor.com/interactive-bracket/

Contributors

Nelson Hsu
Joe Murphy

Assumptions

Google docs
jQuery
Miso

What's in here?
The project contains the following folders and important files:

index.html -- Blank bracket
/js -- Javascript
/css -- Strangely enough, stylesheets

How to use this

Make a copy of this Google doc: https://docs.google.com/spreadsheets/d/1K4luNfy1yXkD4I-6CKEzvwPKCRAqCu9R6qo0ZMGQBn8/edit?usp=sharing
The teams for each region are in separate tabs including the play-in games.  All the labels are in the first tab. Once you have entered all the teams and information, ""Publish to the web...""
In the Publish window, you'll find a URL that will contain a key. Copy that and paste into line 16 of js/bracket.js
You'll probably want to update the year- and tournament-specific information at the top of index.html

License
The MIT License (MIT)
Copyright (c) 2014 Digital First Media
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ""Software""), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


",JavaScript
107,"











mRchmadness
Installation
Introduction
Shiny





README.md




mRchmadness
mRchmadness is not designed to predict the winners of tournament games, but
it is designed to answer the question: Given the true probabilities
dictating tournament results and given the probabilities with which my pool
opponents make their picks, what bracket maximizes my chances of winning my
pool? To answer this question, we simulate tournament results and opponent
picks over and over again, testing a set of candidate brackets against pool
opponents in each simulation and choosing the bracket that performs best.
Installation
# For the latest version of the package, updated frequently during the first
# couple weeks of March, install directly from this GitHub repository.
devtools::install_github('elishayer/mRchmadness')

# If you're not using this R package to fill out a bracket on a deadline, you
# might prefer to install the latest stable version from CRAN.
install.packages('mRchmadness')
Introduction
# For a tutorial on the primary use case of the package, check out the vignette
vignette('mRchmadness')
Shiny
For those who prefer a point-and-click interface, check out our
Shiny app.
You can also use the Shiny app locally by running
shiny::runApp('inst/shinyApp') from the mRchmadness directory.


",R
108,"











Sing4Magisk
Disclaimer
Module config
Usage
Manual mode





README.md




Sing4Magisk
Disclaimer

I'm not responsible for bricked devices, dead SD cards, or burning your Soc.
If you really don't know how to configure this module, you might need apps like v2rayNG, SagerNet etc.

Module config
template: sing/etc/sing.config
Module config use shell variable
Usage

Turn on/off on Magisk manager
Turn on/off by executing /data/adb/sing/scripts/sing.service

Manual mode
If you want to control sing-box by running command totally, just add a file /data/adb/sing/manual.  In this situation, sing-box service won't start on boot automatically and you cann't manage service start/stop via Magisk Manager App.
For further infomation, please visit sing-box wiki


",Shell
109,"











Data
Setup your Developer Environment
Building the Flask app
Parse the Data with Openpyxl





README.md




Compare NBA stats with Openpyxl and Twilio!

app.py: Text a Twilio number ""play,"" then text ""a"" or ""b"" for regular season 2016-1017 versus playoffs, and then text either one or two players separated by a space and a statistic (based on the text you got.)
simplifiedapp.py: Text a Twilio number two NBA players (first and last names) separated by a space and a statistic to compare.
We all know Excel sheets hold useful information, but it can be hard to read the data we want, and especially hard to compare two specific datasets within all that data. Bots, on the other hand, can do that hard work of finding the information for us.
We will read some NBA statistics from Excel sheets in Python using the Openpyxl library. How will we know which statistics to look for and return? Incoming SMS is two players and a type of NBA statistic, and then the outgoing SMS looks up the statistics of the corresponding players.
Data
The data we use is about specific NBA players from this past season.
There, you can specify which season, season type (playoffs versus regular season), data type (game average versus total for the season), which dates, and more. Fun, right? 
No Microsoft Excel? No problem! You can copy and paste the data directly into Google Sheets and export it as a .xlsx file. Here is an excerpt from the the Excel sheet (lots more data not shown to the right and below.)

Some statistics above include age, games played, wins, losses, minutes, points, field goal percentage, three-point shot percentage, and more.
Setup your Developer Environment
Make sure your Python and Flask development environment is set up, like this. If you don’t have a Twilio number to send and receive SMS messages, let’s do that here.
Once your environment is up and running, run the following command in the directory your python file will live in.

Building the Flask app
Make a file called app.py, and import these libraries at the top.

And then make our Flask object:
https://user-images.githubusercontent.com/8932430/27197789-9ad16264-51dd-11e7-8fec-2bf0295342a1.png
Don't forget to run Ngrok http 5000 in terminal! In your terminal in the same directory, run ngrok http 5000.

Now onto some fun stuff.
Parse the Data with Openpyxl
Openpyxl is an open source Python library that reads and writes Microsoft Excel 2010 files.
The higher-order function below takes in our entire Excel file of NBA data returns a dictionary of the data in our Excel file. Players are the keys, and the specific statistic data per each player as the values.

The data structures we use are two separate lists of players and their corresponding statistics we want to search (ie. just games played, wins, losses, minutes, points, field goal percentage, etc.) We then map those statistics to different columns of the Excel sheet, represented by letters, in stat_dict.
Then, we need to load the Excel file full of data with load_workbook and create a worksheet. More complex apps or data may have different sheets (with NBA data, one could be Regular Season while another could be for the Playoffs.) Since we only have one worksheet, we just want the one at index zero. Then, beginning with the for loop, we loop through each item in our Excel spreadsheet.
Finally, we loop through our Excel spreadsheet. The “A” column is for players, so each player in the column (and thus the sheet) are added to our list. Then, we loop through the column which is the value of our dictionary of statistics and columns and add each to the separate statistics list.
Say you want to read from columns. Each column is represented by a letter (that’s why we made the dictionary above, but the dictionary values match the columns in the Excel sheets.) To search multiple columns and just the front row, you could search something like this:

With our data, this returns the name of the player in the first row (Russell Westbrook) and the statistics from columns D, E, and F (wins, losses, and minutes played.)
If you want to access an individual cell, the following code are two different ways to return whatever is in the B column in the second row. (Without using value, you would just get “<Cell u'Sheet1'.B2>”.)

(another way of writing this same line of code is: b2v2 = ws.cell(row=2, column=2))
What does our code do after searching through the cells and rows creating our two distinct lists? These two lists are then zipped together into one dictionary with players as keys and the corresponding statistic numbers as values. This dictionary will be returned in our SendSms() function so we can check if the inputSMS message is in the dictionary (and thus in the Excel sheet.)
Now, onto the core of the code!

Let’s break this down. First, we get our input SMS and convert it to lowercase so it’s easier to check. Then, we break it up by whitespace and add each piece to a string array. If that array has a length of five (which is what we expect, because input should be two players (first and last names) and a statistic), then we assign variables to the two players and the statistic.
Next, we call our higher-order function parseDataIntoDict, and use the dictionary it returns to check that the variables are in it. If they are, we check if the data of one player is greater than the other. Depending on that, a different message is returned. If one or both of the players are not in the dictionary, we return an error message.
Lastly, we run our Flask app!

Wow! You just used Openpyxl to read an Excel spreadsheet. Isn’t it a very handy tool? Who knew reading and writing an Excel spreadsheet could be done this way?
So what’s next? Think of the possibilities! You can use Openpyxl for financial data, for baseball data, etc.
Questions? Comments? Tweet at me @lizziepika.


",Python
110,"











Facebook emoji Basketball Script
Level Support
Explanation
Support Devices





README.md




Facebook emoji Basketball Script
Python shell script to automate playing Facebook basketball. It is a script that use uiautomator python

####Requirement

Android phone with root access
PC (Mac or Linux are preferable)
ADB
Python
uiautomator

####Instruction

Plug your Android device to your PC and connect to ADB
Launch the basketball game
Run the script (Required python, uiautomate and adb)
Enjoy

Level Support

score 1-10 (100%)
score 11-20 (100%)
score 21-30 (98%)
score 31-40 (90%)
score 41-50 (70%)
in progress..

Explanation

score 1-10 The rim is stationary. We can simply use drag function from the ball to the rim.
score 11-20 The rim is moving and has a constant speed. Releasing the ball and set shooting location as an offset of the releasing position by constant pixels.
score 21-30 The moving rim speed is quicker than the score 11-20 and has an unstable speed. We cannot use the method in the previous level. By trial and error, I found that we should fix the shooting position to the middle of the screen. The decision making will be made in the releasing position. However, the optimal releasing position is so small, so the ball get shot not very often. I counter this problem by adding a delay when the rim moves to area before the optimal releasing position.
score 31-40 The rim is moving around across two axis in a transparent container. By statistic, it move to the middle of the screen very often, so I fixed the shooting position to the frequent passing position. The logic is similar to the score 21-30.
score 41-50 Similar to the score 31-40, but with bigger boundary. The logic is being developed. Initial guess is like the previous 3 sections.

Support Devices

I only test in my Nexus 4, but it should be fine on other devices.



",Python
111,"











nbagame
nbaapi.com
Overview
Database Syncing





README.md




nbagame
A Go client to retrieve NBA statistics from stats.nba.com. The client also supports syncing data to a mysql database.


nbaapi.com
If you're just looking for an API for the NBA, check out the nbaapi.com repo that uses nbagame to sync its database.
Overview
The endpoints exposed by nba.com are not intended for public consumption, and no public documentation exists. This package attempts to wrap these endpoints in a clean, well-documented interface.
teams, err := nbagame.Client.Teams()
if err != nil {
  panic(err)
}

for _, team := range teams {
  fmt.Printf(""%s, %s - %v\n"", team.Name, team.City, team.Wins)
}
Database Syncing
NBAGame is most useful as a means to populate a MySQL database with up-to-date NBA statistics. The nbagame/db/sync package provides a programmatic interface for syncing data. If you don't need the programmatic interface or will be using a language other than go, you can use the command-line tool in the nbagame/cmd package. First, follow the directions in the nbagame/db README to setup your MySQL database and your goose dbconf.yml configuration file. If you have permissions to create new MySQL databases and access them without credentials, you can create the database by running
mysql -e ""CREATE DATABASE nbagame""
go get bitbucket.org/liamstask/goose/cmd/goose
goose up

Once your database is constructed, go install ./cmd/... to install the command-line utilities.
To sync data to the entire database, run the following command:
nbagamesync -season=""2015-16""
By default, the command-line tool only loads data from the current season (except for players, which will load all historical players too). If you want to load data from a particular season, add the season flag.
nbagamesync -season=""2015-16""
If you don't want to sync everything, specify which entities you want to sync as arguments, ex:
nbagamesync teams games

Once you've loaded the data, open a MySQL client and try querying. Here's a sample query that calculates average blocks per game by team.
SELECT teams.id, teams.name, AVG(stats.blocks) AS avg_blocks_per_game
FROM teams
LEFT JOIN team_game_stats ON teams.id = team_game_stats.team_id
LEFT JOIN stats ON team_game_stats.stats_id = stats.id
GROUP BY teams.id ORDER BY avg_blocks_per_game DESC;


",Go
112,"











March Madness Algorithm
1. Projection and Simulation
2. Bracket-Pool Simulation
3. Optimization





README.md




March Madness Algorithm
This is the full code used for my march madness
optimization app. The app calculates a set of diversified brackets which gives you the best chance of winning in march madness. You can run the code
yourself to customize things such as increasing the number of
simulations, increasing the bracket pool size, changing the projection
model, and more. To run, the order of files is: 1-simulate-tournament,
2-simulate-brackets, 3-calculate payouts, 4-optimize-brackets in that
order. Or you can just use the optimization app. Below I explain the methodology.  
1. Projection and Simulation
The algorithm starts by projecting all the tournament matchups and then
simulating the tournament:
head(probs, 20)

##                     R1    R2    R3    R4    R5    R6
## 1 Villanova      0.984 0.861 0.660 0.464 0.290 0.184
## 1 Virginia       0.969 0.798 0.621 0.425 0.286 0.158
## 2 Duke           0.976 0.824 0.499 0.350 0.190 0.120
## 2 Purdue         0.961 0.711 0.501 0.229 0.127 0.071
## 2 Cincinnati     0.903 0.700 0.472 0.241 0.148 0.065
## 1 Kansas         0.912 0.695 0.511 0.243 0.103 0.059
## 3 Michigan State 0.901 0.705 0.355 0.225 0.117 0.057
## 2 North Carolina 0.975 0.762 0.467 0.250 0.129 0.052
## 4 Gonzaga        0.895 0.646 0.387 0.221 0.107 0.044
## 1 Xavier         0.975 0.674 0.349 0.192 0.080 0.038
## 3 Texas Tech     0.877 0.552 0.231 0.101 0.041 0.018
## 5 Ohio State     0.752 0.296 0.147 0.070 0.028 0.018
## 3 Michigan       0.820 0.492 0.246 0.124 0.051 0.017
## 3 Tennessee      0.861 0.556 0.280 0.109 0.040 0.015
## 5 West Virginia  0.868 0.468 0.155 0.065 0.031 0.013
## 4 Arizona        0.821 0.480 0.135 0.060 0.030 0.011
## 6 Houston        0.662 0.343 0.153 0.054 0.017 0.007
## 5 Kentucky       0.685 0.369 0.120 0.055 0.023 0.006
## 4 Wichita State  0.877 0.497 0.121 0.054 0.019 0.005
## 4 Auburn         0.809 0.459 0.169 0.049 0.013 0.005

Above are the probabilities of teams reaching each round for 2018, 1000
simulations  
2. Bracket-Pool Simulation
Then, using ESPN Pick
Percentages,
you can simulate a pool of brackets.
head(ownership, 20)

##            Team_Full    R1    R2    R3    R4    R5    R6
## 59        1 Virginia 0.986 0.938 0.645 0.532 0.334 0.172
## 58       1 Villanova 0.992 0.946 0.817 0.624 0.301 0.156
## 29  3 Michigan State 0.975 0.892 0.476 0.330 0.199 0.093
## 14            2 Duke 0.979 0.880 0.472 0.297 0.167 0.093
## 21          1 Kansas 0.976 0.909 0.759 0.279 0.152 0.081
## 36  2 North Carolina 0.986 0.899 0.561 0.347 0.164 0.078
## 28        3 Michigan 0.967 0.794 0.331 0.202 0.085 0.044
## 2          4 Arizona 0.939 0.598 0.220 0.170 0.095 0.043
## 64          1 Xavier 0.979 0.859 0.477 0.187 0.080 0.033
## 9       2 Cincinnati 0.976 0.842 0.549 0.111 0.059 0.030
## 18         4 Gonzaga 0.961 0.727 0.359 0.156 0.053 0.028
## 41          2 Purdue 0.979 0.848 0.602 0.160 0.053 0.022
## 23        5 Kentucky 0.830 0.339 0.096 0.078 0.038 0.014
## 51       3 Tennessee 0.945 0.681 0.267 0.037 0.018 0.011
## 55      3 Texas Tech 0.919 0.562 0.183 0.047 0.018 0.010
## 62   4 Wichita State 0.904 0.455 0.063 0.042 0.018 0.008
## 61   5 West Virginia 0.864 0.469 0.073 0.050 0.015 0.008
## 37      5 Ohio State 0.789 0.220 0.082 0.026 0.013 0.005
## 15         6 Florida 0.803 0.349 0.100 0.021 0.008 0.005
## 57 13 Unc Greensboro 0.039 0.019 0.009 0.006 0.005 0.005

Above are the ownership percentages by round for the pool of brackets,
1000 brackets. You can start to see that certain teams are overvalued in
the pool of brackets compared to their projections (ex: Mich St), while others seem to
be undervalued in the pool relative to their projection (ex: Villanova).
3. Optimization
Finally, you can apply your scoring to get finishes for each bracket in
the pool compared to eachother across the simulations. For example, the 2nd bracket generated in the pool of brackets will have different finishes for each simulation, and so by summarizing its finishes I can get its P(90th percentile) or P(95th percentile). Then you can set up an
optimization to return the optimal bracket(s) for any number of
specifications, Ex: Return 1 Bracket to maximize P(90th percentile). 3
brackets to maximize P(97th), 1 bracket to maximize points, etc. I can
also test out other brackets against the pool of 1000 brackets in order
to get alternative brackets which may do well but weren’t included in
the pool.
Below is the bracket which maximized P(90th percentile) for 2018:
brackets$Prob90<-apply(brackets[, grepl(""Percentile"", colnames(brackets)) & !grepl(""Actual"", colnames(brackets))], 1, function(x) sum(x>=.90)/sims)
max(brackets$Prob90) #projected P(90th percentile)

## [1] 0.306

plotBracket(brackets[which.max(brackets$Prob90), 1:63], text.size = .8)


brackets[which.max(brackets$Prob90), c(""Percentile.Actual"", ""Score.Actual"")]

##     Percentile.Actual Score.Actual
## 261             0.925         1070

The bracket ended up getting in the 92.5th percentile (getting the chamption right will usually get you there). I calculated the 92.5 by comparing the bracket's actual score to the actual scores of the brackets in the bracket pool.
In conclusion, using this system allows you to optimize the brackets you enter for march
madness. With the app or the code you can change the scoring system, pool
sizes, number of brackets entered, and projection system. Using this system gives you an analytical way to balance expected point maximization
with being contrarian.


",R
113,"



README.md




BasketballStats
Basketball Statistics Demo
Raw stats are in /data.


",Scala
114,"














BasketBall
体验说明
在线体验
源码体验
准备
下载代码
运行游戏
运行在web
运行在微信小游戏





README.md




BasketBall
CC游戏案例之 炸弹对攻
体验说明
联网游戏通常为多人游戏,需要开启多个客户端,详情见多开说明
在线体验
体验地址 体验链接
源码体验
准备

下载安装cocos creator(v1.8.1以上,v2.0以下)(http://www.cocos.com/download)
可以不更新本项目使用的matchvs插件,如果想需要使用最新的插件,可以在cocos creator中下载插件,

下载代码

git clone https://github.com/matchvs/BasketBall.git
用cocos creator打开该项目文件

运行游戏
运行在web

IDE打开项目
点击运行按钮,即可运行游戏
开始体验游戏

运行在微信小游戏

在cocos creator打包输出微信小游戏项目,点击cocos creator上的导航栏中的项目
在构建发布界面中,发布平台为""Wechat Game"",填入appid(如果是你自己的项目,你需要在微信开发者平台中申请).
点击构建,之后发布.
用微信开发者工具打开.
开始体验游戏



",JavaScript
115,"



README.md




Basketball web app
Try out the Basketball web app by clicking on the button below:



",Python
116,"














FSM
Features
Watch Games
Search Player
Search Team
Standings
Game Schedule
Stat Leader
Game Result
Special Features
NBA Meme
NBA News
Play with it!
Reference
License
Demo





README.md
















🏀 The NBA LINE Bot with 9 features!

Watch NBA games, check the schedule, lookup the stats, search for players by using Daily-NBA. Button carousel templates are designed and implemented in every feature. Instead of directly typing the commands to the LINE bot, users can just simply press buttons on the carousel template to browse the features and access the NBA information!
There are four main componenets in this project

LINE Bot: Built by the official LINE Messaging API
Web Scraping: Use BeutifulSoup to scrape several websites to retrieve NBA information
Backend: Built the backend with Flask to handle the webhook
FSM: Create FSMs with pytransitions for the users state management

FSM



Finite State Machine is implemented for the state management of the users. A FSM is maintained for each individual user. This way, every user has their own independent state, and the operations between two different users will not affect each other.
Finite state machine is a model in Theory of Computation. This model is implemented in Daily-NBA. Each feature is represented by a state, and the button that user pressed on the carousel template will trigger the transitions between states. The FSM graph is drawn by GraphMachine in transitions.extensions.
Features
Watch Games
Checking out all the scores of the games on that day. (Today / Yesterday / Manually input date)






Search Player
Searching for a specific player. (Manually input player name)









Search Team
Searching for a specific team. (Manually input team name)






Standings
Showing the team standing from both Eastern and Western conference.



Game Schedule
Showing the game schedule tomorrow.



Stat Leader
Showing the stat leaders. (Most Points / Assist / Rebound / 3PM / Steal / Block)



Game Result
Checking out the box score of a specific game. (Manually input date and team)



Special Features
NBA Meme
My favoritie feature! Brininging the best and newest NBA meme to you by pressing one button.



NBA News
Bringing the hottest NBA news to you by pressing one button.



Play with it!



Reference
All data comes from basketball-reference.com.
NBA memes come from twitter@NBAMemes.
NBA news come from realgm.
License
MIT © chonyy
Demo

































































",Python
117,"











DFSharp
Daily Pipeline
Working files, not yet integrated into dfsharp.com:





README.md




DFSharp
Open Source Tools For Daily Fantasy Basketball
Optimizer and Live projections are at-
DFSharp.com
Kibana dashboard can be viewed at-
DFSharps.com
Daily Pipeline
-generate_model.py
this file runs daily at 6am, pulling down stats from rotoguru.net and training/saving a gradient boosted regression model, while splitting off todays players and saving them as a csv
-make_projections.py
this file runs every 10 minutes from noon to 11pm, it reads depth charts, injury reports, and live twitter updates, loads latest model, and makes projections.  it inserts the latest projections into elasticsearch and saves a csv of the day's projections
-optimizer_openopt.py
this is the lineup optimizer file- the optimize() function can take a host of parameters, and returns a dataframe of the players in the optimized lineup.  it also writes the latest lineup to ES.  this file is called from the flask app
-/dflask/dflaskr.py
this is the flask app- it allows users to use the optimizer, manually adjust minutes, and view the latest projections, using AJAX, jquery and datatables.
-/dflask/templates/layout.html
this holds the html and javascript required to run the site
Working files, not yet integrated into dfsharp.com:
-Sentiment.py
this file reads in tweets from this list https://twitter.com/RotoViz/lists/dfs-follows , does sentiment analysis on each one and adds it to elasticsearch
-otp_Elastic.py
this file reads live NBA ownership information from the OwnThePlay.com API and adds it to elasticsearch
[OwnThePlay has shut down until october]
-carrot2.py
this file is for live clustering of elasticsearch results
-webhoser.py
this file uses webhose.io to pull in any articles related to ""NBA DFS"", and adds them to elasticsearch


",Python
118,"














euRobasket
Installation
Play by play functions
Getting the ids for fibalivestats.com and live.fibaeurope.com
Download stats tables from realgm.com
Download scores and box scores from realgm.com
Download and visualize shots
Assists





Readme.md




euRobasket
euRobasket is an R package which helps download, prepare and analyze data from
European basketball leagues. In current version data sources include: realgm.com,
fibalivestats.com, live.fibaeurope.com.
Installation
devtools::install_github('bziarkowski/euRobasket')
library(euRobasket)
Play by play functions
With euRobasket you can download play by play data from fibalivestats.com and live.fibaeurope.com and prepare it for further analysis.
This package makes play by play data easier to analyze by converting it to stints (stint is a period of time that the same set of ten players are on the court). But you can also download raw play by play.
#download raw play by play
get_raw_pbp_fibalivestats(742430)
get_raw_pbp_livefibaeurope(108510)

#get stints from play by play
get_stints_fibalivestats(742430)
get_stints_livefibaeurope(108510)
With stints you can calculate lineup stats and on/off splits.
#calculate lineups stats from single game with lineup_stats()
get_stints_fibalivestats(742430) %>% 
lineups_stats()

#calculate on/off splits for Ł. Koszarek and J. Florence from single game with on_off_splits()
get_stints_fibalivestats(742430) %>% 
on_off_splits(players = c('Ł. Koszarek', 'J. Florence'))

Getting the ids for fibalivestats.com and live.fibaeurope.com
Ids for fibalivestats.com and live.fibaeurope.com are available with this package.
You can get them by using data()
#fibalivestats.com
data(""fibalivestats_matches_ids"")

#live.fibaeurope.com
data(""livefibaeurope_matches_ids"")
Download stats tables from realgm.com
Stats tables with teams or players stats. You can download different types of
stats such as: Totals, Advanced Stats, Averages, Per48, Per40, Per36, Miscellaneous.
#get available realgm.com leagues
get_realgm_league_names()

#download teams stats
get_team_stats_realgm(league = 'Spanish ACB', season = 2017, type = 'Totals')
get_team_stats_realgm(league = 'Polish TBL', season = 2014, type = 'Advanced_Stats', split = 'Team_Starters')

#download players stats
get_players_stats_realgm(league = 'Israeli BSL', season = 2014, type = 'Advanced_Stats')
get_players_stats_realgm(league = 'German BBL', season = 2016, type = 'Totals', position = 'PG')
Download scores and box scores from realgm.com
Scores and box scores from european league for given period of time.
Date format is YYYY-MM-DD.
#download scores
get_scores_realgm('2017-10-01', '2017-11-01', league = 'Polish TBL')
get_scores_realgm('2015-09-01', '2016-02-01', league = 'Danish Basketligaen')

#download box scores
get_boxscores_realgm(start_date = '2016-10-01', end_date = '2016-10-02', league = 'Turkish TBL')

Download and visualize shots
euRobasket lets you download and visualize shot data for various leagues from fibalivestats.com and live.fibaeurope.com.
Download data from single games with game id.
#from fibalivestats.com
get_shots_data_fibalivestats(742430)

#from live.fibaeurope.com
get_shots_data_fibalivestats(108510)

Visualize shots
#one chart from single game with shot_chart()
get_shots_data_fibalivestats(742430) %>%
dplyr::filter(player == 'F. Matczak') %>%
shot_chart(type = 'Scatter')
You can also create dashboard with shots.
#download shots from multiple games with for loop
shots = data.frame()
for(i in c(742430, 766471)) {
shots = rbind(shots, get_shots_data_fibalivestats(i))  
}

#create dashboard
shots_dashboard(shots)
Assists
Download assists and create assists networks for teams
#download assists
get_assists_fibalivestats(742430) %>%
assist_network()


",R
119,"











Smarter Than Nate Silver
Making NCAA March Madness predictions
A Rank Agnostic Approach
Neural Nets
2017 March Madness
Contact





README.md




Smarter Than Nate Silver

SmarterThanNateSilver.com - website is live!
Making NCAA March Madness predictions
It's about that time of year again!
Time to fill out a bracket and pick the best college basketball team in America.
But, how should we pick who wins?
Tons of very smart people spend an inordinate amount of time trying to answer exactly this question. Nate Silver's website FiveThirthyEight.com does a good job of showing probabilities of any team winning the tournament.
So why the beef with Nate, dog?
Most of his predictions (as well as others') rely heavily on stats like BPI, Power Ratings, and Elo scores which are themselves based mostly on the ranking of the team going into the tournament. These rank-based stats take many names, sometimes it's ""Strength of Schedule"", or ""Opponent Strength"". But those stats skip over the fact that they have not defined what determines highly ranked team to begin with.

So, models built on this information lean toward picking a winning team based on who is the better seed. You can see this effect based on who FiveThirtyEight has picked to be in the Final Four from the last couple of tournaments:
|Year|Team|Seed|Made Final Four
-----|-----|-----|:-----:|-----
2016|Kansas|1|No
||UNC|1|Yes
||Mich. St.|2|No
||Oklahoma|2|Yes
2015|Kentucky|1|Yes
||Villanova|1|No
||Duke|1|Yes (won championship)
||Arizona|2|No
2014|Florida|1|Yes
||Arizona|1|No
||Louisville|4|No
||Mich. St.|4|No
Hmmmm...that seems to be a lot of No.1 seeds. Perhaps they are seeded higher because they are the better team, so we should use this number, right?
Not exactly, ranking and placing teams in the opening round of the tournament is far more complicated, and even worse, dependent on a panel to decide where each team should rank.
A Rank Agnostic Approach
Why not just ignore the rankings, and mine through historical data to evaluate team performance based solely on player-level data?
We can then use this game data to predict the outcome of future matches based on the patterns seen in the historical data. Machine Learning techniques like Neural Nets do a great job of finding these type of patterns. So let's build a Multilayer Perceptron to take player data from regular season game data to predict the margin of victory (the point-spread) of post-season games like the March Madness tournament.
This data was scraped for every game that had complete boxscores for the last decade using my scrapey.py file in this repo. Also, csv files for player data of each season are available in the data folder.
What is a point-spread?
Point-spreads were introduced by Charles K. McNeil (who later became JFK's math teacher) as an attempt to balance out betting between both outcomes. For example, if Team 1 is a strong favorite to beat Team 2, you would expect that a majority of the bets will be for Team 1 to win. This is a huge disadvantage to whomever is taking the bet. If Team 1 wins, they have a massive amount of payouts to make. But, if we make the bet over whether Team 1 will win by more than an certain number of points rather than just if they will win. We now can move this handicap to persuade bets to take one side or the other and thus keep an even number of bets on both sides.
Wait, why would the people taking the bet want an even number on both sides?
Great question, because they want to minimize their exposure to risk. With balanced betting they can trust that regardless of the outcome, there is no risk of one side having to pay out more than the other. Don't worry though, they still get a piece of every bet they see, so they still make money.
Neural Nets
Neural Nets (NN) adapt to the data being feed into them. They are adapting to what they see in relation to the desired outcome. This adaptation of the model is why these methods are referred to as Machine Learning. The model changes a neuron's weighted input that minimizes the error between the model output and desired output.
To build the Multilayer Perceptron NN I used Keras and followed a lot of what Jason Brownlee blogged about on Machine Learning Mastery. Because we are concerned with predicting point_spreads, this is a regression model. I used a deep network in the hopes that it would allow the NN to find more interactive patterns in the player stats, like an underlying synergy or ""team-i-ness"". I tested just under 100 different parameter tweaks (e.g. number of hidden layers, width of input layer, activation function, and epoch/batch sizes). Using the following model I achieved the lowest RMSE and highest percentange of correct calls on game winner:
def baseline_model():
    model = Sequential()
    model.add(Dense(200, input_dim=X2_reg.shape[1], init='uniform',
        activation='softsign'))
    model.add(Dense(75, input_dim=X2_reg.shape[1], init='uniform',
        activation='softsign'))
    model.add(Dense(10, input_dim=X2_reg.shape[1], init='uniform',
        activation='relu'))
    model.add(Dense(1, init='uniform'))

    model.compile(loss='mean_squared_error', optimizer='adam')
    return model
2017 March Madness
This same approach was used to model data from the 2016-2017 dataset. Results of all predictions (all 351 tems playing each other, roughly 62,000 predictions) were computed and dumped into a python dict which allows fast access to results without the unnecessary re-modeling and re-predicting. Because dicts are hash-mapped, they are also incredible fast and web-friendly since they resemble JSON elements. These predictions get served over the web using a Flask app which you can find here: SmarterThanNateSilver.com
After ""Selection Sunday"" on March 12th, I will be filling out a bracket with choices made solely by my model, as well as predicted results for daily match-ups throughout the tournament.
I have also modified this model to conform to Kaggle's ""March Machine Learning Mania"" so you can track how well it's holding up against other Data Science Nerds:
Kaggle Leaderboard
Contact
Feel free to reach out if you are in the market for a data scientist!
Steve Iannaccone - Denver, CO
LinkedIn
GitHub


",HTML
120,"



README.md




basketball-object-tracker
CS 231 Project Winter 2014
Project to perform single-view 3D reconstruction of basketball scenes
using commonly available TV footage of games.
Our main objective is to identify location of court relative to camera.
Source code is located in the src directory:

To get an understanding of how the 4-point selection works, look at
image_object.py, which calls most other files.
(This script can be run without arguments.)
The homography estimation is done in homography.py.
(This script can be run without arguments.)
Frame extraction is done in extract_frames.py.
(This script requires arguments, which you can find by running with -h.)



",Python
121,"














P+ League LINE Chatbot
Prerequisite
Developer Side
Environment property
LINE account (LINE_CHANNEL_ACCESS_TOKEN, LINE_CHANNEL_SECRET)
Local testing
Heroku
License





README.md




P+ League LINE Chatbot



Prerequisite

flask/Python 3.8
LINE v10.14
PostgreSQL


You need Github, LINE, Heroku accounts to deploy this bot.

Developer Side
Environment property
Fill in the following environment variables:
LINE_CHANNEL_ACCESS_TOKEN=
LINE_CHANNEL_SECRET=
DATABASE_URL=postgres://USER:PASSWORD@127.0.0.1:5432/postgres


You need to modify DATABASE_URL as your postgresql settings.

LINE account (LINE_CHANNEL_ACCESS_TOKEN, LINE_CHANNEL_SECRET)

Got A LINE Bot API developer account Make sure you already registered, if you need use LINE Bot.


Go to LINE Developer Console

Close auto-reply setting on ""Messaging API"" Tab.
Setup your basic account information. Here is some info you will need to know.

Callback URL: https://{YOUR_URL}/webhooks/line
Verify your webhook.




You will get following info, need fill back to .env file.

Channel Secret
Channel Access Token (You need to issue one here)



Local testing


Run Scripts/ profiles first, sync official website data to database as crawler.


first terminal window


cp .env.example .env # Modify variables value

# By docker (choose one)
docker-compose up # and go to DOCKER_IP:4040

# By localized (choose one)
pip install -r requirements.txt --user
python api.py


Create a provisional Https:

ngrok http 5000

or maybe you have npm environment:
npx ngrok http 5000



Copy URL to LINE Developer Console

Heroku


Enable clock button to schedule corn.



Add Heroku Postgres and it would create DATABASE_URL environment variable automatically.


If you are not sure where are files in, use following up commands:
heroku run bash
heroku logs --tail

License
MIT License


",Python
122,"














consumable-code-the-sport-db-api
Attention Please ‼️
Screenshoot Apps
Version Release
How To Use This Project
Step 1. Add the JitPack repository to your build file
Step 2. Add the dependency
Step 3. Declaration ConsumeTheSportDbApi
Documentation THE SPORT DB API
Function Main From This Project
Colaborator
Attention !!!





README.md





consumable-code-the-sport-db-api
 
Eliminates the method of retrieving json data using retrofit repeatedly. so this project has a set of functions to retrieve data without the need for fetching data using the retrofit of the API
Attention Please ‼️
Please use frogo-consume-api Click Here to get the latest updates
Screenshoot Apps



The Sport DB API
Chuck Data 1
Chuck Data 2










Version Release
This Is Latest Release
$version_release = 1.1.1

What's New??
* Update Build Gradle *
* Enhance Performance *

How To Use This Project
Step 1. Add the JitPack repository to your build file
Add it in your root build.gradle at the end of repositories:
allprojects {
	repositories {
		...
		maven { url 'https://jitpack.io' }
	}
}

Step 2. Add the dependency
dependencies {
        // library consumable code the sport db api
        implementation 'com.github.amirisback:consumable-code-the-sport-db-api:1.1.1'
}

Step 3. Declaration ConsumeTheSportDbApi
val consumeTheSportDbApi = ConsumeTheSportDbApi(""1"") // ""1"" is API KEY

consumeTheSportDbApi.usingChuckInterceptor(this) // This is Code Chuck Interceptor

consumeTheSportDbApi.searchForPlayerByName(
    ""Danny Welbeck"",
    object : SportResultCallback<Players> {
        override fun getResultData(data: Players) {
            
            // * PLACE YOUR CODE HERE FOR UI / ARRAYLIST *

        }

        override fun failedResult(statusCode: Int, errorMessage: String?) {
            // failed result
        }

        override fun onShowProgress() {
            // showing your progress view
        }

        override fun onHideProgress() {
            // hiding your progress view
        }
    })

Documentation THE SPORT DB API
https://www.thesportsdb.com/api.php
Function Main From This Project
// Switch For Using Chuck Interceptor
fun usingChuckInterceptor(context: Context)

// Search for team by name
fun searchForTeamByName(teamName: String?, sportResultCallback: SportResultCallback<Teams>)

// Search for team short code
fun searchForTeamByShortCode(shortCode: String?, sportResultCallback: SportResultCallback<Teams>)

// Search for all players from team *Patreon ONLY*
fun searchForAllPlayer(teamName: String?, sportResultCallback: SportResultCallback<Players>)

// Search for players by player name
fun searchForPlayer(playerName: String?, sportResultCallback: SportResultCallback<Players>)

// Search for players by player name and team name
fun searchForPlayer(playerName: String?, teamName: String?, sportResultCallback: SportResultCallback<Players>)

// Search for event by event name
fun searchForEvent(eventName: String?, sportResultCallback: SportResultCallback<Events>)

// Search For event by event name and season
fun searchForEvent(eventName: String?, season: String?, sportResultCallback: SportResultCallback<Events>)

// Search for event by event file name
fun searchForEventFileName(eventFileName: String?, sportResultCallback: SportResultCallback<Events>)

// List all sports
fun getAllSports(sportResultCallback: SportResultCallback<Sports>)

// List all leagues
fun getAllLeagues(sportResultCallback: SportResultCallback<Leagues>)

// List all Leagues in a country
fun searchAllLeagues(countryName: String?, sportResultCallback: SportResultCallback<Countrys>)

// List all Leagues in a country specific by sport
fun searchAllLeagues(countryName: String?, sportName: String?, sportResultCallback: SportResultCallback<Countrys>)

// List all Seasons in a League
fun searchAllSeasons(idTeam: String?, sportResultCallback: SportResultCallback<Seasons>)

// List all Teams in a League
fun searchAllTeam(league: String?, sportResultCallback: SportResultCallback<Teams>)

// List all Teams in Sportname & Country Name
fun searchAllTeam(sportName: String?, countryName: String?, sportResultCallback: SportResultCallback<Teams>)

// List All teams details in a league by Id
fun lookupAllTeam(idLeague: String?, sportResultCallback: SportResultCallback<Teams>)

// List All players in a team by Team Id *Patreon ONLY*
fun lookupAllPlayer(idTeam: String?, sportResultCallback: SportResultCallback<Players>)

// List all users loved teams and players
fun searchLoves(userName: String?, sportResultCallback: SportResultCallback<Users>)

// League Details by Id
fun lookupLeagues(idLeague: String?, sportResultCallback: SportResultCallback<Leagues>)

// Team Details by Id
fun lookupTeam(idTeam: String?, sportResultCallback: SportResultCallback<Teams>)

// Player Details by Id
fun lookupPlayer(idPlayer: String?, sportResultCallback: SportResultCallback<Players>)

// Event Details by Id
fun lookupEvent(idEvent: String?, sportResultCallback: SportResultCallback<Events>)

// Player Honours by Player Id
fun lookupHonour(idPlayer: String?, sportResultCallback: SportResultCallback<Honors>)

// Player Former Teams by Player Id
fun lookupFormerTeam(idPlayer: String?, sportResultCallback: SportResultCallback<FormerTeams>)

// Player Contracts by Player Id
fun lookupContract(idPlayer: String?, sportResultCallback: SportResultCallback<Contracts>)

// Lookup Table by League ID and Season
fun lookupTable(idLeague: String?, season: String?, sportResultCallback: SportResultCallback<Tables>)

// Next 5 Events by Team Id
fun eventsNext(idTeam: String?, sportResultCallback: SportResultCallback<Events>)

// Next 15 Events by League Id
fun eventsNextLeague(idLeague: String?, sportResultCallback: SportResultCallback<Events>)

// Last 5 Events by Team Id
fun eventsLast(idTeam: String?, sportResultCallback: SportResultCallback<Results>)

// Last 15 Events by League Id
fun eventsPastLeague(idLeague: String?, sportResultCallback: SportResultCallback<Events>)

// Events in a specific round by league id/round/season
fun eventsRound(idLeague: String?, round: String?, season: String?, sportResultCallback: SportResultCallback<Events>)

// All events in specific league by season (Free tier limited to 200 events)
fun eventsSeason(idLeague: String?, season: String?, sportResultCallback: SportResultCallback<Events>)

Colaborator
Very open to anyone, I'll write your name under this, please contribute by sending an email to me

Mail To faisalamircs@gmail.com
Subject : Github _ [Github-Username-Account] _ [Language] _ [Repository-Name]
Example : Github_amirisback_kotlin_admob-helper-implementation

Name Of Contribute

Muhammad Faisal Amir
Waiting List
Waiting List

Waiting for your contribute
Attention !!!
Please enjoy and don't forget fork and give a star

Don't Forget Follow My Github Account
If you like this library, please help me / you can donate to buy patreon services



",Kotlin
123,"











BasketTracking
Table of Contents
Demo
Dependencies
Usage





README.md




BasketTracking

Tactics and statistics in professional basketball teams are widespread. This operation can be optimized and speed up by
an automatic computer vision system. We aim at developing such system capable of action tracking and understanding in
basketball games using computer vision approaches and ideas alongside deep learning models such as Detectron2. Our
system tracks player trajectories from videos and rectifies them to a standard basketball court, showing also the player
who owns the ball.
Table of Contents

Demo
Dependencies
Usage

Demo



Dependencies

Python
OpenCV
Detectron2
Pytorch-Cuda
Numpy
Matplotlib

Usage
The system can be executed from the main.py.

main.py: Initializes classes and loads or rectifies the needed images
video_handler.py: Manages the frame reading procedure from the input video.
rectify_court.py: Produces homographies, rectified images, panoramas.
ball_detect_track.py: Detects and tracks the ball
player_detection.py: Detects and tracks the players
player.py: Contains the class Player.
tools: Helper functions.
resources: Contains template images, input video.



",Python
124,"














nbapy - stats.nba.com API for python
Summary
Usage
Documentation
Installation
Contributing
1. Fork the repository and create a feature/bug fix branch
2. Install development requirements
3. Hack away
4. Create some tests
5. Make sure everything looks good
6. Submit a pull request
To-Do
Authors





README.md









nbapy - stats.nba.com API for python
Summary
A python facing API for stats.nba.com
Warning stats.nba.com is notorious for being extremely unreliable. Please report any issues you find.
Usage
All data is returned as a pandas dataframe (check out the starter docs if you're new to pandas). For example:
from nbapy import game
import pandas as pd

game_id = '0021900017'  # taken from 'https://stats.nba.com/game/0021900017/'
stats = game.BoxScore(game_id).players_stats()
print(stats)
If you want to cache results so you don't have to reach the api every time, you can use requests-cache
from nbapy import game
import pandas as pd
import requests_cache

requests_cache.install_cache('nbapy_cache')

game_id = '0021900017'
stats = game.BoxScore(game_id).players_stats()
print(stats)
Documentation
A constant work-in-progress, but check them out!
Installation
To install from pypi:
$ python -m pip install nbapy
Contributing
1. Fork the repository and create a feature/bug fix branch
2. Install development requirements
You will to first install poetry if you don't already have it.
$ python -m pip install poetry
After that, just run poetry install inside of your fork.
3. Hack away
Coding conventions

black for formatting
google docstrings
flake8 for linting
mypy for static typing analysis
conventional commits for commit style.
isort for import organization.

Whew, that's a lot, but I'm a big fan of clean code, and I hope you are too! The good news is that if you follow the following advice, you'll find these aren't too hard to manage 😄
Optional (but recommended)
nbapy has a pre-commit file that you can install to automatically enforce these conventions prior to committing via a git hook.
To install: $ pre-commit install
You can also use $ pre-commit run -a to run the checks manually.
For commit messages, I recommend using commitizen. It is automatically installed in the dev dependencies, so to commit, you just run cz c and follow the prompts.
If you're using pre-commit, and either the black or isort check fails, the good news is it will fix the problems for you. However, it won't continue the commit automatically so that you get a chance to look over the changes. You'll have to re-stage the changes, and then you can run cz c --retry so you don't lose that nice commit message you just wrote.
4. Create some tests
5. Make sure everything looks good
$ pytest --cov*
$ sphinx-build -n -W -q -b html docs docs/_build/html
$ pre-commit run -a (if you didn't install the pre-commit git hook)
* note the first time you run this, it may take a few minutes. However, the requests will cache, and subsequent runs should be much faster.
6. Submit a pull request
Other ways to contribute involve submitting any issues or adding some documentation!
To-Do

Finish Jupyter Notebook documentation

Authors
This is orginally based off of https://github.com/seemethere/nba_py so a lot of the work was done by those guys. My goal with this project is to clean up the code, add some proper documentation, and keep it up to date.


",Python
125,"














Setup Environment
Installing PostgreSQL on OSX
Installing PostgreSQL on Linux
Installing PostgreSQL on Windows
Download Source
Prepare the Database
Install Dependencies
Start the Server
Register a User
Enjoy





README.md




@page bitballs Bitballs
@group bitballs.components Components
@group bitballs.clientModels Client Models
@group bitballs.services Services
@group bitballs.serviceModels Service Models
@hide contents

Bitballs is a DoneJS app that enables users to coordinate
the players, teams, games, rounds and recordings of a basketball tournament.
It also serves as an example of how to use DoneJS with sessions, user
privileges, RESTful services, and ORM models.
To run the Bitballs app locally, run its tests, or generate its documentation
follow the steps outlined below.

Setup Environment

Installing PostgreSQL on OSX
Installing PostgreSQL on Linux
Installing PostgreSQL on Windows


Download Source
Install Dependencies
Prepare the Database
Start the Server
Register a User
Enjoy

Setup Environment
Make sure you have installed:

Node 5
NPM 3 (packaged with Node)
PostgreSQL

Installing PostgreSQL on OSX
On a Mac, the easiest way to install and configure PostgreSQL
is using the brew utility:
brew install postgresql

Pay special attention to the end of the brew command's
output, which includes instructions on how to start postgres:
To load postgresql:
  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
Or, if you don't want/need launchctl, you can just run:
  postgres -D /usr/local/var/postgres

The provided launchctl command ensures the postgres process is always
running, even after a system restart. The alternative postgres command
starts the postgres process manually.
We recommend the launchctl option. If desired, postgres can be
stopped and uninstalled by running:
brew uninstall postgresql

Installing PostgreSQL on Linux
Coming Soon
Installing PostgreSQL on Windows
Download and use the graphical installer available on postgresql.org. Make sure you host it listen to port 5432.
Open pg_hba.conf, which should be in C:\Program Files\PostgreSQL\9.5\data, and change from md5 authentication to trust. For example, change:

host    all             all             127.0.0.1/32            md5

to:

host    all             all             127.0.0.1/32            trust

trust should not be used in a production environment.  We are only using it here as a substitute for the peer mode available in UNIX environments. Read more about it here.
Finally, using pgAdmin III graphical database manager, which should have been installed with postgres, create a bitballs database.
Download Source
Clone this repo using git:
git clone https://github.com/donejs/bitballs.git

Navigate to the repository's directory
cd bitballs

Prepare the Database
Make sure the postgres process is running:
ps | grep postgres

You should see ""postgres -D"" among the output:
92831 ttys000    0:00.02 postgres -D /usr/local/var/postgres
92856 ttys000    0:00.00 grep postgres

With that confirmed we can create the database that the bitballs app
will persist its data to:
createdb bitballs

Install Dependencies
To install the project's JavaScript dependencies run:
npm install

Additionally DoneJS's command line utilities need to be installed globally:
npm install -g donejs-cli

Start the Server
With all the prerequisite setup completed the server can be started by running:
donejs develop

Register a User
Navigate to http://localhost:5000/register
in your browser and follow the instructions.
Enjoy
You're finished! Explore some of the app's features:

Live reload (donejs develop)
Run the tests (donejs test)
Generate the documentation (donejs document)



",JavaScript
126,"



README.md




nba-hangtime


",Assembly
127,"














Basketball-Statistics-Tracking
By: Alex Eidt
Home Screen:
Buttons and Labels:
Settings Window:
Starter Selection:
Buttons and Labels:
Roster Management
Buttons and Labels:
Box Score Button:
Player Buttons:
Undo Button:





README.md




Basketball-Statistics-Tracking
By: Alex Eidt
A program that can track player statistics for a Basketball Game

All Icons in the 'Image' Folder are not mine and all rights are reserved to their respective owners.
Visit pngtree.com for Free Icon Downloads.

Home Screen:
When the program is launched from BasketballMain the Home Screen is created and is
shown below:



Buttons and Labels:



Icon
Component Name
Description





Add Player
Adds the player name entered in the text field.



Undo
Removes the most recently added player.



Players
The players entered by the user. The most recently added player appears at the top of the list.



Start Game
Becomes enabled when the user enters the minimum required players. The default minimum is 5, however the user can change this in the Settings.



Old Games
Loads any games previously tracked using this software. In the case of a crash or unwanted closure of the program, statistic tracking can resume without any concerns.



Instructions
Opens a new window with the documentation for the program. There is text that walks the user through all the components of the program and has interactive panes where the user can become familiar with the mechanics of the program.



Settings
Allows user to change the rules governing gameplay and the background color of the program while they use it.



Close
Closes the program.



Settings Window:
The settings window features several Radio Button groups to change the configurations of the game. There is also the option of changing the background color of the program. The settings window is shown below:




Starter Selection:
If the number of players entered in the Home Screen is greater the number
of starters selected in the settings window, then you will need to choose
who will start in your game.
Clicking on the player names will add them to a list of players currently
selected to start the game. You will only be able to start the game
once you have selected the appropriate number of starters.



Buttons and Labels:



Icon
Component Name
Description





Undo
Removes the most recently added starter.



Start Game
Becomes enabled when the correct number of starters have been entered. Opens a Roster Management window.



Close
Closes the Starter Selection window.




Roster Management
If the number of players entered equals the number of starters specified (either by default or in
the settings) then you will be directed to this window after clicking the Start Game
button in the Home Screen or if the game you are loading with the Old Games
button had as many players as starters specified.



If the number of players entered was greater than the number of starters specified, then you were redirected to the Starter Selection window where you chose your starters. Once you pressed the Start Game button there, you will be redirected to an alternate version of the Roster Management window with starters and a bench. Players who foul out of the game have their button marked red and disabled. If the foul that got that player ejected is removed through the Undo Button, then that player's button will become enabled and will be colored light gray to show they are back on the bench and can be substituted in. If only five players remain (or however many starters were specified in the Settings) due to player ejections or injuries, then no player that has fouled out will be allowed into the game, contrary to the NBA Rule where the first player who fouled out comes back into the game.



Buttons and Labels:



Icon
Component Name
Description





Score
Shows the total points scored by the team.



Box Score
Opens a new window showing all player statistics in the traditional Box Score format used for Basketball Games.



Undo
Opens a new window allowing the user to correct any statistics they entered by deleting them. All periods of the game are shown and clicking on a period shows the user all statistics that were entered during that period. Clicking on any statistic closes the Undo window and removes that statistic.



Done
Stops the game and closes the Roster Management window.



Start/Stop
Starts/Stops the timer for the game.



Timeouts
Takes away one timeout (Timeouts remaining shown on button) and stops the  timer.



Team Fouls
Shows the current number of team fouls in the period. Resets after each period.



Box Score Button:
The window that appears when the Box Score Button is pressed. It shows all player statistics in the traditional 'Box Score' format. The table is shown below:



Player Buttons:
There are some additional features in the Roster Management window. When a player's button is clicked (who is on the court), a new window will open that allows the user to select from all possible statistics. Pressing on any statistic will increment that statistic for the given player by the correct amount. This window is shown below:



Some statistics increment several other statistics when they are incremented:

Made FG
Made 3pt FG
OREB/DREB

For example, if a Made 3pt FG is selected, then Points, Made FG, FGA, Made 3pt FG, and 3PA are all incremented as well.
The program incorporates several features to make statistical tracking quicker during actual game play. Hotkeys are shown in square brackets for quicker statistic entries and several statistics have built in functionality to avoid redundancy. Made Shots, Missed Shots and Blocks will ask the user if the shot was Assisted, Offensive Rebounded, or Defensive Rebounded respectively.
For Example: If the statistic is a missed shot, then the user is asked if the shot was rebounded by a teammate, if that is the case, then the user will be asked who got the reboudn. These windows are shown below:



Did a team member get the Offensive Rebound?
Who got the Rebound?









If the Roster Management window has a bench panel on it, then clicking on one of the players on the bench will open a window that will ask the user to substitute the player that was clicked into the game. The window is shown below:



Undo Button:
If there was a mistake when entering a statistic, it is possible to undo this mistake with the Undo Button. When clicked, a window will open with a bar at the top allowing the user to chose from any period of the game. If that period has not yet started, then those buttons will be disabled. When the desired period button is clicked, a list of buttons will appear each showing the statistics entered in chronological order. Clicking on a statistic will close the window and remove that statistic. The window is shown below:





",Java
128,"











Web Scraping NBA Data Using Selenium
By Alex Cheng
Description
Example
Data
More Information





README.md





Web Scraping NBA Data Using Selenium
By Alex Cheng
Description
This web scraper is a tool to scrape data from Basketball-Reference.com. Using the web scaper module, you can go to a specific player's page on Basketball-Reference.com and scrape the career statistics from these tables:

Per Game
Per 100 Possessions
Advanced
Shooting

Example
Source: Russell Westbrook

Data
Basketball-Reference.com
More Information
SeleniumHQ


",Python
129,"











Time2Jam
Dedication
Art Tools





README.md




Time2Jam
Dedication

“If you make every game a life and death proposition, you’re going to have
problems. For one thing, you’ll be dead a lot.”
–- Dean Smith

Art Tools

https://github.com/khalim19/gimp-plugin-export-layers



",Haskell
130,"











Repository Overview
Data Collection
Scraping MVP Data
Scraping NBA Player Statistics
Preparing Datasets - CSV Files
Machine Learning
Ridge Regression





README.md




Repository Overview
The first section of this application involves scraping NBA statistics from Basketball Reference in order to train a machine learning model we can use to generate time-series predictions for each player, in regards to their chance of winning the MVP for a certain year.
Data Collection
We use Python to scrape data from Basketball Reference, a website that provides basketball statistics and player data from the past 30 years in the NBA.

Source: https://www.basketball-reference.com/
Datasets: MVP Data, Player Statistics, Team Statistics

Scraping MVP Data
The following block of code scrapes MVP data from the past 30 years (1991 to 2022), then creates an HTML file for each year. After we are finished webscraping, we will extract the relevant data from each HTML file, and convert those files into individual CSV files.
def Scrape_MVP():   
    years = range(1991, 2022)
    url_start = ""https://www.basketball-reference.com/awards/awards_{}.html""
    for year in years:
        url = url_start.format(year)
        data = requests.get(url)        
        with open(""mvp/{}.html"".format(year), ""w+"") as f:
            f.write(data.text)
Scraping NBA Player Statistics
The webpages that contain NBA player statistics contain dynamic content, making it a challenge to scrape all of the data we need in order to train our machine learning model. However, we address this problem using a Selenium chrome driver in order to loa  block of code scrapes MVP data from the past 30 years (1991 to 2022), then creates an HTML file for each year. After we are finished webscraping, we will extract the relevant data from each HTML file, and convert those files into individual CSV files.
Preparing Datasets - CSV Files
After collecting the MVP data from the past 30 years, we iterate every year in our 'mvp' folder and apply the following operations to each HTML file:

Create an empty array that will be used to store multiple dataframes
Extract relevant information from each HTML file, specifying the 'id' attribute of the table we need.
Use Pandas to read the HTML table using Pandas as a dataframe
Create a CSV file in the ""mvp"" folder using the .to_csv() operation

def Parse_MVP(years):
    dfs = []
    years = range(1991, 2022)
    for year in years:
        with open(f""mvp/{year}.html"") as f:
            page = f.read()
        soup = BeautifulSoup(page, ""html.parser"")
        soup.find('tr', class_=""over_header"").decompose()
        mvp_table = soup.find(id=""mvp"")
        mvp_df = pd.read_html(str(mvp_table))[0]
        mvp_df[""Year""] = year        
        dfs.append(mvp_df)
    mvps = pd.concat(dfs)
    mvps.to_csv(""mvp/mvps.csv"")    

Avoid overloading website by sending too many requests
Google Chrome Version: 102.0.5.005.61
Selenium Chrome Driver: https://chromedriver.storage.googleapis.com/index.html?path=102.0.5005.61/

Run in Command-Line:



xattr -d com.apple.quarantine /Users/danieldayto/Downloads/chromedriver



Machine Learning
Scikit-learn is a free software machine learning library for the Python programming language. It features various classification, regression and clustering algorithms.
Ridge Regression
Ridge regression is a regularization technique that performs L2 regularization. It modifies the loss function by adding the penalty equivalent to the square of the magnitude of coefficients.
  train = stats[stats[""Year""] < 2021]
  test = stats[stats[""Year""] == 2021]
  reg = Ridge(alpha=.1)
  reg.fit(train[predictors], train[""Share""])
  predictions = reg.predict(test[predictors])
  predictions = pd.DataFrame(predictions, columns=[""Predictions""], index=test.index)


",HTML
131,"











nba-player-tracker
Screenshots
Installation
Usage
Contribute





README.md




nba-player-tracker

Track and compare player stats, news, and game logs.


Screenshots
      
Installation


Be sure to have React Native installed, as well as Android Studio & AVD.


Clone the repo., install dependenices.
$ git clone https://github.com/kshvmdn/nba-player-tracker.git
$ cd nba-player-tracker/NBAPlayerTracker
$ yarn install


Usage


I strongly suggest using this with an actual device if you can, but an emulator should work just as well.


With a device connected (or emulator running):
$ react-native run-android


Contribute
Have a request or find a bug? This project is completely open source, feel free to open an issue or submit a pull request.
The project uses a variety of tools (incl. Python 3, jq and cairosvg) to aggregate logo images and player data. This data is served from a public domain (http://nba.kshvmdn.com) and used within the application. If you're interested in local development, you generally shouldn't need to worry about this stuff though.


",JavaScript
132,"














Gameplay
Demo
Game Modes
Football
Volley
Basket
Abilities
Controls
AI
Specification
Trees Used
Football
Volley
Basket
Execution





README.md





An arcade 1v1 football(soccer)/volley/basket game (single or local multiplayer). It can be played online here. It was made using the Unity game engine.
Gameplay
The gameplay is straightforward: two players try to get the ball on the opposition's goal; the winner of the game is the one that reaches the goal limit first (if a limit was set).
Demo

Game Modes
There are three game modes available: football, volley and basket.
Football

Volley

There is a 7 second limit for how long the ball can be in the same area.
If the limit is exceeded, the other player scores a point.
Basket

Abilities
The game offers three different abilities:

Kick - kick the ball, with a specific power and direction;



Lift - lift the ball (90 degrees angle);



Stop - stop the ball;


Controls
Both the keyboard and the controller are supported, although the controller is recommended way to play. The input used can be changed in the 'Controls' menu.

The menu can be navigated both with the mouse and the keyboard/controller. The goal limit can be changed selecting the input field and entering the number or using the vertical keys (W,S,up,down,LB).
AI
The player's AI was implemented using the concept of decision trees. But instead of writing the functions and all the ifs/elses needed, it was used a YAML file to specify the tree. This file is then parsed by a Python script, that converts it to C# code. With this, the AI can be written faster (less boilerplate code) and it's easier to understand/manage.
Specification
A specification file has three main fields:

include - other specification files to include (relative path);
expressions - aliases for expressions to be used in the nodes' specification;
nodes - specification of the tree:

info - what the node does (to serve as documentation);
action - instructions to be executed before the decision is made (ex: setting variables);
decision - logic expression;
yes - nodes to execute (can be multiple) when the decision is true (or there is no decision);
no - nodes to execute (can be multiple) when the decision is false.



There are two dictionaries that must be provided to the tree:

state - the state of the game;
data - (empty) dictionary to set variables (to be used to pass the result and/or to use internally).

For example, let's say we want to create an AI that just follows the ball. The state provides us with the ball and the player's position. We could implement this AI like so (this could be simplified even further by having an action like data[""move""] = state[""playerPosX""] - state[""ballPosX""] < 0 ? 1 : -1, it's just a simple illustrative example):
expressions:
    # the expression is not needed, it's used just to make the code more readable
    left_of_ball: state[""playerPosX""] < state[""ballPosX""]

nodes:
    ROOT:
        info: Is the player to the left of the ball?
        decision: left_of_ball # or state[""playerPosX""] < state[""ballPosX""]
        yes: MOVE_RIGHT; SPRINT
        no: MOVE_LEFT; SPRINT

    MOVE_LEFT: data[""move""] = -1
    # same as
    # MOVE_LEFT:
    #    action: data[""move""] = -1

    MOVE_RIGHT: data[""move""] = 1

    # the SPRINT node could be a ROOT action, since it's simple and always used
    SPRINT: data[""sprint""] = 1
This results in the following tree (using the Assets/Scripts/AI/plot_specification.py script):

Trees Used
Football

Volley

Basket

Execution
The structure is converted in instructions that adds the nodes to a tree, starting with the leaves and ending with the root. In runtime, the game state is passed to the tree, as well as the data dictionary. The result is provided using the reference to the data.


",C#
133,"











Basketball Game
Unity3D + PSMove
Synopsis
Installation
API Reference
Contributors





README.md




Basketball Game
Unity3D + PSMove

Synopsis
This is an in-development Basketball game, where the player will be able to play using the Playstation PSMove Controller.
Installation
You can run this source code by downloading, and opening the main scene on any 5.x + version of the Unity3D engine.
API Reference
We are using the libpsmoveapi API and the UniMove Package for Unity.
Contributors
This project was created by me, Jonathan Prust Vernizzi and my friends Gustavo Vitorino and Gustavo Mendes.


",C#
134,"











Basketball detection
Evaluation of the model





README.md




Basketball detection
Authors: Michał Szachniewicz (szacho), Anna Klimiuk (Stardust87)
This project automates the process of extracting a basketball trajectory from a video. It saves results and creates a pretty visualization:


The algorithm used for object detection is YOLO, forked from https://github.com/ultralytics/yolov5. It has been trained on a custom dataset of privately recorded videos. The whole process is automated and it can handle a directory of videos one by one.
Evaluation of the model
The test set was created from two sceneries. Scenery 0 was present in a training set, but different recordings were used. Scenery 1 was completely new to the model. Every video was split into 4 categories:

in_hands - the ball is in or near the hands of a player
in_air - the ball was thrown and is in the air until it hits something
near_basket - the ball is close to the basket or even going through one (it can be occluded by a rim etc.)
bouncing - the ball is bouncing on the ground

Furthermore, an additional category custom was added and it consisted of different images from the internet to assure that the model can generalize well.  We evaluated the performance of the model on every scenery and category by intersection over union and distance error between (x_true, y_true) and (x_pred, y_pred) in pixel space.
Full results are available in the yolo_analysis notebook. In short: predictions are very accurate -- the average error in the distance for unseen scenery was equal to only 1.3px! That is comparable to human error.
Below are grouped per scenery and per category boxplots of IoU and distance error on the test set.




",Python
135,"











Shiny Scorekeeper
Installation





README.md





Shiny Scorekeeper
Shiny Scorekeeper is a basketball scorekeeper app built with the Shiny web framework for R. The app is a hobby project that I took on as a learning exercise. It is likely only of interest to a small subset of people building Shiny apps.
Installation

Install R
Install RStudio Desktop
Clone or download this repository
Open Shiny-Scorekeeper.Rproj
Run the following code to install required packages (only needs to be done once)

install.packages(c(""shiny"", ""shinydashboard"", ""shinyWidgets"", ""shinyjs"", ""DT"", ""dplyr"", ""tidyr""), dependencies = TRUE)


Run the following code to launch the app

shiny::runApp()

Instructions for how to use the app are found here. Background information about the app is found here.


",R
136,"











cxk超远距离投篮游戏
在线预览：cxk投篮





readme.md




cxk超远距离投篮游戏
在线预览：cxk投篮


",JavaScript
137,"














toRvik 
Package Installation
Package Highlights
Basic Uses
Pull T-Rank ratings:
Pull team statistics
Pull player statistics
Pull transfer histories
Pull recruiting rankings
Predict games and tournaments
Documentation
The Author





README.md





toRvik 





toRvik is an R
package for working with and scraping men’s college basketball.
There are a lot of college basketball data out there, but most are
difficult to pull and clean or they are behind a paywall. With toRvik,
you have immediate access to some of the most detailed and extensive
college basketball statistics publicly available – all returned in tidy
format with just a single line of code! Best of all, no subscription is
required to access the data.
Most of toRvik’s functions are powered by a dedicated Fast API
framework – delivering data at rapid speeds with dependable up-times.
As of version 1.0.3, the package includes nearly 30 functions for
pulling player and team data, game results, advanced metric splits,
play-by-play shooting, and more. Leveraging the same data and models as
Barttorvik, the package now offers game
and tournament predictor functions, allowing you to simulate games
between any pair of teams on any date at any venue back to the 2014-15
season. toRvik also offers extensive transfer histories for over 5,000
players back to the 2011-12 season and detailed player recruiting
rankings for over 6,000 players back to 2007-08.
Package Installation
Install the released version of toRvik from CRAN:
install.packages(""toRvik"")
Or install the development version from GitHub with:
if (!requireNamespace('devtools', quietly = TRUE)){
  install.packages('devtools')
}
devtools::install_github(""andreweatherman/toRvik"") 
Package Highlights

Detailed game-by-game + season-long statistics by player and split
Extensive transfer + recruiting histories
Custom game and tournament predictions
Shooting splits + shares by team
Game box scores for all D-1 games
Team + conference four factors by split
Game-by-game four factors
NCAA committee-style team sheets
D-1 head coaching changes

Basic Uses
All toRvik functions fall into one of six categories:

Rating, pulling and slicing T-Rank + four factor data
Player, pulling player data and histories
Team, pulling team statistics and histories
Game, pulling game-by-game data and schedules
Tournament, pulling raw and adjusted tournament performance
Miscellaneous

Pull T-Rank ratings:
Calling bart_ratings will return the current T-Rank ranks and ratings.
head(bart_ratings())
## ── Team Ratings: 2022 ────────────────────────────────────────── toRvik 1.1.0 ──

## ℹ Data updated: 2022-09-09 08:20:52 EDT

## # A tibble: 6 × 19
##   team     conf  barthag barth…¹ adj_o adj_o…² adj_d adj_d…³ adj_t adj_t…⁴   wab
##   <chr>    <chr>   <dbl>   <int> <dbl>   <int> <dbl>   <int> <dbl>   <int> <dbl>
## 1 Gonzaga  WCC     0.966       1  120.       4  89.9       9  72.6       5  6.71
## 2 Houston  Amer    0.959       2  117.      10  88.5       6  63.7     336  6.15
## 3 Kansas   B12     0.958       3  120.       5  91.3      13  69.1      71 10.4 
## 4 Texas T… B12     0.951       4  111.      41  85.4       1  66.3     223  6.57
## 5 Baylor   B12     0.949       5  118.       8  91.3      14  67.6     149  8.91
## 6 Duke     ACC     0.944       6  123.       1  96.0      53  67.4     161  7.19
## # … with 8 more variables: nc_elite_sos <int>, nc_fut_sos <dbl>,
## #   nc_cur_sos <dbl>, ov_elite_sos <int>, ov_fut_sos <dbl>, ov_cur_sos <dbl>,
## #   seed <dbl>, year <int>, and abbreviated variable names ¹​barthag_rk,
## #   ²​adj_o_rk, ³​adj_d_rk, ⁴​adj_t_rk

Pull team statistics
Calling bart_factors will return four factor stats on a number of
splits. To filter by home games, set venue to ‘home.’
head(bart_factors(location='H'))
## ── Team Factors ──────────────────────────────────────────────── toRvik 1.1.0 ──

## ℹ Data updated: 2022-09-09 08:20:52 EDT

## # A tibble: 6 × 22
##   team      conf  rating  rank adj_o adj_o…¹ adj_d adj_d…² tempo off_ppp off_efg
##   <chr>     <chr>  <dbl> <dbl> <dbl>   <dbl> <dbl>   <dbl> <dbl>   <dbl>   <dbl>
## 1 Houston   Amer    32.7     1  116.      15  83.0       1  66.1    117.    54.2
## 2 Gonzaga   WCC     29.7     2  120.       5  89.9      18  72.7    123.    60.1
## 3 Baylor    B12     28.8     3  116.       9  87.6       9  69.3    116.    55.0
## 4 Villanova BE      28.8     4  123.       2  94.0      50  63.2    122.    57.6
## 5 Purdue    B10     28.4     5  124.       1  96.0      81  67.9    125.    58.2
## 6 Auburn    SEC     27.6     6  115.      17  87.5       8  72.9    113.    53.1
## # … with 11 more variables: off_to <dbl>, off_or <dbl>, off_ftr <dbl>,
## #   def_ppp <dbl>, def_efg <dbl>, def_to <dbl>, def_or <dbl>, def_ftr <dbl>,
## #   wins <int>, losses <int>, games <int>, and abbreviated variable names
## #   ¹​adj_o_rank, ²​adj_d_rank

Calling bart_team_box will return team box totals and per-game
averages by game type. To find how Duke performed during the month of
March:
bart_team_box(team='Duke', split='month') |>
  dplyr::filter(month=='March')
## ── Team Stats ────────────────────────────────────────────────── toRvik 1.1.0 ──

## ℹ Data updated: 2022-09-09 08:20:53 EDT

## # A tibble: 1 × 39
##   team  month   min   pos   fgm   fga fg_pct   tpm   tpa fg3_pct   ftm   fta
##   <chr> <chr> <int> <int> <int> <int>  <dbl> <int> <int>   <dbl> <int> <int>
## 1 Duke  March  1800   599   270   518  0.521    63   176   0.358   118   149
## # … with 27 more variables: ft_pct <dbl>, oreb <int>, dreb <int>, reb <int>,
## #   ast <int>, stl <int>, blk <int>, to <int>, pf <int>, pts <int>,
## #   second_chance_pts <dbl>, second_chance_fgm <dbl>, second_chance_fga <dbl>,
## #   second_change_fg_pct <dbl>, pts_in_paint <dbl>, pts_in_paint_fgm <dbl>,
## #   pts_in_paint_fga <dbl>, pts_in_paint_fg_pct <dbl>, fast_brk_pts <dbl>,
## #   fast_brk_fgm <dbl>, fast_brk_fga <dbl>, fast_brk_fg_pct <dbl>,
## #   bench_pts <dbl>, pts_tov <dbl>, games <int>, wins <int>, losses <int>

Pull player statistics
Calling bart_player_season will return detailed season-long player
stats. To pull per-game averages for Duke players:
head(bart_player_season(team='Duke', stat='box'))
## ── Player Season Stats ───────────────────────────────────────── toRvik 1.1.0 ──

## ℹ Data updated: 2022-09-09 08:20:53 EDT

## # A tibble: 6 × 21
##   player      pos   exp   hgt   team  conf      g   mpg   ppg fg_pct  oreb  dreb
##   <chr>       <chr> <chr> <chr> <chr> <chr> <int> <dbl> <dbl>  <dbl> <dbl> <dbl>
## 1 Paolo Banc… Wing… Fr    6-10  Duke  ACC      39  33.0 17.2   0.513 1.77   6.05
## 2 Wendell Mo… Comb… Jr    6-5   Duke  ACC      39  33.9 13.4   0.513 1.21   4.05
## 3 Trevor Kee… Comb… Fr    6-4   Duke  ACC      36  30.2 11.5   0.422 0.833  2.61
## 4 Mark Willi… C     So    7-0   Duke  ACC      39  23.6 11.2   0.782 2.59   4.87
## 5 AJ Griffin  Wing… Fr    6-6   Duke  ACC      39  24.3 10.4   0.503 0.769  3.15
## 6 Jeremy Roa… Comb… So    6-1   Duke  ACC      39  29    8.62  0.412 0.359  2.05
## # … with 9 more variables: rpg <dbl>, apg <dbl>, tov <dbl>, ast_to <dbl>,
## #   spg <dbl>, bpg <dbl>, num <dbl>, year <int>, id <int>

Calling bart_player_game will return detailed game-by-game player
stats. To pull advance splits by game for Duke players:
head(bart_player_game(team='Duke', stat='advanced'))
## ── Player Game Stats ─────────────────────────────────────────── toRvik 1.1.0 ──

## ℹ Data updated: 2022-09-09 08:20:54 EDT

## # A tibble: 6 × 25
##   date        year player exp   team  conf  opp   result   min   pts   usg  ortg
##   <chr>      <dbl> <chr>  <chr> <chr> <chr> <chr> <chr>  <dbl> <dbl> <dbl> <dbl>
## 1 2021-11-09  2022 Theo … Sr    Duke  ACC   Kent… W         22     5  14.3  98.7
## 2 2021-11-12  2022 Theo … Sr    Duke  ACC   Army  W         15     0  11.9  18.1
## 3 2021-11-13  2022 Theo … Sr    Duke  ACC   Camp… W         10     0   1.9 236  
## 4 2021-11-16  2022 Theo … Sr    Duke  ACC   Gard… W         15     4  19.1 100. 
## 5 2021-11-19  2022 Theo … Sr    Duke  ACC   Lafa… W         17     4  12.2 122. 
## 6 2021-11-22  2022 Theo … Sr    Duke  ACC   The … W         16     8  11.6 207. 
## # … with 13 more variables: or_pct <dbl>, dr_pct <dbl>, ast_pct <dbl>,
## #   to_pct <dbl>, stl_pct <dbl>, blk_pct <dbl>, bpm <dbl>, obpm <dbl>,
## #   dbpm <dbl>, net <dbl>, poss <dbl>, id <dbl>, game_id <chr>

Pull transfer histories
Calling transfer_portal will return transfer histories with matching
player IDs to join with other statistics. To find all players who
transferred to Duke:
head(transfer_portal(to='Duke'))
## ── Transfer Portal ───────────────────────────────────────────── toRvik 1.1.0 ──

## ℹ Data updated: 2022-09-09 08:20:54 EDT

## # A tibble: 6 × 11
##      id player        from  to    exp    year imm_e…¹ source from_d1 to_d1 sit  
##   <int> <chr>         <chr> <chr> <chr> <int> <chr>   <chr>  <lgl>   <lgl> <lgl>
## 1 65776 Kale Catchin… Harv… Duke  Sr     2023 Yes     Josep… TRUE    FALSE NA   
## 2 66209 Ryan Young    Nort… Duke  Jr     2023 Yes     Jeff … TRUE    FALSE NA   
## 3 65826 Max Johns     Prin… Duke  Sr     2023 Yes     <NA>   TRUE    FALSE NA   
## 4 50593 Theo John     Marq… Duke  Sr     2022 Yes     <NA>   TRUE    TRUE  FALSE
## 5 51179 Bates Jones   Davi… Duke  Sr     2022 Yes     <NA>   TRUE    TRUE  FALSE
## 6 45926 Patrick Tape  Colu… Duke  Sr     2021 Yes     Evan … TRUE    TRUE  TRUE 
## # … with abbreviated variable name ¹​imm_elig

Pull recruiting rankings
Calling player_recruiting_rankings will return extensive recruit
histories with matching player IDs. To find all 5-star players who
played high school basketball in North Carolina:
head(player_recruiting_rankings(stars=5, state='NC'))
## ── Recruiting Rankings ───────────────────────────────────────── toRvik 1.1.0 ──

## ℹ Data updated: 2022-09-09 08:20:55 EDT

## # A tibble: 6 × 31
##   position player  height weight team  conf  high_…¹ town  state tfs_c…² tfs_c…³
##   <chr>    <chr>   <chr>   <dbl> <chr> <chr> <chr>   <chr> <chr>   <dbl>   <int>
## 1 SF       Patric… 6-6       215 Flor… ACC   West C… Char… Nort…    99.1       5
## 2 PG       Devon … 6-2       185 Kans… B12   Provid… Char… Nort…    99.3       5
## 3 SF       Jaylen… 6-8       215 Wake… ACC   Wesley… High… Nort…    99.3       5
## 4 SG       Coby W… 6-5       185 Nort… ACC   Greenf… Wils… Nort…    99.1       5
## 5 PF       Harry … 6-10      240 Duke  ACC   Oak Hi… Wins… Nort…   100.        5
## 6 PG       Dennis… 6-3       190 Nort… ACC   Trinit… Faye… Nort…    99.7       5
## # … with 20 more variables: tfs_comp_national <dbl>, tfs_comp_position <dbl>,
## #   tfs_comp_state <dbl>, tfs_rating <dbl>, tfs_star <int>, espn_rating <dbl>,
## #   espn_grade <dbl>, espn_rank <dbl>, rivals_rating <dbl>, rivals_rank <dbl>,
## #   avg_rank <dbl>, num_offers <int>, announce_date <chr>, tfs_cb <chr>,
## #   tfs_cb_odds <dbl>, tfs_cb_alt <chr>, tfs_cb_alt_odds <dbl>, tfs_pid <int>,
## #   year <int>, id <int>, and abbreviated variable names ¹​high_school,
## #   ²​tfs_comp_rating, ³​tfs_comp_star

Predict games and tournaments
Calling bart_game_predictions will returns expected points,
possessions, and win percentage for a given game on a given date. To
simulate North Carolina at Duke in mid-January:
bart_game_prediction('Duke', 'North Carolina', '20220113', location = 'H')
## ── Duke vs. North Carolina Prediction ────────────────────────── toRvik 1.1.0 ──

## ℹ Data updated: 2022-09-09 08:20:55 EDT

## # A tibble: 2 × 8
##   team           date          location tempo   ppp   pts win_per did_win
##   <chr>          <chr>         <chr>    <dbl> <dbl> <dbl>   <dbl> <lgl>  
## 1 Duke           Jan. 13, 2022 Home      73.4  1.15  84.2    73.1 TRUE   
## 2 North Carolina Jan. 13, 2022 Away      73.4  1.02  75.1    26.9 FALSE

Calling bart_tournament_prediction will simulate a single-elimination
tournament between a group of teams on a given date. To simulate the
2022 Final Four 25 times:
bart_tournament_prediction(teams = c('Duke', 'North Carolina', 'Kansas', 'Villanova'), '20220402', sims = 25, seed = 10)
## ── Tournament Prediction: 25 Sims ────────────────────────────── toRvik 1.1.0 ──

## ℹ Data updated: 2022-09-09 08:20:56 EDT

## # A tibble: 4 × 4
##   team            wins finals champ
##   <chr>          <int>  <int> <int>
## 1 Duke              31     21    10
## 2 Kansas            17     10     7
## 3 Villanova         21     15     6
## 4 North Carolina     6      4     2

Documentation
For more information on the package and its functions, please see the
toRvik reference.
The Author
Andrew Weatherman



",HTML
138,"











🏀 Basketball
What is Basketball?
How does it look?
Is there a full list of features?
Credit
License





README.md




🏀 Basketball
A self-hosted Dribbble Playbook alternative







What is Basketball?
Basketball is a self-hosted alternative to the quite pricey Dribbble Playbook. Playbook is a portfolio site which automatically displays your Dribbble Shots, and that's what Basketball can also do! It's easier than manually uploading all your shots to a portfolio site, and also it just looks cool to have a custom portfolio with a custom domain. Of course, Basketball is hackable, so you can create your own themes or do more with the Dribbble API.
How does it look?

Live preview available at https://demo.usebasketball.com











Is there a full list of features?
Yes there is:

 🔗 Custom domain support (Connect your own domain, like example.com)
 ⚡️ Fast loading times (Thanks to Dribbble request caching with custom cache expiry)
 📸 Dribbble synchronization (Basketball automatically fetches your Dribbble posts)
 ✨ Great design (Basketball's design is minimalistic yet functional)
 ⚙️ Extensible (Make your own themes and add functionality)
 📦 Easy to install (Basketball is super easy to install and doesn't need to be maintained)
 💸 Save money (You can host Basketball for free when using Deta - Don't pay $12 /month for Dribbble's Playbook!)
 🏀 Open Source (Basketball is maintained by contributors on GitHub - The source code is public)



  What are you waiting for?



Credit
Made possible by FastAPI. Thanks for making such an awesome framework ❤️
License
Basketball: A self-hosted Dribbble Playbook alternative
Copyright (C) 2022 berrysauce (Paul Haedrich)
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
For legal questions, contact legal[at]berrysauce[dot]me.



",HTML
139,"











Rotowire-modified
Data
Statistic of the datasets
Format
Usage





README.md




Rotowire-modified
Script for generating the rotowire-modified dataset for Learning to Select, Track, and Generate for Data-to-Text (Iso et al; ACL 2019).
Data
This script generates the dataset ""rotowire-modified"" by extracting required data from the original rotowire dataset.
We are not allowed to distribute the dataset itself due to the copyright issue, so we distribute only the script.
The new dataset generated by this script is almost the same as, but not identical to the dataset used in the paper (Iso et al; ACL 2019).
ACL's dataset contains 14 games that do not appear in the original rotowire and have to be obtained from https://www.rotowire.com and https://www.nba.com.
Further information of the 14 games is listed in additional_games.txt.
In addition, there are a number of slight differences in data records due to the update of the original pages.
For empirical comparison by other researchers, we also distribute the experimental result on this new rotowire-modified dataset at the sports-reporter repo.
Statistic of the datasets



Data
Train
Validation
Test
Total




rotowire (Wiseman'2017)
3398
727
728
4853


rotowire-modified (Iso et al; ACL 2019)
2714
534
500
3748


rotowire-modified (This repo)
2705
532
497
3734



Format
Since this script simply removed duplicate records from the original dataset, the data format is the same as that of the original rotowire dataset.
Please refer to boxscore-data repo.
Usage
You can download the original dataset (Wiseman'2017) from the boxscore-data repo,
and then, transform it as bellow.
The script will create a directory ""rotowire-modified"", which contains train.json, valid.json, and test.json files.
DATA_PATH=<path to the locally downloaded original dataset>
python script/generate_rotowire_modified.py --src_dir $DATA_PATH



",Python
140,"











NBA Predictive Analytics
How It Works
Stephen Curry Shooting Analysis
Kevin Durant Shooting Analysis
How Did We Do?





README.md




NBA Predictive Analytics
As Fall 2017 Exam Season reaches its climax, I did what any other university student would do - make a side project!
From any NBA match, you can tell that many basketball players have a unique style of play. We have players like Stephen Curry and Kyrie Irving dominating the 3-point range or like LeBron James and Russell Westbrook who devastate their opponents near the rim.
But avid NBA fans know these characteristics out of instinct after watching the NBA for weeks, months, maybe even years. I wanted to find a concrete method of arriving at these conclusions. This led me to create a Python program which analyzes any current NBA player's gameplay to find which areas of the court they have most shooting success and the probability of shooting from certain spots. With this analysis, it can allow coaches and players to know their opponents gameplay and can show them which areas of the court to prioritize their defense.

How It Works
Using datasets from Kaggle (formatted with Pandas), we can use Matplotlib to illustrate our data analysis. This dataset includes every shot taken in the 2016-2017 Regular Season so any player who played a game during this season can be analyzed. By incorporating machine learning through Python's Scikit-Learn (using a K-Nearest Neighbours Classifier) we can also simulate a player's shooting from every position on the court.
I incorporated multiple methods of analyzing shooting habits so let's take a look!
Stephen Curry Shooting Analysis

Let's start off with the two time MVP from the Golden State Warriors, Stephen Curry. In this plot, the green dots represent scoring shots while the red dots represent missed shots. The black dots represent spots that Curry is most likely to shoot from. The size of the dots represent the relative probability of Curry shooting from that position and the darkness of the dot illustrates his shot accuracy from that spot (with darker shades representing a higher accuracy).
However, the black dots are a bit hard to see because of the green and red dots, so let's simplify the plot.

So how did we do? Our plot says that Curry is most likely to shoot from very close range (at layup distance) or from the 3-point range. Any NBA fans can verify the accuracy of this prediction since Curry is known for his 3-point shooting and his ability to rush past defenders for layups.
For our next analysis let's change things up and take a look at another player - Curry's teammate, Kevin Durant.
Kevin Durant Shooting Analysis

In this analysis we are incorporating machine learning by using a Decision Tree to simulate Kevin Durant's shooting throughout the court. With this analysis we have a more uniform distribution for our analysis so we can predict how Durant will shoot based on his past shooting habits. In this plot, the green dots represent scoring shots and the red dots represent missed shots.
From this analysis we can determine that Durant is more dominant on the right side of the court (which is the case for right-handed players). He also is predicted to score with high consistency throughout the key and around the 3-point perimeter - another prediction which is confirmed by his known playing style.
But we can take this one step further, let's compare Kevin Durant's shooting to the average NBA player.

Similar to how we simulated Kevin Durant's shooting with machine learning, we can use the data for all NBA players in the 2016-2017 Regular Season to find the shooting habits of the average NBA player. In this plot, green dots represent shots that Durant made but the NBA average player missed (meaning Durant is above average shooting at this positions). In contrast, the red dots represent shots that Durant missed but the average player scored (meaning Durant is below average at these spots). Additionally, the yellow dots represent neutral areas where both Durant and the average player scored or missed.
From the plot, we can see that Durant is above average in the majority of the court. He dominates shooting throughout the key and around the 3-point range - once again aligning with his known game style.
How Did We Do?
Overall, our predictive models can predict NBA players' shooting habits with a high degree of effectiveness as seen from the analysis on Curry and Durant. We can determine exactly which areas a player is above average at shooting and which they are below. We can also predict where they are most likely to shoot from and their accuracy from these positions. With this data, NBA coaches can plan defense strategies with much higher precision.
Try it out with your favourite NBA players!



",Python
141,"











rfeb
Installation
Examples





README.md




rfeb
rfeb provides a set of tools for scraping and analyzing basketball data from Spain's FEB leagues.
Installation
# install.packages(""devtools"")
devtools::install_github(""solmos/rfeb"")
Examples
library(rfeb)
library(ggplot2)
game_ids <- 2010208:2010216
shots <- extract_shots(game_ids)
plot_shotchart(shots, color = made) +
    facet_wrap(~game_id)



",R
142,"











balldontlie-client
API Implementation Status
Install
Usage
Example with for-await-of
Example with .next()





README.md




balldontlie-client



Javascript client for Balldontlie.
API Docs for this client can be found here.

API Implementation Status



API
Status




Players
✅


Teams
✅


Games
✅


Stats
✅


Season Averages
✅



Install
npm i @jharrilim/balldontlie-client
Usage
This library uses async generators for handling pagination. You may use this in conjunction with
for-await-of
to make multiple API requests. You may also request for one page at a time by awaiting .next().
Axios is used interally, and axios configuration options may be passed into .v1() if needed.

Warning: This API is rate limited. You may only make up to 60 requests per minute.

Example with for-await-of
import { BallDontLie } from '@jharrilim/balldontlie-client';

void async function main() {
    const v1Client = BallDontLie.v1();
    for await(const teams of v1Client.teams(0)) {
        // paginate through all the teams
        for(const team of teams) {
            console.log(team.full_name);
        }
    }
}().catch(console.error);
Example with .next()
import { BallDontLie } from '@jharrilim/balldontlie-client';

void async function main() {
    const v1Client = BallDontLie.v1();
    const teamGenerator = v1Client.teams(0, 10); // starting from 0, 10 per page
    
    const teams1 = (await teamGenerator.next()).value; // get the first 10 teams
    teams1.forEach(team => console.log(team.full_name));

    const teams2 = (await teamGenerator.next()).value; // get the next 10 teams after the first 10
    teams2.forEach(team => console.log(team.full_name));

}().catch(console.error);
More examples can be found in the tests.


",TypeScript
143,"



README.md




kinect-basketball-spinner
Basketball Spinner using Kinect v2 and Unity3D. Augmented Reality App.


",C#
144,"











Basketball-Analytics
Requirements
Step 1: Scrapping the data





README.md




Basketball-Analytics
Analytics with NBA player salaries with data from basketball-reference.com. This is part of IS5126: Hands on with Business Analytics
Requirements

Python 2.7
BeautifulSoup 4.0
SQLite 3

Step 1: Scrapping the data
To scrap the data from basketball-reference.com run the following scripts

py player_crawler.py : To extract the information about the players. The starting URL is http://www.basketball-reference.com/players/. The output is generated as csv files data/player_basic_profile_info.csv and data/player_stats.csv
py team_crawler.py : To extract the team information and player salaries. The starting URL is http://www.basketball-reference.com/teams/. The output csv files are data/player_salary.csv, data/team_basic_profile_info.csv and data/player_stats.csv



",Python
145,"











Scripts for Yahoo fantasy basketball
Install dependencies
Activate virtualenv (if not already done)
Authentication
Start active players
Usage examples with output
Project matchup





README.md




Scripts for Yahoo fantasy basketball
Install dependencies
$ virtualenv venv
$ . venv/bin/activate
$ pip install -r requirements.txt

Activate virtualenv (if not already done)
$ . venv/bin/activate

Authentication
Set Yahoo credentials in the YAHOO_USERNAME and YAHOO_PASSWORD environment variables.
Start active players
$ python start_active_players.py <league_id> <team_id> <date (default: today, format: YYYY-MM-DD)> <num_days (default: 1, max: 100)>

Usage examples with output
Start active players for the next week:
$ python start_active_players.py 847591 8 8
Superteams League - Lamarc Gasolridge's Team:

- Sat, Feb 07, 2015: Started active players
    - Alternate: Gerald Henderson (Cha - SG,SF) [@Phi]
- Sun, Feb 08, 2015: Started active players
- Mon, Feb 09, 2015: Started active players
- Tue, Feb 10, 2015: Started active players
- Wed, Feb 11, 2015: Started active players
- Thu, Feb 12, 2015: Started active players
- Fri, Feb 13, 2015: Started active players
- Sat, Feb 14, 2015: Started active players

Start active players for the week starting with March 3, 2015:
$ python start_active_players.py 847591 8 2015-03-03 7
Superteams League - Lamarc Gasolridge's Team:

- Tue, Mar 03, 2015: Started active players
- Wed, Mar 04, 2015: Started active players
- Thu, Mar 05, 2015: Started active players
- Fri, Mar 06, 2015: Started active players
    - Alternate: DeMarcus Cousins (Sac - PF,C) [@Orl]
    - Alternate: Dennis Schroder (Atl - PG) [Cle]
- Sat, Mar 07, 2015: Started active players
- Sun, Mar 08, 2015: Started active players
- Mon, Mar 09, 2015: Started active players

Project matchup
$ python project_matchup.py <league_id> <team_id>



",Python
146,"











schneiderman
Installation
Project Structure
Executables
Code
schneiderman/:
Data





README.md




schneiderman
Predictive analytics for daily fantasy basketball.
Installation
pip install -r requirements.txt
Project Structure
Executables
Code
The python code is contained within the schneiderman module.
Any executable files (python or otherwise) are within bin/.
schneiderman/:

scrape/ Various data scrapers.
models/ Persistent storage for scraped and processed data.
regresssion/ The linear modeling tools used on the gathered data to predict weekly scores.
lineup/ Randomized algorithm used in generating lineups from predicted weekly scores.

Data

static Static data.  Supports analysis, changes infrequently, fetched manually.
data/ The user local data folder.  Used for temporary storage of pipeline
stage data.  Ignored by git.

data/clean Output data from bin/clean.
data/scrape Output data from bin/scrape
data/games Output data from bin/load_games
data/train Output data from bin/train
data/predict Output data from bin/predict
data/lineup Output data from bin/lineups





",Python
147,"














Basketball-Action-Recognition
Motivation
Action/Video Classification
Dataset
Augmentations
Rotate
Translate
Training
Checkpointing
Validation and Evaluation
Confusion Matrix
Test on Training and Validation Set
Testing on the 10% of the leftover data.
Inference Examples - Error Analysis
Player Tracking
Output
Future Additions
Credits





README.md




Basketball-Action-Recognition
Spatio-Temporal Classification of 🏀 Basketball Actions using 3D-CNN Models trained on the SpaceJam Dataset.
LeBron shooting over Deandre Jordan

Live Example

Motivation
Utilizing the SpaceJam Basketball Action Dataset Repo, I aim to create a model that takes a video of a basketball game to classify a given action for each of the players tracked with a bounding box. There are two essential parts for this program: R(2+1)D Model (Can be any 3D CNN architecture) and the player tracking. The deep learning framework used to train the network was PyTorch and the machine used to train the model was the Nvidia RTX 3060ti GPU.
This is a demo video from the SpaceJam Repo.
Demo Video
Action/Video Classification
A pretrained baseline R(2+1)D CNN (pretrained on kinetics-400 dataset) from torchvision.models is used and further fine-tuned on the SpaceJam dataset. Any 3D CNN architecture can be used, but for this project it was decided that the R(2+1)D was a perfect balance in terms of number of parameters and overall model performance. It was also shown in the paper that factorizing 3D convolutional filters into separate spatial and temporal dimensions, alongside residual learning yields significant gains in accuracy. The training was done at train.py.
Dataset
As mentioned above, the SpaceJam Basketball Action Dataset was used to train the R(2+1)D CNN model for video/action classification of basketball actions. The Repo contains two datasets (clips->.mp4 files and joints -> .npy files) of basketball single-player actions. The size of the two final annotated datasets is about 32,560 examples. Custom dataloaders were used for the basketball dataset in the dataset.py.

Augmentations
After reading the thesis Classificazione di Azioni Cestistiche mediante Tecniche di Deep Learning, (Written by Simone Francia) it was determined that the poorest classes with examples less than 2000 examples were augmented. Dribble, Ball in Hand, Pass, Block, Pick and Shoot were among the classes that were augmented. Augmentations were applied by running the script augment_videos.py and saved in a given output directory. Translation and Rotation were the only augmentations applied. After applying the augmentations the dataset has 49,901 examples.
Rotate

Translate

Training
The training was done at train.py. The training was run for 25 epochs and with a batch size of 8. The model was trained with the classic 70/20/10 split. Where 70% of the data was use to train and 20% was used to validate the model. And, the rest of the 10% was used in the inference to test the final model. It was found that a learning rate of 0.0001 was better than a learning rate of 0.001.
Checkpointing
Both history and checkpointing is done after every epoch with checkpoints.py in the utils directory.
Validation and Evaluation
The final model was a R(2+1)D CNN trained on the additional augmented examples. For validation on the test set, the model at epoch 19 was used as it was the best performing model in terms of validation f1-score and accuracy. The model performs significantly better than the reported 73% in the thesis Classificazione di Azioni Cestistiche mediante Tecniche di Deep Learning, acheiving 85% for both validation accuracy and test accuracy. The confusion matrix was attained using the inference.py code. Further analysis on predictions and errors is done on error_analysis.ipynb notebook.
Confusion Matrix
- 0: Block, 1: Pass, 2: Run, 3: Dribble, 4: Shoot, 5: Ball in Hand, 6: Defence, 7: Pick, 8: No Action, 9: Walk
Test on Training and Validation Set

Testing on the 10% of the leftover data.

Inference Examples - Error Analysis



State
Shooting
Dribble
Pass
Defence
Pick
Run
Walk
Block
No Action




True











False












Player Tracking
All player tracking is done in main.py. Players are tracked by manually selecting the ROI using the opencv TrackerCSRT_create() tracker. In theory, an unlimited amount of people or players can be tracked, but this will significantly increase the compute time. In the example above only 2 players, LeBron James (Offence) & Deandre Jordan (Defence) were tracked. A simple example of player tracking is available in Basketball-Player-Tracker.
Output
After extracting the bounding boxes from TrackerCSRT_create(), a cropped clip of 16 frames is used to classify the actions. The 16 frame length clip is determined by the vid_stride (Set to 8 in the example video above) which is set in the cropWindows() function in main.py. Within the cropped window time frame the action is displayed on top of the bounding boxes to show the action of the tracked player.
Future Additions

Separate augmented examples from validation and only in training.
Utilize better player tracking methods.
Restrict Box size to 176x128 (Or with similar Aspect Ratio), so resize of image is not applied.
Fully automate player tracking. Potentially using YOLO or any other Object Detection Models.
Play around with hyperparameters such as learning rates, batch size, layers frozen, etc.
Try various 3D-CNN Architectures or sequential models such as CONV-LSTMs.
Improve model to +90% accuracy and f1-score.

Note:

The Model does not perform well with off-ball actions for some reason. Often times, the defender is classified to be dribbling when they are not. This might be because of the similarity of the stance while dribbling the ball and playing defence. For both movements, players generally lower their torsos forward in order to lower their centre of gravity.

Credits
Major thanks to Simone Francia for the basketball action dataset and paper on action classification with 3D-CNNs.


",Python
148,"



README.md




GBA-Audio-Basketball-Game
I found a way to play audio clips on the Game Boy Advance.
This has several thing to help teach you how to make a simple game.
Check out my YouTube channel too! www.youtube.com/c/3dsage


",C
149,"











Project: College Basketball Final Four Prediction
Project Goal
Dataset Information:
Tech Stack
Featured ML Algorithms
Things to Note





README.md




Project: College Basketball Final Four Prediction
Project Goal
Analyze basketball metrics of different college basketball teams and predict which teams can make it to the NCAA Final Four.
Dataset Information:
This dataset is about the performance of basketball teams. The cbb.csv data set includes performance data about five seasons of 354 basketball teams.
Tech Stack
Python
Jupyter Notebook
NumPy
Pandas
Matplotlib
Scikit-learn
IBM Watson Studio
Featured ML Algorithms
K-Nearest Neighbors (KNN)
Decision Tree
Support Vector Machines (SVM)
Logistic Regression
Things to Note
This Jupyter Notebook is also hosted on IBM Watson Studio


",Python
150,"











Basket & Ball
Website: https://basketball.projects.thearnav.dev/





README.md





Basket & Ball
The Game of Baskets And basketballs. Collect balls and earn points. Play and Share with your friends.







Website: https://basketball.projects.thearnav.dev/
​



",C#
151,"











Haxe GameCircle
Features
Install
Usage





README.md




Haxe GameCircle
Unofficial Amazon GameCircle 2.x leaderboards and achievements support for OpenFL Android target.
Deprecation note. GameCircle has been deprecated, and so are these Haxe support bindings.
Features
Supports:

GameCircle sign-in.
Showing leaderboards and achievement popover screens.
Submitting leaderboard scores, unlocking and updating achievement progress.
React to player login or logout with a custom listener.

Doesn't Support:

iOS target.
Whispersync.
Fetching leaderboard/achievement/player data from the Amazon servers.

If there is something you would like adding let me know. Pull requests welcomed too! Here it is in action:

Install
haxelib install samcodes-gamecircle
Usage
Project.xml
<haxelib name=""samcodes-gamecircle"" />

<!-- Add your GameCircle API key. Refer to the Amazon documentation:
https://developer.amazon.com/public/apis/engage/gamecircle/docs/create-a-gamecircle-configuration#Generate API Keys
-->
<template path=""android/debug_gamecircleapikey.txt"" rename=""assets/api_key.txt"" if=""debug"" />
<template path=""android/release_gamecircleapikey.txt"" rename=""assets/api_key.txt"" unless=""debug"" />
Example usage:
// Your wrapper of the GameCircle leaderboards functionality
class GameCircleLeaderboards {
	public static var get(default, never):GameCircleLeaderboards = new GameCircleLeaderboards();
	
	private var leaderboards:GameCircle;
	
	private function new() {
		leaderboards = new GameCircle();
	}
	
	public function setListener(listener:GameCircleListener):Void {
		leaderboards.setListener(listener);
	}
	
	public function openLeaderboard(id:String):Void {
		leaderboards.games.showLeaderboard(id);
	}
	
	public function openAchievements():Void {
		leaderboards.games.showAchievements();
	}
	
	public function isSignedIn():Bool {
		return leaderboards.games.isSignedIn();
	}
	
	public function signIn():Void {
		leaderboards.games.showSignInPage();
	}
	
	public function submitScore(id:String, score:Int):Void {
		leaderboards.games.submitScore(id, score, """");
	}
	
	public function updateAchievementProgress(id:String, percent:Float):Void {
		leaderboards.games.updateAchievement(id, percent, """");
	}
	
	public function setPopUpLocation(location:PopUpLocation):Void {
		leaderboards.games.setPopUpLocation(location);
	}
}

// Your game
class MyGame {
	public var leaderboards:GameCircleLeaderboards;
	
	public function create():Void {
		leaderboards = GameCircleLeaderboards.get;
		leaderboards.setPopUpLocation(PopUpLocation.TOP_CENTER);
		
		if (!leaderboards.isSignedIn()) {
			leaderboards.signIn();
		}
	}
	
	public function onLevelEnd() {
  		if (leaderboards.isSignedIn()) {
  			// Create your leaderboards and achievements and set their ids through the Amazon developer console
  			leaderboards.submitScore(""my_leaderboard_id"", 1000);
			leaderboards.updateAchievementProgress(""my_achievement_id"", 50); // 50% complete
			leaderboards.updateAchievementProgress(""my_other_achievement_id"", 100); // Unlocks/100% complete
  		}
	}
}


",Haxe
152,"














Play by Play
Install
Test
Simulate a single game
Development
Tech stack
Model
Terminology
Redux
System
States
Simulation
Markov
Old game





README.md




Play by Play
Ruby basketball simulation. Partial recreation of a BASIC college basketball simulation I wrote in the 1980s. Inspired by discussion about The Hot Hand in Basketball: On the Misperception of Random Sequences: ""Kobe Bryant shooting a basketball is essentially flipping a coin."" Given seasons of NBA data, I can model those coin flips.
The project reads NBA play-by-play game files and builds a probability distribution. It uses the probability distribution and a model to simulate games. There is also a web app to browse imported data.
Game simulation is very simple. There is a ""home"" team and a ""visitor"" team, each with exactly equal chances, league-average to make field goals, block shots, etc. There isn't even the concept of players, yet! Even this simulation is interesting: given two perfectly-matched teams, ~10% of games are 20-point blowouts. Maybe there's more than coin-flipping going on? An entire simulated season routinely produces at least one 50-win team and one 33-win team.
Install

On OS X, just run bin/setup
Install Ruby, node.js
Postgres
gem install bundler
bundle
cd web; npm install; npm run dist:dev

Test
rspec
Simulate a single game
rake
This Rake task also populates the probability distribution from three sample games in spec/data.
Development
rake spec:fast runs all specs, skipping any that rely on the database or web server
rake import:game imports a single game. Use rake parse:game to check parsing logic without saving the results.
See the Rakefile for options and other Rake tasks.
rackup to run the web app and browse http://localhost:9292/ to view import errors.
Database: psql play_by_play_development
Tech stack
Ruby 2.5 with minimal gems
Sinatra for web API
React for frontend web UI
Postgres
Model
The model and simulation borrows concepts from finite-state machines, Markov chains, Redux and Monte Carlo simulations.
Games are modeled as state machines. State is described by a small number of attributes (is the ball in play?, which team has the ball?, what period is it?, are free throws pending?). Each state has a set number of valid transitions to other states. Each transition also has a probability.
Taken together, a game is a chain of game states. This is, more or less, a Markov model and a Markov chain. See Markov below.
Terminology
Each game state is a Ruby Possession class. Each transition between Possessions is a Play. A Simulation::Game is a chain of Possessions.
A Game is a store of immutable Possessions and Plays. Each Play is a state transition that produces a new Possession. A new Possession can only be created by a Play.
In state machines, plays could also be considered actions or events. ""Possession"" is  nebulous in common usage. Here, it could also have been called a ""game"" or ""game state"".
The probability distribution is the probability that a transition (Play) will occur given a game state (Possession). It could also be called a transition matrix or a conditional probability distribution.
Only some transitions are valid from certain states. For example, steals can never occur when free throes are pending. All states are valid from each other. They are all ""accessible"" Markov states.
In some places, it is easier to express plays and possessions with symbols. For example: { ball_in_play: true, team: :home } => [ :turnover ] => { ball_in_play: true, team: :visitor }
Redux
While not strictly a Redux app, the simulation uses the reducer, state, and action ideas from Redux. Possessions are immutable Redux states, Plays are actions, and the GamePlay play! method is a reducer. GamePlay.play!(possession, play) => possession is equivalent to Redux's function(previousState, action) => newState.
A Play is a record of an ""applied"" action, either from a real-world sample or a simulation. The Play key (:rebound, team: :defense) is the Redux action.
This is a handy way to model basketball games that leads to concise, testable model code.
System
The larger system accepts play-by-play JSON files as input and outputs Simulation::Game.
Input: historical state transitions. Output: chain of states
Modules:

Sample. Import JSON files from real world games.
Model. Abstract model of basketball game.
Simulation. Use probabilities from Sample to run Model to simulation a game or season of games.
View. Display Simulation output as text.
Web. Web UI.

Many modules have duplicate names (Game, Team), but these duplicates are different, though related concepts. Mixing those concepts makes for confusing code.
States
Possessions are game states at a point in time. Game state can be considered essentially infinite. Every combination of players, time remaining, score, fouls, etc. can produce different transition probabilities.
However, to model what is possible is much more finite. The model uses just:

ball in play?
team has possession?
pending free throws?
pending technical free throws?

Taken in order, the states are exclusive, so game state can be reduced in PlayMatrix to just: technical free throws?, free throws?, team?, ball in play?, any time remaining?.
Games could be modeled as several concurrent game state machines. One each for possession, FTs, etc., but that isn't helpful in practice.
Simulation
The simulation is inspired by the Monte Carlo method, but isn't really a Monte Carlo simulation. It could be considered a Monte Carlo generator run once. (And could be run multiple times to be a true Monte Carlo simulation).
The RandomPlayGenerator is a ""roulette wheel"". The model determines which slots (plays) are on the wheel. Historical sample data determines the width of those slots. Similar to log5.
Markov
Markov models and chains help build a game model, but they are tools for predicting the probability of future states, not for simulations. This simulation care about the type of transition for counting stats like points, field goals made, assists, and more.
Our model also has multiple transitions from two states. Typical Markov examples only have one transition between two states, because only the probability matters. Matrices also aren't very useful here, though there are good applications for baseball strategy.
Old game
The old BASIC game had a text box score and a scrolling play-by-log. Similar to what you might hear on the radio or view on nba.com. ""Coaches"" playing the game could sub players in and out, assign position, defensive assignments, and choose basic strategy (offense, defense, rebound, steals, set picks, pass).
First steps on the new simulation are to build a solid game model and feed it good data. With that in place, it should be possible to make a playable simulation.


",Ruby
153,"











Basketball-Analytics
Background
Research Question
Model Methodology
Addtional Functionality
Codes
Demo





README.md




Basketball-Analytics
Investigated quantitatively the optimal body mechanics for shooting basketball by employing pose estimation and sports theory.
Background
If there is one thing that I wish I had learned earlier in my ten years of experience in basketball, it is shot mechanics.
Too often, when training for better performance, beginners put too much emphasis on the drills: ""I should complete 80 behind-the-back dribbles, 100 free throws, 50 three-pointers, etc."" Focusing on the drills usually means very little attention paid to their body mechanics during the moves. How much should I bend my knees? Should I contract my glute first or quad first?
As a wise man once observed, ""form before strength,"" which means one should priortize body mechanics over brute force in most skill-intensive sports.  The attention to details and mind-muscle connection is often what sets professional players apart from street hoopers. But how can we learn from those superstars? What's the secret magic that helps them optimize their forms to achieve longer shooting range and higher explosiveness?
Though there are rule-of-thumbs about shooting forms, little quantitative work has been done regarding the underlying body mechanics. By employing pose estimation and sports theory, this project aims to unscramble to myth behind optimal shot mechanics in basketball.
Research Question
Different key muscle groups are activated at different time intervals when a player shoots.
What's the optimal timing and order for activating these muscle groups?
Model Methodology

Use the mediapipe API to obtain the locations of each joint (e.g. ankle, knee, hip)
Connect neighbouring joints to model limbs (e.g. connecting hip and knee gives the line representing thigh)
Compute the angular acceleration at each joint using the limbs stemming from it (e.g. the rotational movement thigh and lower leg determines the angular acceleration at knee)
Estimate the activation of a specific muscle group using angular acceleration at the corresponding joint (e.g. glute corresponds to hip). This follows from the angular part of Newton's Second Law (angular acceleration proportional to torque)

Addtional Functionality

Produce a graph describing the player's shot mechanics as muslce activation vs. time
Evaluate the efficiency of the shot as a score
Give suggestions on how to improve the shot mechanics

Note: the speed and acceleration are in relative terms, scaled for comparision across players
Codes
The AnalyzerModule.py file wraps an Analyzer class, the instance of which can be used to analyze a video of a player shooting.
The pipeline.py file applies Analyzer to produce i) a slow-motion video tracking (at real time) the activation of each muscle groups and ii) a graph illustrating the graph.
The Scoring.py file implements a scoring system to evaluate the efficiency of the player's shot mechanics.
Demo
See the Demo folder for demo videos and graphs.


",Python
154,"














Amateur Basketball Broadcasting Camera System
First software releases as of April 27th 2021
The background
Motion detection
The panning (April 29th)
Async video capture
Discarded ideas
Async video writing and others (As of May 4th)
Things to do (We would love some help here)





README.md




Amateur Basketball Broadcasting Camera System

First software releases as of April 27th 2021
You can see the design and consideration in the about section.
In this past week, both Sameer and me have found some time to finally work on the coding aspects of the project. In the repository you have both scripts.
Bear in mind this software needs a video recorded with a panoramic camera and some tunning for the specific playground.
My script is a refined version of Sameer's, but I have left out by now the recording of the video itself, thus the script is good to play with and see if the algorithmic ideas are right or not.
The background
In both cases we create a static background by extracting some random frames from the video and averaging them. This system should be improved so it is able to work in a streaming fashion instead of loading from a recorded video. Also, it is hard to get a static image with no players in such facilities, specially if you consider changing lighting conditions and different baskets utilized, so I have discarded such option. This is an area of improvement.
Motion detection
Motion detection is done every nth frame by substracting the background image. From there, only bigger than a limit area are considered. To those, the feet position is computed and seen if it is withing the playground area.
In the case of Sameer's, the center of gravity is computed just with the center of the feet. In my version, both the position and the area are considered. My alternative makes biggher rectangles weight more in the positioning decision (for example, multiple players detected as just one box, have significant weight as the area is big).
My version implements the idea of the Automatic Camera Selection paper.
In my version, I believe there is a better way to compute it, working directly with arrays.
Also, might be interesting to apply some Non Maximum Substraction (NMS) to reduce false positives, but reality is, as those tend to happen were there are players, I'm not worried by this factor.
Still, the possibility of shapes entering the field while their feet are outside of it and not being related to the game (like coach or public) is clearly affecting the results if their body is partially boxed. In many cases the bounding box doesn't cover the whole body and it is within the field (for example, the upper torso). It would be very important to reduce this effect to the maximum by proper camera placement (in our lab unfortunately the bodies of the coaches clearly enter the field many times).
I just purchased a Jetson Nano 2GB Dev Kit. Hope that by using a more advanced motion detection mechanism while still being able to sustain the framerate, will improve this situation.
The panning (April 29th)
I just commited a better panning system solving mostly the jitter in the movement. Now is quite smooth and in case of necessity, jumps forward faster. For sure it could be further improved by someone with PTZ management experience, but for now is ok.
Async video capture
The last improvement to my version has been to make the reading of the video async. Performance improved from 16 to 24 FPS which is a huge boost. For the background computation I don't use it, but I'm not worried by now about that is it is only computed once in its current form and is outside of the hot code path.
What is more important, the same VidGear library provides methods to read video from a RTSP server (most CCTV cameras have one) and to send the final video to Youtube or Facebook using RTMP (which is the ultimate goal of the project).
So not only we have improved performance, but found the way to easily support source and sink video streams !!!
Discarded ideas
One way to speed up the center of gravity computation was to do it directly over the mask image. It does work, producing good results but surprisingly is slower that finding the contours and iterating over them, thus we discarded it.
Also, instead of using an static background image we tried to detect movement by substracting a prior frame. We tried both frame -1 and frame -skip but the results were too erratic (the problem of the coach being partially detected as within the field).
Async video writing and others (As of May 4th)
Thanks to the help of VidGear's main developer, now the code is able to record the resulting video. In my Mac I get around 12FPS when eanbling recording. He also made some little improvements on other parts of the code.
Things to do (We would love some help here)

Improve rectangle selection by applying some Non Maximum Suppresion
Improve center of mass calculation by using matrix operations after NMS
Apply bitmask to remove areas where we know movement detection is undesirable and could lead to many false positives (public)
Apply some correction to area computation based on the distance to the camera as further rectangles weight less than closer ones
Port code to Nvidia Jetson Nano 2GB
Port code to Adlink Vizi-AI board based on Intel Myriad X



",Python
155,"











College-Basketball-Prediction
'cbb_acquire_team_data.py'
'cbb_acquire_game_data.py'
'make_ratings_dict.py'
'prepare_for_ml.py'
'make_predictions.py'





README.md




College-Basketball-Prediction
Predict the outcome when division I college basketball teams compete.
- Uses historical data from the 2003-2013 NCAA DI basketball seasons for
  training data.

- Considers each team's strength of schedule, abilitiy of opponents, 
  field goal percentage, defensive rebounds, fouls, three point percentage,
  assists, turnovers, free throw shooting, ..., etc.  
 
- Uses difference in teams' cummultive statistics to learn which features
  are most important in predicting game outcomes using a logistic regression
  model. 

'cbb_acquire_team_data.py'
The purpose of this python script is to obtain descriptive statistics of team
performance from www.sports-reference.com/cbb. Team descriptive statistics are,
for example, points per game, free throw percentegae, and the number of blocks
per game. Within this file is a class called 'CBB_Acquire_Team_Data', which
accepts a span of years and a csv file name as input. This class scrapes the
sports-reference site for descriptive statistics for every division I college
basketball team that played within the span of years input by the user. The
results are output to the specified csv file. Each descriptive statistic will be
used as a feature in a predictive model.
'cbb_acquire_game_data.py'
Scrapes www.sports-reference.com/cbb for the results of all games played during
some span of seasons. The user inputs the starting season, an end season, and a
csv file name to a class named 'CBB_Acquire_Scoring_Data'. For every game in the
span of season the class will output the two teams playing and points scored by
each team to the specified csv file. The results are used to form the
classification in a predictive model.
'make_ratings_dict.py'
Using the description in http://www.pro-football-reference.com/blog/?p=37, this
python script calculates several additional team descriptive statistics based on
the results from 'cbb_acquire_game_data.py'. Specifically, the statistics output
by the class 'Strength_of_Sched' summarize the degree of competion faced be each
team during a given season. The feature 'strength of schedule' accounts for how
easy or difficult a team's schedule has been. The feature 'margin' summarizes  a
team's margin of victory against all of its opponents. Finally, the feature
'rating' combines both the margin and strength of schedule of each team to
produce a coarse metric that can be used to rank all the teams. All the features
are output to a dictionary named 'ratings_dict.cpickle'.
'prepare_for_ml.py'
Converts the raw data from www.sports-reference.com/cbb to data structures that
the libraries in scikit-learn can easily use. The ultimate result of the
routines included in this file is a numpy array containing all the features and
game results for the historical game data. The structure 'features.npz' contains
this output and is eventually loaded by scikit-learn. The features have not been
normalized.
'make_predictions.py'
Uses scikit-learn and historical game results to make predictions on college
basketball games that have not been played. A logistic regression predictive
model is created. Using this model, all the teams during the current season are
ranked by simulating the results when each team plays every other DI team.
Analysis of results can be output to csv files for further analyses in something
like Tableau.


",Python
156,"











fntsylu
Does not work anymore because ESPN changed their website.
How to use
Crontab





README.md




fntsylu
Does not work anymore because ESPN changed their website.
=========================================================================================================================================
ESPN Fantasy Basketball Daily Lineup Automator
This is my script to set my ESPN Fantasy Basketball lineup daily. Not fully automative as it does not add players off
the bench and into the starting lineup if all the spots are taken, and of course, the players in those spots have games.
In that case, the script sends me an email with the amount of players who were unable to be added to the lineup.
How to use
First, you'll need to install:

google-chrome
selenium webdriver

Next, clone or download the repository and extract the fntsylu folder. Now, open up the fntsylu.py file in any text editor and edit the following:
 def login(self):
   // some code //
   username = """"  # Insert your email here
   password = """"  # Insert your password
   // rest of the code //
Before you edit this code, you'll need to create a gmail account that will notify you when there are players still on your bench. After you create the email, go back into the fntsylu.py file and edit the sendEmail function:
 def sendEmail(self, players):
   // some code ///
   email = """"          # Insert the email you just created
   password = """"       # Insert the password for the email you just created
   recipientEmail = """" # Insert the email you want to be notified (your personal email)
   // rest of the code //
Next, you'll need to know your league ID and team ID in order to enter the command to run the script.
Here's an example of correct command:

python fntsylu.py 7609 18 2018

'7609' is the ID of the league that I want to enter. '18' is the team ID. You can find your league and team ID by reading the url of the homepage of your fantasy league.'2018' is just the current year. Once you find your league and team IDs, go to your command line and change directory to the fntsylu folder, then type the following:

python fntsylu.py 'Insert your league ID here' 'Insert your team ID here' 'Insert your season ID here (current year)'

Chrome should open up and the script should be setting your lineup
Crontab
Next, you can set up cron to run the command for you. In the terminal, type

crontab -e

And enter the following at the bottom of the crontab file:

0 11 * * * export DISPLAY=:0; /usr/bin/python /path/to/fntsylu.py 'insert league id' 'insert team id' 'insert season id'

For the example line above, cron will run the script every day at 11.


",Python
157,"











ESPN Fantasy Autopick Chrome Extension
How to install
How to build
Bug reports





README.md




ESPN Fantasy Autopick Chrome Extension
A pair of Chrome extensions that let you automatically add active players to the current roster in an ESPN NBA/NHL fantasy league.
How to install
The extensions can be found in the Chrome Web Store:

NBA
NHL

How to build
Run yarn unpacked to create a folder suitable for loading as an unpacked extension in Chrome. yarn package creates a zipped version of the extension, ready to be uploaded to the extension store.
To build only the NBA extension, run yarn unpacked-nba or yarn package-nba. For the NHL extension, run yarn unpacked-nhl or yarn package-nhl.
Bug reports
If the extension isn't working properly, please report a bug on the GitHub page. To help me figure out what the problem is, the following is very helpful:

Include screenshots or text that shows your roster and your league settings.
Check the developer console in your browser for any error messages.

To check for errors, do the following:

Open the developer console by pressing the F12 key, and go to the Console tab.
There's a dropdown that sets the log levels. Make sure the ""Verbose"" level is included so it says ""All levels"".
Clear the log by clicking the Clear button.
Click the Auto button added by the extension.
The extension should print some debug information to the console. If something goes wrong there may be a red error message or a yellow warning message as well. Either copy the relevant text or take a screenshot that contains all of it.



",JavaScript
158,"











ncaahoopsscraper
Install
Usage





README.md




ncaahoopsscraper
Kurt Wirth
2019-07-03
A tool to easily scrape NCAA basketball game results from Sports Reference.
Install
Install from GitHub with the following code:
if (!requireNamespace(""devtools"", quietly = TRUE)) {
  install.packages(""devtools"")
}
devtools::install_github(""kurtawirth/ncaahoopsscraper"")
Included in this package as dependents are dplyr and rvest.
Usage
There are currently two functions currently live for ncaahoopsscraper.
The first, named 'ncaahoopsscraper', will return scores along with the date of each game. If you prefer to have team box scores included, you may use the 'boxscrapr' function.
For both, simply input the beginning date of the season desired in quotes followed by the end date. Importantly, these dates must be in YYYY/MM/DD format.
ncaahoopsscraper(""2017/11/10"", ""2018/04/02"")

The tool will output a tidy object that includes the games' dates, home team and its score, and the visiting team and its score. If you choose, you may then ouput this object as you wish (write.csv, for example). If you choose to use 'boxscrapr', the output will be a tidy object that includes the games' dates, team name, opponent team name, whether the team was at home or away, and the team's box score.
The package also includes files for each season from 2010 (the earliest this tool currently works for) until 2018 as well as a consolidated version with all seasons during that timespan.


",R
159,"














NBA Player and Team ID Database
Intro
Variables
NBA_Player_IDs.csv
NBA_Team_IDs.csv
Conclusion
Acknowledgements
Authors





README.md




NBA Player and Team ID Database
Intro
This project allows users to easily access a wide-variety of in-depth stats in one location. Currently, advanced NBA stats are spread out across various websites such as: ESPN, NBA.com, Basketball Reference and Spotrac. The main issue with the data being spread out is that it makes it especially difficult to scrape and analyze. Our project collects player IDs and puts them in one location. Thus, this will allow us to have all the advanced NBA metrics in one database that is easily accessible. All the data in one place leads to a reduction in the time it takes to scrape it. The new central location of the advanced metrics will allow for basketball statistics to be scraped more easily. Data is up-to-date as of the beginning of the 2019-2020 NBA season.
To scrape player data from each key basketball statistics website (https://stats.nba.com/, https://www.basketball-reference.com/, http://www.espn.com/nba/statistics/rpm, https://www.spotrac.com/nba/), we used R packages such as rvest, XML, and RSelenium to gather important information from each site. For each player we scraped their name (according to the site), link, ID (last few characters of link), and birth date (if available) to be able to match tables from different sites. Data was merged by name and birth date, but due to small differences in naming, some merging was done by hand. The corresponding code to scrape each website is provided, so we encourage users to utilize this code to scrape following years of data.
To gather the data necessary for identifying each team, we first went to every major basketball statistics website and examined the unique URLs of each team page on their respective websites. Then, we found what parts of the URL make each page unique from each other for the specific websites and logged those changes in excel. For example, the URL for the Los Angeles Clippers on basketball-reference is https://www.basketball-reference.com/teams/LAC/, while the URL for the Los Angeles Lakers is https://www.basketball-reference.com/teams/LAL/. We noted the difference at the end of each URL for each team, so that each URL would be accessible when plugging in the different endings, and did this for each website listed.
Variables
NBA_Player_IDs.csv

BBRefName – player name according to Basketball Reference
BBRefLink – player link according to Basketball Reference
BBRefID – player ID according to Basketball Reference
BBRefBirthDate – player birth date according to Basketball Reference
NBAName – player name according to NBA
NBALink – player link according to NBA
NBAID – player ID according to NBA
NBABirthDate – player birth date according to NBA
ESPNName – player name according to ESPN (RPM)
ESPNLink – player link according to ESPN (RPM)
ESPNID – player ID according to ESPN (RPM)
ESPNBirthDate – player birth date according to ESPN (RPM)
SpotracName – player name according to Spotrac
SpotracLink – player link according to Spotrac
SpotracID – player ID according to Spotrac

NBA_Team_IDs.csv

Season – first year of season (ex. 2019-2020 season would be 2019)
League	 - NBA or ABA
BBRef_Team_Name – team name according to Basketball Reference for given season
BBRef_Team_Abbreviation – team abbreviation according to Basketball Reference for given season
Current_BBRef_Team_Name – current (2019-2020) team name according to Basketball Reference for given season
Current_BBRef_Team_Abbreviation – current (2019-2020) team abbreviation according to Basketball Reference
ESPN_Current_Link_ID – current (2019-2020) team link ID according to ESPN
NBA_Current_Link_ID – current (2019-2020) team link ID according to NBA
Spotrac_Current_Link_ID – current (2019-2020) team link ID according to Spotrac

Conclusion
By taking note of the differences in how each website identifies players and teams, we were able to effectively bring all of the information from each site into one place. Bringing this data into one location will streamline the data gathering process for future research projects.
Acknowledgements

Check out https://syracusesportanalytics.weebly.com/basketball.html for Syracuse Basketball Analytics content.
Check out https://syracusesportanalytics.weebly.com/ for Syracuse Sport Analytics content.

Authors

Dylan Blechner, Alejandro Pesantez, Davis Showell, Chris Thomas, Ben Wachtel, Preston Klaus, Ian Archer



",R
160,"











gamezoneR 
Installation
Getting started
Documentation
Code of Conduct





README.md




gamezoneR 
gamezoneR is an R package for working with NCAA Men's Basketball play-by-play data
from STATS LLC's GameZone. The package allows users to scrape team and master schedules as well as play-by-play data with shot locations into a tidy format. The main benefit of gamezoneR is the volume of shot location data available. While ESPN also charts shots, as of March 10th 2021, ESPN has charted approximately 70,000 shots while STATS LLC has charted over 170,000 from the 2020-21 college basketball season alone!
Installation
You can install gamezoneR from
GitHub with:
# Install via devtools package using the following:
devtools::install_github(repo = ""JackLich10/gamezoneR"")
Getting started
For a quick introduction to the package, visit the Intro to gamezoneR article.
If you want to load in all available play-by-play data dating back to the 2017-18 season, use the following code:
future::plan(""multisession"")
tictoc::tic()
progressr::with_progress({
  pbp <- gamezoneR::load_gamezone_pbp(gamezoneR:::available_seasons())
})
tictoc::toc()
## 48.078 sec elapsed
length(unique(pbp$game_id))
## 24,994 games
pbp %>% dplyr::filter(!is.na(loc_x)) %>% nrow()
## 2,843,392 shot locations
Documentation
For more information on the package and function reference, please see the gamezoneR documentation.
Code of Conduct
Please note that the gamezoneR project is released with a Contributor Code of
Conduct.
By contributing to this project, you agree to abide by its terms.


",R
161,"











SportStreamer     
Check out the Web version of this app here: davidnester.github.io/sportstreamer. Site is still being developed.
Things I Intend To Do
To Use





README.md




SportStreamer     
Application used to mine streaming links for various sports from reddit forums designated for
posting stream links. I use Beautiful Soup to parse the pages and get the links. This uses
acestreams and opens them automatically in SodaPlayer. It also
gives links to web streams and will open them as a new tab in your browser.
Check out the Web version of this app here: davidnester.github.io/sportstreamer. Site is still being developed.

GUImain.py -- main file to run. Runs GUI
Utility.py -- contains a few functions, global variables, and import statements
Forum.py -- Class for a reddit streaming forum like Soccer Streams
Game.py -- Class for a game (also a post in a forum)
Column.py -- Stores list of buttons and wrapper for scrollable frame
scrframe -- Scrollable frame class found on stackoverflow
OLD -- Files that I no longer use. Command line interface and more basic GUI version

This works on my 2013 Macbook Pro with HighSierra 10.13.2. Have not tested on other platforms or OS versions.
Things I Intend To Do

Compile into app so that script doesn't have to be run every time
Get game data
Directly to chromecast
GUI improvements

Please feel free to add to it or suggest updates. I am using this as a learning experience
and am adding things as I discover them. I am sure I am doing many things in bad ways -- some I
am aware of and intend to fix and others I am unaware of a better way to do them. Any advice,
suggestions, and improvements are welcomed.
To Use
Uses Python 3.6.2
Install with pip
Mac users may need to go to /Applications/Python 3.6/ and run Install Certificates.command (double click on the file)
In your command line:
cd location/to/save/project/in/
mkdir SportStreamer
cd SportStreamer
git init
git clone https://github.com/DavidNester/SportStreamer.git
cd SportStreamer
pip install -r requirements.txt
python GUImain.py 

Mac users may have to use python3 GUImain.py
How it looks on my screen:



",Python
162,"



README.md




Android_JHipster_Basketball
Android frontend that integrates with JHipster backend via OAuth 2.0
This is the corresponding JHipster repository: https://github.com/TaniaFontcuberta/Spring-Basketball-oAuth2.git
You simply need to properly configure the properties:
https://github.com/alfredorueda/Android_JHipster_Basketball/blob/master/app/src/main/assets/app.properties
as defined in your JHipster app:
https://github.com/alfredorueda/basketballOAuth2/blob/master/src/main/resources/config/application.yml
security:
authentication:
oauth:
clientid: basketballapp
secret: mySecretOAuthSecret
# Token is valid 30 minutes
tokenValidityInSeconds: 1800
rememberme:
# security key (this key should be unique for your application, and kept secret)
key: a2a6c0b3627730ff7edad3f9b829c9d80969fe7a
Then, you simply need to add some players using the AngularJS Web interface as usual.
After that, you can query your new players from your Android application!
TODO:

Complete CRUD
Use best practices from this nice book: https://leanpub.com/retrofit-love-working-with-apis-on-android (interceptor)
(https://futurestud.io/blog/retrofit-series-round-up)



",Java
163,"











Hoops
Useful Links





README.md




Hoops
Useful Links
http://cvlab.epfl.ch/research/body/surv/
http://cmuems.com/excap/readings/forsyth-ponce-computer-vision-a-modern-approach.pdf
http://cvgl.stanford.edu/data2/pr2dataset/
http://www.pyimagesearch.com/2015/11/09/pedestrian-detection-opencv/
http://www.pyimagesearch.com/2014/11/10/histogram-oriented-gradients-object-detection/
https://github.com/ITCoders/Human-detection-and-Tracking
http://www.pierrebaque.com/page-DeepOcclusion/
http://www.pyimagesearch.com/2015/09/14/ball-tracking-with-opencv/
http://www.pyimagesearch.com/2016/12/05/macos-install-opencv-3-and-python-3-5/
http://www.pyimagesearch.com/2016/12/19/install-opencv-3-on-macos-with-homebrew-the-easy-way/
http://docs.opencv.org/3.2.0/d5/de5/tutorial_py_setup_in_windows.html
https://www.learnopencv.com/object-tracking-using-opencv-cpp-python/
http://www.pyimagesearch.com/2017/02/13/recognizing-digits-with-opencv-and-python/
https://stackoverflow.com/questions/10948589/choosing-correct-hsv-values-for-opencv-thresholding-with-inranges


",Python
164,"














Basketball-Shot-Detectection
Project Explanation/ Demo: https://www.youtube.com/watch?v=aW3IlB3nBoI
Project Poster: /FYP_DOCUMENTS/POSTER.pdf
Project Report: /FYP_DOCUMENTS/KCOMP_20072377_FinalReport.pdf
Ball Detection using OpenCV
Ball Detection using OpenCV
Player Detection using YOLO
3D player position to 2D player position





README.md




Basketball-Shot-Detectection
Major improvements data extraction in sports enables sport analyst to study and output an evaluation report of an athletes capabilities. Major teams and even players themselves have acted quickly to these turn of events and are now investing in the
idea of data driven decisions to win games.
I have decided to create an computer vision application based on the sport of Basketball. The following application will take in a recorded video of a player shooting a basktball as its input. Using computer vision methods in python I aim to display player position on a 2D court and display total count of make and missed shots on a score board.
Project Explanation/ Demo: https://www.youtube.com/watch?v=aW3IlB3nBoI
Project Poster: /FYP_DOCUMENTS/POSTER.pdf
Project Report: /FYP_DOCUMENTS/KCOMP_20072377_FinalReport.pdf
Ball Detection using OpenCV

Ball Detection using OpenCV

frame masked using lower and upper hsv colour range
countour detection and labelling usingOpenCV an


Player Detection using YOLO

detection player using YOLOv3
label using OpenCV


3D player position to 2D player position

extract points using hough transform and line intersection methods
warped 3D points onto coresponding 2D points
detection player using colour range masking




",Python
165,"











Kinect-Unity-Basketball
Table of Contents





README.md




Kinect-Unity-Basketball
A basketball game built in Unity and played using the Kinect v2
Table of Contents

Introduction
Installation
Project Details

Introduction
Team: Eamon McNicholas & Alan Niemiec
With the aim of this module focusing on gestures we have decided to implement multiple gestures using a Basketball free throw game in Unity as a basis for this research. Our technology of choice has been the Kinect v2 as the Kinect v1 version did not allow for the tracking of as many joints as we needed.
The application allows one or two users to compete in a free throw basketball game over who can get more shots into the basket. The application works whether or not there is a second user.The players use their raised left hand to throw the basketball at the correct power level.
Game code sourced from : https://code.tutsplus.com/tutorials/create-a-basketball-free-throw-game-with-unity--cms-21203
and : https://github.com/tutsplus/BasketballFreeThrowUnity
Body Joints List : https://www.codeproject.com/articles/743862/kinect-for-windows-version-body-tracking 
The UI has multiple elements to help the user:


In the top left there is a camera output that shows what the Kinect can see. We have tried but couldn't get it to output the Skeleton or Joints of the current users.


Top Middle – This is the basketball hoop that the players have to shoot at.


Bottom left & right – The user scores are shown as digit values in both corners. They increase when the user gets a basket.


Bottom middle – This is the outline of the basketball to imitate the baskebtall being held by the user.


Bottom left & right of the basketball outline – These are the power bars. When they start moving the user knows that the Kinect is ready to shoot.


Installation
To play the game you will need the Kinect V2 equipment for Windows as well as the Kinect SDK. You Will also need Unity.
#Project Details
There are three gestures in this application both of which imitate an actual throw in basketball:


Closed fist – The user has to start the the game with the fist closed to imitate the holding of a basketball. This is also crucial for the shooting as the Kinect shoots as soon as the hand is opened.


Arm raised above shoulder – In order for Kinect to allow the user to shoot, the users arm must be raised above his shoulder. The user can then Move his hand back and forth to adjust the power of the shot. The distance between the hand and shoulder joints is the force that is added to the ball.


Open hand gesture – Once the user completes the predefined action of raising back the arm he has to shoot by opening the palm of his hand and swinging forward.


We have determined for these to be the most natural actions a person would take during a basketball throw. Apart from the closed fist which was a necessity these imitate the actions taken during a throw.
A dribbling gesture could also be implemented to allow for the bouncing of the ball from the ground (perhaps with possible sound feedback) but we didn't have enough time to implement it.


",C#
166,"



README.md




Basketball Betting Bot - Another Ball Brother

TELEGRAM: @BasketballBettingBot
The fourth Ball Brother didn't make it to the NBA and slipped off into sports
gambling and wants to play with you! He sends you 11 NBA games to bet on each week,
10 good ones and one battle between the supreme tank commanders.
The one who gets the most games right in a week gets one point.
You play against the other members of your group chat and the overall winner is
the one with the most points at the end of the season.
There's also an alternative ranking that's just looking at the total number of
bets you guys got right, and doesn't care about weekly wins if that's more
your style.
To get started add the bot (@BasketballBettingBot) to your group chat and
send /start into the chat. Afterward you'll receive the games to bet on
for the upcoming week. Each game is sent to you in the form of a poll,
so just answer these to participate in the game.
After sending /start for the first time, all you need to do is answer the polls
that will be sent to you weekly.
This continues until the NBA season ends or you end the season yourself (/stop_season).
The bot can't read your group chat's messages, just the ones starting with an '/',
so don't worry about trash talking him - he won't know.
These are the commands he understands:


/start -> Start your season! (wait until everyone who wants to participate was
added to the group)


/standings -> Show standings for the ongoing week


/full_standings -> Show standings for the whole season


/all_bets -> Show fraction of correct bets for the whole season
(Alternative to weekly standings)


/week_standings -> Show standings for a specified week


/sage -> Cleanse the chat from toxic energy


/stop_season -> End the betting season and receive final standings.
THIS CAN'T BE UNDONE!


Here's an example of what it looks like:



",Rust
167,"











bracketology
To install





README.md




bracketology
This R data package contains over 2.8 million bracket predictions for the 2015
NCAA March Madness Men's Basketball Tournament. This package is 49MB so it may
take some time to download depending on the speed of your internet connection.
To install
# install.packages(""devtools"")
library(devtools)
install_github(""seankross/bracketology"")



",R
168,"











NBAloveR
Installation
Official Document
Data Source
Hands-on Tutorial





README.md




NBAloveR




""NBAloveR"" is an R package that helps you analyze basketball data easily using statistical software tool, R.

koki25ando/NBAloveR
CRAN Official Page

Installation
# devtools::install_github(""koki25ando/NBAloveR"")
install.packages(""NBAloveR"")
library(NBAloveR)

Official Document

Package ""NBAloveR""

Data Source
Data you can get using this package are from following websites.

Basketball Reference
nbadraft.net
RealGM

Hands-on Tutorial
Visit my blog posts to learn more about NBAloveR package!

Introducing ""NBAloveR""
NBAloveR is now updated!



",R
169,"



README.md




March-Madness
blogpost


",Python
170,"














2020年篮球机器人视觉代码
1. 算法简介
1.1 识别检测：
1.2 定位
1.2.1 球类定位
1.2.2 标定柱（篮筐）定位
2. 依赖
2.1 硬件环境
2.2 软件环境
3. 使用方法
3.1 编译
34.2 运行





README.md




2020年篮球机器人视觉代码
1. 算法简介
1.1 识别检测：


使用Yolo V4（C++版）在yolov4.conv.137权重上利用自己采集的上千张数据集进行迁移学习，训练出合适的模型。


使用TensorRT[https://github.com/NVIDIA/TensorRT]库对原模型进行推理，完成Float32->Float16到转换，保存半精度计算的engine(Yolo-TensorRT仓库)，提高机器人识别帧率。


使用相机读取最新帧图像，完成检测并返回labels和boundingboxes。


1.2 定位
1.2.1 球类定位

利用图像检测得到的boundingbox中心和相机内参，计算球的正投影相对机器人中心投影的物理角度。
使用Hokuyo雷达获取机器人到指定方向上球的距离（需要配合一些去除噪点的算法）
利用角度和距离，解算出球的坐标。


1.2.2 标定柱（篮筐）定位

利用HSV参数条件组合识别蓝绿蓝的标定柱
利用深度学习学习识别颜色特征明显的标定柱


2. 依赖
2.1 硬件环境

Nvidia Jetson Xavier NX

2.2 软件环境


ROS


Ubuntu18


Opencv4.1.0


Usbcapture相机驱动（intel x86下可用，Xavier暂不可用）


3. 使用方法
3.1 编译
mkdir build & cd build
cmake ../
make 

34.2 运行
# 赋予雷达端口权限
sudo chmod a+rw /dev/ttyACM0
# 启动Roscore
roscore
# 设置雷达参数
rosparam set hokuyo_node/calibrate_time false
rosparam set hokuyo_node/port /dev/ttyACM0
# 测试运行（如果和其他控制代码一起编译，可以通过rosrun运行）
./build/vision/main



",C++
171,"











BasketballGA
To install





README.md




BasketballGA
An AI created for Facebook Messenger's basketball game using simple Genetic Algorithm.

More info about it and watch the AI in action here:
http://www.summarizerman.com/post/141963213990/simple-genetic-algorithm-ai-for-fb-messengers
To install
pip install -r requirements.txt
python run.py

Used Phaser as the game engine.


",HTML
172,"



README.md




Ansong Basketball
A basketball trainer Website.
https://www.ansongbasketball.com


",HTML
173,"











BallDetection
Introduction
Dataset
Annotation
Preprocess
Feature extraction
Evaluation





README.md




BallDetection
Implementation of Machine learning algorithms to detect a goal in basketball games.

Naive classifier
Logistic regression
SVM
Multiple layer perceptron
CNN

Introduction
Dataset
Our dataset is four basketball videos containing about 400, 000 frames.
Annotation
Basically, we label each frame as goal(1) or not goal(0). A frame is labeled as goal if from the time when the bottom of the basketball touches the loop to the time when the top of the ball is leaving the nets.
Preprocess
Label, cut, and randomly shuffle the frames. See details in preprocess.
Feature extraction
For naive classifier, LR, SVM, we use HoG to extract features.
Evaluation
A ROC curve is used for evaluation.


",Python
174,"



README.md




Individual work - is to make an app or game of a given topic in Android Studio or xCode.
Basketball game for Android



",Java
175,"











College Basketball CLI
Usage





readme.md




College Basketball CLI

Get live scores and game times from your terminal


Usage
You can install globally with npm install -g cbb or use with npx.
# Usage
npm install -g cbb
npx cbb

# Help menu
cbb --help

# Filter by AP top 25
cbb --ap

# Filter by conference
cbb --conference big-ten
cbb -c big-ten

# Filter by name
cbb --name purdue

# watch live games
cbb watch


",JavaScript
176,"











Similar-Shooter
Examples
How does it work?
What data are used?





README.md




Similar-Shooter
 
Find basketball players with similar shot charts
Examples
A live version of this flask app can be seen at: https://similar-shooter.herokuapp.com/.  Note, I am not paying anything to host this, so it could take forever to run...
Here are some static examples, though.
Who is most similar to DeAndre Jordan? Top shot-chart match: Rody Gobert


Who is most similar to Buddy Hield? Top shot-chart match: Tim Hardaway


How does it work?
I played around with a lot of different algorithms to define what makes shot charts similar.  It's an interesting question: what does it mean for two shot charts to be similar?
I made the following assumptions:

If two shot charts are the exact same, but with different densities, they are still very similar.  Players with different usage rates shouldn't be penalized as being different.
The most important features are distance from the hoop, and 2PT vs 3PT shots.  I largely disregard things like which side of the court players shoot from.

Using these assumptions, I compare the Kullback-Leibler divergence of each players shot distributions.  Players with low KL divergence have high similarity.
What data are used?
Shot data and shot charts are scrapped seperately (design flaw).  These data were scraped March 7 2017, so they contain data from the 2017 season up until this data.
To get up-to-date data, rerun scraper/scraper.py and shotchart/shotchart.py.
To get historic data, change global parameter YEAR before scraping.


",Python
177,"














wncaahoopR 
Installation
Functions
Scraping Data
Win-Probability and Game-Flow Charts
Assist Networks
Shot Charts
Datasets
Examples
Creating a PBP Object
Win Probability Charts
Game Flow Chart
Single-Game Assist Network
Circle Assist Networks
Glossary





README.md




wncaahoopR 
wncaahoopR is an R package for working with women's NCAA Basketball play-by-play (and other) data.
This package relies heavily on the work done by Luke Benz (lbenz730) in his package ncaahoopR, designed for working with men's NCAA basketball play-by-play data.
wncaahoopR also scrapes data from ESPN, but differs in that it does not have scraping provided in multiple functions, choosing to only scan in the data once and then makes use of that pbp object within R to produce win-probability and game flow charts, as well as assist networks.
wncaahoopR is a joint effort between Seth Berry (saberry) and Scott Nestler (snestler).  They welcome bug identification and ideas via the Issues tab, but please look at open issues before creating a new one.
Installation
You can install wncaahoopR from GitHub with:
# install.packages(""devtools"")
devtools::install_github(""snestler/wncaahoopR"")
Functions
Several functions use ESPN game_ids. You can find the game_id in the URL for the game summary, as shown below in the URL for the summary of the Notre Dame - Michigan game played on Nov. 23, 2019.

Scraping Data

get_pbp_game(game_ids):  Get play-by-play data for a specific vector of one or more ESPN game_ids.
get_pbp_season(team, season): Game entire current season's worth of play-by-play data for a given team and season. season defaults to current season, but can be specified in ""2019-20"" form.
get_roster(team, season): Get a particular team's roster, season defaults to current season, but can be specified in ""2019-20"" form.
get_game_ids(team, season): Get a vector of ESPN game_ids for all games in which team plays in. season defaults to current season, but can be specified in ""2019-20"" form.

The team parameter in the above functions must be a valid team name from the ids dataset built into the package. See the Datasets section below for more details.
Win-Probability and Game-Flow Charts
Win Probability Charts
There is a function (wp_chart) for plotting win probability charts, using the ggplot2 library. NOTE: This is equivalent to the  (gg_wp_chart) function in ncaahoopR package.  We did not see the need to maintain a base R graphics function.

NOTE 1:  For now, all win probability charts are ""naive,"" in that they do not incorporate a pre-game line or spread, until we determine a reliable and freely available source (since this is not provided on ESPN, like for the mens game).
NOTE 2:  For now, the WP calculations are based on historical data from NCAA MBB games; this will be updated in a future release.

wp_chart(pbp, home_col, away_col, show_legend = T)

pbp Play-by-play (pbp) object created from w_get_pbp_game function.
home_col Chart color for home team; defaults to the primary color ine ncaa_colors.
away_col: Chart color for away team; defaults to the primary color in ncaa_colors.
show_gei: Logical, whether or not to show Game Excitement Index on chart. Default = TRUE.

Game Flow Charts
game_flow(pbp, home_col, away_col)

pbp Play-by-play (pbp) object created from w_get_pbp_game function.
home_col Chart color for home team; defaults to the primary color ine ncaa_colors.
away_col: Chart color for away team; defaults to the primary color ine ncaa_colors.

Game Excitement Index
game_exciment_index(pbp)
Returns GEI (Game Excitement Index) for given ESPN game_id. For more information about how these win-probability charts are fit and how Game Excitement Index is calculated, check out the below links

Model Methodology
Game Excitement Index

Game Control Measures
average_win_prob(game_id)

ESPN game_id for which to compute time-based average win probability (from perspective of home team).

average_score_diff(game_id)

ESPN game_id for which to compute time-based average score differential (from perspective of home team).

Assist Networks
Traditional Assist Networks
assist_net(pbp, team, node_col, three_weights, threshold, message = NA, listing = T)

team is the ESPN team name, as listed in the ids data frame.  Or can be 'home' or 'away' (without quotes).
season: Options include ""2018-19"" (for entire season), or a vector of ESPN game IDs.
node_col is the node color for the graph.
three_weights (default = TRUE): Logical. If TRUE, assisted three-point shots are given 1.5 weight. If FALSE, assisted three-point shots are given weight 1. In both cases, assisted two-point shots are given weight 1.
threshold: Number between 0-1 indicating minimum percentage of team assists/baskets a player needs to exceed to be included in network. Default = 0.
message (default = NA) Option for custom message to replace graph title when using a subset of the season (e.g. conference play).
listing: Return list of assist network related statistics (default = TRUE)

Circle Assist Networks and Player Highlighting
circle_assist_net(pbp, team, season, highlight_player, highlight_color, three_weights, message = NA, listing = T)

team is the ESPN team name, as listed in the ids data frame.    Or can be 'home' or 'away' (without quotes).
season: Options include ""2018-19"" (for entire season), or a vector of ESPN game IDs.
highlight_player: Name of player to highlight in assist network. NA yields full team assist network with no player highlighting. Default = NA.
highlight_color: Color of player links to be highlighted. NA if highlight_player is NA.
three_weights (default = TRUE): Logical. If TRUE, assisted three-point shots are given 1.5 weight. If FALSE, assisted three-point shots are given weight 1. In both cases, assisted two-point shots are given weight 1.
threshold: Number between 0-1 indicating minimum percentage of team assists/baskets a player needs to exceed to be included in network. Default = 0.
message: User supplied plot title to overwrite default plot title, if desired. Default = NA.
listing: Return list of assist network related statistics (default = TRUE)

Shot Charts
wncaahoopR does not currently include the ability to plot shot location data, as this information is not currently available on ESPN, like it is for some mens games.
Datasets
dict A dataframe for converting between team names from various sites.

NCAA: the name of the team, as listed on the NCAA website
ESPN: the name of the team, as listed on the ESPN URLs
ESPN_PBP: the name of the team, as listed on the ESPN Play-By-Play logs
Warren_Nolan: the name of the team, as listed on WarrenNolan.com
Trank: the name of the team, as listed on barttorvik.com
name_247: the name of the team, as listed on 247Sports.com

ids A data frame for converting between team names from various sites.

team: the name of the team to be supplied to function in ncaahoopR package
id: team id; used in ESPN URLs
link: link; used in ESPN URLs

ncaa_colors A data frame of team color hex codes, pulled from teamcolorcodes.com. Additional data coverage provided by Luke Morris.

ncaa_name: The name of the team, as listed on the NCAA website (same as dict$NCAA)
espn_name: The name of the team, as listed on the ESPN URLs (same as dict$ESPN)}
primary_color: Hexcode for team's primary color.
secondary_color: Hexcode for team's secondary color, when available.
tertiary_color: Hexcode for team's tertiary color, when available.
color_4: Hexcode for team's 4th color, when available.
color_5: Hexcode for team's 5th color, when available.
color_6: Hexcode for team's 6th color, when available.


Primary and secondary colors for all 351 teams.
These datasets can be loaded by typing data(""ids""), data(""ncaa_colors""), or data(""dict""), respectively.
Examples
Creating a PBP Object
ND_Mich <- w_get_pbp_game(401171130)
Win Probability Charts

wp_chart(ND_Mich)

wp_chart(ND_Mich, away_col = ""#C99700"")
Game Flow Chart

game_flow(ND_Mich, away_col = ""#C99700"")
Single-Game Assist Network

assist_net(ND_Mich, team = ""Notre Dame"")
Circle Assist Networks

circle_assist_net(ND_Mich, team = ""Notre Dame"")

circle_assist_net(ND_Mich, team = ""Notre Dame"", highlight_player = ""Sam Brunelle"", highlight_color = ""#C99700"")
Glossary
Play-by-Play files contain the following variables:

play_id: Unique identifier of play/event in sequence of game events.
period: Period of action in the game. 1, 2, 3, and 4 denote the four quarters of regulation play, while 5 denotes OT1, 6 denotes OT2 etc.
time_remaining_period: Time remaining in the period as it would appear on a scoreboard.
secs_remaining: Time remaining in regulation, in seconds.
secs_remaining_absolute: The time remaining until the game is over, in seconds. For example a game that goes to overtime would begin with 2700 seconds remaining (2400 for regulation and 300 for overtime), and regulation would end with 300 seconds remaining.
description: A description of the play/game event.
home_score: Home team's score.
away_score: Away team's score.
score_diff: Score differential from the home team's perspective (home_score - away_score)
play_length: Duration of the the given play, in seconds.
win_prob: Win probability for the home team.
home: Name of the home team.
away: Name of the away team.
home_timeout_remaining: Number of timeouts remaining for the home team.
away_timeout_remaining: Number of timeouts remaining for the away team.
home_timeout_ind: Binary (0-1) indicator if home team took a timeout in previous 60 seconds.
away_timeout_ind: Binary (0-1) indicator if away team took a timeout in previous 60 seconds.
home_favored_by: Number of points by which the home team is favored, prior to tip-off. If Vegas point spread is available on ESPN, that is used as the default. When not available, an attempt is made to impute the pre-game point spread from derived team strengths. Imputed point spreads are not available for games prior to the 2016-17 season or when one of the teams is not in Division 1.
game_id: ESPN game_id for the game in question.
date: Date of game.
whichScored: A team name indicating which team scored on a play.



",R
178,"














WeBall Statistics
The WeBall Statistics application is a league statistics application for basketball, which was created as part of the course ""Apps development for Mobile Devices"" (University of Macedonia - Applied Informatics, academic year 2021-2022, 6th semester).
Part of the course, was to get organized into groups of 10 people. Our team (#Team 2) consists of the following students alphabetically:
Video presentation of the app on YouTube: presentation video
Visit the other repository, with the android mobile application: Android App - Front-End
Navigating the app's back-end UI
This is the home/index page of the back-end admin UI. From there one can see information about the software that was developed, such as team members, course teachers, etc. Through this page, the admin user has the options to Login or create an account by selecting the appropriate link from the nav bar.
Through the first screen, the admin can login to their account. If he does not have an account, he can create one through the form shown on the second screen.
After successfully logging into his account, he will go to the admin panel. From there he has the following possibilities:
Through this screen he can create teams and see the existing ones.
Through this screen he can create players and see the existing ones.
Through this screen, the admin can create the league matches manually.
Through this screen, the admin can create the league matches automatically by simply pressing the button and waiting 5sec for the process to complete.
This is the last screen, where the admin will find information about managing the admin panel.
Prerequisites
Local Installation
For the correct use of the application, the following actions are required:
Note: Maybe you will see already data for live matches because of the real time cloud service was used, firebase real-time database!





README.md




WeBall Statistics
The WeBall Statistics application is a league statistics application for basketball, which was created as part of the course ""Apps development for Mobile Devices"" (University of Macedonia - Applied Informatics, academic year 2021-2022, 6th semester).
Part of the course, was to get organized into groups of 10 people. Our team (#Team 2) consists of the following students alphabetically:

Ampatzidou Elisavet
Charakopoulos Minas - Theodoros
Dasyra Evmorfia - Elpida 
Iordanou Sofia
Lougaris Dionisis 
Lousta Aravella
Machairas Panagiotis
Ouzounidis Kyriakos
Pepa Leonard
Stefou George-John

Video presentation of the app on YouTube: presentation video
Visit the other repository, with the android mobile application: Android App - Front-End
Navigating the app's back-end UI

This is the home/index page of the back-end admin UI. From there one can see information about the software that was developed, such as team members, course teachers, etc. Through this page, the admin user has the options to Login or create an account by selecting the appropriate link from the nav bar.






Through the first screen, the admin can login to their account. If he does not have an account, he can create one through the form shown on the second screen.



After successfully logging into his account, he will go to the admin panel. From there he has the following possibilities:

Create Team and view a list with all the teams in the MySQL Database
Create Player and view a list with all the players in the MySQL Database
Create league manually for every week
Championship draw selection automatically, through our own algorithm.
Reset his password
Load data from json files with ready data for players and teams so he doesn't have to put it all in manually.
Check the manual
Logout




Through this screen he can create teams and see the existing ones.



Through this screen he can create players and see the existing ones.



Through this screen, the admin can create the league matches manually.



Through this screen, the admin can create the league matches automatically by simply pressing the button and waiting 5sec for the process to complete.



This is the last screen, where the admin will find information about managing the admin panel.
Prerequisites

Android Studio
XAMPP Control Panel
An emulator installed e.g. Nexus 5 API 30, Pixel 3 XL API 29
Internet Connection

Local Installation
For the correct use of the application, the following actions are required:
Run at first the back-end:
git clone https://github.com/uom-android-team2/WeBall_Statistics-Backend.git or download the zip from github and extract it
Store or move the root folder WeBall_Statistics-Backend(-master) in <PATH>\xampp\htdocs folder
Open XAMPP Control Panel and start Apache and MySQL servers
Visit from your browser http://localhost/WeBall_Statistics-Backend/index/ then register or login and follow the manual

Now, for the Mobile Application:
git clone https://github.com/uom-android-team2/WeBall_Statistics.git or download the zip from github and extract it
Store or move the root folder WeBall_Statistics(-main) in <PATH>\AndroidStudioProjects\
Open Android Studio and the app root folder.
Config the App:
public static final String IP = <YOUR_IP>  --> (java/uom/team2/weball_statistics/configuration/Config.java)
<domain includeSubdomains=""true""><YOUR_IP></domain>  --> (res/xml/network_security_config.xml)
Start any emulator, and then you are ready to launch the app!

Note: Maybe you will see already data for live matches because of the real time cloud service was used, firebase real-time database!


",PHP
179,"














WeBall Statistics
The WeBall Statistics application is a league statistics application for basketball, which was created as part of the course ""Apps development for Mobile Devices"" (University of Macedonia - Applied Informatics, academic year 2021-2022, 6th semester).
Part of the course, was to get organized into groups of 10 people. Our team (#Team 2) consists of the following students alphabetically:
Video presentation of the app on YouTube: presentation video
Visit the other repository, with the back-end of our application: back-end
R1    Display matches - Admin Login - Guest Starting Page
R2    Match management by Admin
R3    Recording statistics
R4    Watch the progress of the Live Match
For the implementation of the real time data, the possibility of the real time database offered by the Firebase platform was utilized.
R5    Watch the Statistics of the Live Match (Both for Teams and Players)
R6    Statistics of completed matches
R7    League Scoreboard
R8    Overall team stats
R9    Personal player stats
R10    Top-5 players for each week
Prerequisites
Local Installation
For the correct use of the application, the following actions are required:
Note: Maybe you will see already data for live matches because of the real time cloud service was used, firebase real-time database!





README.md




WeBall Statistics
The WeBall Statistics application is a league statistics application for basketball, which was created as part of the course ""Apps development for Mobile Devices"" (University of Macedonia - Applied Informatics, academic year 2021-2022, 6th semester).
Part of the course, was to get organized into groups of 10 people. Our team (#Team 2) consists of the following students alphabetically:

Ampatzidou Elisavet
Charakopoulos Minas - Theodoros
Dasyra Evmorfia - Elpida 
Iordanou Sofia
Lougaris Dionisis 
Lousta Aravella
Machairas Panagiotis
Ouzounidis Kyriakos
Pepa Leonard
Stefou George-John

Video presentation of the app on YouTube: presentation video
Visit the other repository, with the back-end of our application: back-end
R1    Display matches - Admin Login - Guest Starting Page






Requirement 1 is handled by the administrator (admin) and it concerns the match selection, and manage the card of the selected match. This includes the appearance of players and the corresponding ones logos. First, the administrator must enter the username and password in the form is requested, after choosing the button “LOGIN AS ADMIN"". The admin account can created by the backend website through it register. It then goes to the “Matches” screen, where there are three columns with the corresponding matches (Previous Matches, Live Matches, Upcoming Matches). From there the administrator can choose a match and edit the tab of. More specifically, by pressing it arrow a popup appears menu, which includes the players of the groups. With the edit button, is transferred to the “Welcome Admin” screen, where it is match management (see R2). 
Note: The edit option concerns ONLY the live and upcoming matches, not the completed.
R2    Match management by Admin






Requirement 2 constitutes the next possibility of the administrator (admin), which includes all functions related to managing a match (Shoot with
type and result, Rebound or Assist or Block, Steal, Turnover and Foul). Necessary condition for starting the game, but also to activate the buttons, it is to click the button ""Start"". After it's click, the same button turns into “End”, through which the match could be terminated. In addition, the administrator can stop the timer and start it (from where you stopped it) via the “Pause” button, the which turns into “Continue” when pressed, and vice versa. Still, for registering any action, it is necessary, the administrator to follow a series of steps. Initially, the administrator during his navigation on this screen, sees the home team selected (by default). To if he can change team, he uses the Banner of which located at the top as an image. Once he selects any from the 2 teams, the key players of the selected team, appear at the bottom of the screen. In the same way that the team is selected, a player can also be selected, that is, by clicking on his image. 
Note: The match does not end when ""Done"" is pressed. Only will paused and the admin will moved back to all matches.
R3    Recording statistics
This particular requirement deals with calculating stats for players and the groups, when the administrator performs a corresponding action. These actions include the basic events that occur in a match basketball skills such as free throws and attempts (two-pointers, three-pointers). In addition, assists, rebounds, steals, cuts, fouls are also recorded and mistakes. The specific statistics are recorded in the database at the moment which the administrator presses a similar button from its graphical interface which is fragment_admins_view. Statistics recording can begin the moment a match is live. For something like this to happen, it is necessary o
administrator to press the start button from its graphical interface. On the contrary, if the administrator seeks to increase statistics for a player, team respectively buttons will be disabled. Beyond the simple recording of statistics n application modifies the above data into a more logical form for the user. Specifically, in the frontend, a percentage calculation is also carried out through a condition. To if the application succeeds in the specific process, it stores its data in classes statistics for players and teams from the database.
R4    Watch the progress of the Live Match






The purpose of implementing requirement 4 is that users as well as match administrators (admins) can watch the progression of a live match in real time, through verbal descriptions and comments for more details. In order to watch the progress of a live match, one must first choose one, from the list of live matches (Live matches), by clicking anywhere on its layout. Thus, it will be transferred to a new screen, where the 2 teams, the current score, the match week, as well as the current minutes of the match, are shown above. Below, is a menu available where gives the opportunity to watch the match through brief descriptions by selecting the ""Progress"" tab, as well as through comments and more detailed descriptions by pressing the ""Comments"" tab. He can also see the statistics of the teams and the respective players by going to the ""Statistics"" tab (R5). 
About the ""Progress"" tab, short descriptions are displayed for actions registered by the admin and performed in the match such as the following: 

Start, complete, pause and resume of the match.
Successful freethrow, 2-point and 3-point
Rebound
Steal
The name of the player who made the Assist in parentheses (only for 2 points or 3 points).
Block
Foul
Turnover
Player Substitution

About the ""Comments"" tab, all actions previously mentioned in the “Progress” tab are described in the form of comments with the extra addition of the display of missed free throws, 2-points and 3-points.
Left-aligned descriptions refer to the home team, right-aligned to the away team and in the center there are descriptions generally related to the flow of the match without specifically addressing any team.
Note:  All descriptions are realtime and no refresh is required to display the newest events. Each new action will appear on top, first, at the beginning. Also, the score and the time shown in the header of the match are realtime and directly obey the actions of the admin.
For the implementation of the real time data, the possibility of the real time database offered by the Firebase platform was utilized.
R5    Watch the Statistics of the Live Match (Both for Teams and Players)






Requirement 5 will give the opportunity to the user to watch live stats of a match as it is live. The user, having selected a live match, has the possibility to see the relevant statistics of the teams from the last column of the ""Live Game"" screen. Here again the elements on the left side of the screen represent the home team, while the elements on the right represent the away team. In addition, the bars visually show the statistics of the teams by category  (Successful effort, Total effort, Successful freethrow, Total freethrow, Successful twopointer, Total twopointer, Successful threepointer, Total threepointer, Steal,
Assist, Block, Rebound, Foul, Turnover), while the number above each bar indicates the total number of attempts, successful shots, etc. The “View Players Live Statistics” button at the bottom of the screen, refers the user to the individual player statistics by category again. The team's overall data (e.g. total effort) is displayed on the right and the number representing each player on the left. The bar again indicates the corresponding percentage. Additionally, the user can select the player from the bottom of the screen or change team from the pop-up menu on the top left of the screen.
Note:  Firebase was used to record and store the data, so that the comments of each match are always updated, without the need for further action by the user (e.g. refreshing the page).
R6    Statistics of completed matches






Requirement 6 will offer the user the option to view the stats of a completed match. From the user's home match screen and the “Previous Matches” column, the user can select a completed match to view its statistics. In more detail, after selecting one, the individual statistics of the five most efficient players of each team are displayed, and below, a list of the leading players in the specific statistics for the selected match. The following are the total statistics of the two teams per category (Team Efficiency, 3 Pointers Made, 2 Pointers Made, Total Freethrows, Team Assists, Total Fouls.
10). The left side is for the home team, while the right side is for the away team.
R7    League Scoreboard




In requirement 7, the scores of all the teams will be presented, after they have completed the match in which they are participating. More specifically, the user goes to the scoreboard screen from the ""CHAMPIONSHIP LEADERBOARD"" button located on the home screen. This screen shows the teams sorted according to their score (PTS). To the left of the columns is the position number of each team (#), followed by the team name, total games played so far (GM), wins (W) and losses (L) respectively and finally the points scored have collected (PTS). Points are calculated as the sum of wins times 2 and losses. Additionally, there are two buttons on this screen. The “STATISTICS” button, which leads to
team and player statistics, and the “TOP 5” button, which leads to the best 5 players (regardless of team).
R8    Overall team stats




In requirement 8, the total statistics of the teams will be displayed. The user from the ""STATISTICS"" button of requirement 7 goes to the ""Championship Statistics"" screen, which has two tabs. The second tab “TEAM STATS” (related to R8), contains four tables per category. In each table the five teams with the highest percentages per category (points per game, assists per game, rebounds per game, blocks per game, up to the given moment in the league) are shown. For example, in “Points Per Game”, the user can see the top five teams that collected the most points per game.
R9    Personal player stats




In requirement 9, the personal statistics of the players throughout the league are displayed. The ""STATISTICS"" button of requirement 7 navigates the user to the ""Championship Statistics"" screen, which has two tabs. The first tab on the left (PLAYERS STATS) corresponds to requirement 9 and concerns the statistics of the players by category (points per game, assists per game, rebounds per game, blocks per game, fouls per game), i.e. how many points, rebounds, assists, etc. collected by the respective player per game (up to the given moment in the league). In each category, the 5 players who collected the highest percentages per category, in the matches they have participated in so far, are displayed. These statistics are updated as the match progresses.
R10    Top-5 players for each week




In requirement 10, the best 5 of the Competition are calculated based on the evaluation system (Efficiency meter). By pressing the button ""TOP 5"" the user enters the page and displays the 5 best players of the matchday (last matchday / current week), according to the position in which they play. For the selection of the top five, the statistics of all players who participated in the completed matches of the current week are gathered, the efficiency index of each player is calculated and then these indices are compared between players of the same position. The player with the greatest efficiency emerges as the best of the week for the position he plays. In addition, the data of the 5 best players is displayed in a frame with a background color that dominates the team they play.
Prerequisites

Android Studio
XAMPP Control Panel
An emulator installed e.g. Nexus 5 API 30, Pixel 3 XL API 29
Internet Connection

Local Installation
For the correct use of the application, the following actions are required:
Run at first the back-end:
git clone https://github.com/uom-android-team2/WeBall_Statistics-Backend.git or download the zip from github and extract it
Store or move the root folder WeBall_Statistics-Backend(-master) in <PATH>\xampp\htdocs folder
Open XAMPP Control Panel and start Apache and MySQL servers
Visit from your browser http://localhost/WeBall_Statistics-Backend/index/ then register or login and follow the manual

Now, for the Mobile Application:
git clone https://github.com/uom-android-team2/WeBall_Statistics.git or download the zip from github and extract it
Store or move the root folder WeBall_Statistics(-main) in <PATH>\AndroidStudioProjects\
Open Android Studio and the app root folder.
Config the App:
public static final String IP = <YOUR_IP>  --> (java/uom/team2/weball_statistics/configuration/Config.java)
<domain includeSubdomains=""true""><YOUR_IP></domain>  --> (res/xml/network_security_config.xml)
Start any emulator, and then you are ready to launch the app!

Note: Maybe you will see already data for live matches because of the real time cloud service was used, firebase real-time database!


",Java
180,"



README.md




The NCAA simulator application contains the following:

Game simulator built on an individual posession framework (customizable options available)
Simualted Game Stats (for each simulated Game)
NCAAA Basketball Team Stats Hub
In Development - Upcoming Game Predictions (Vegas Betting Lines Included)

Published Here: https://tdagostino.shinyapps.io/NCAA-Basketball-Sim/
Game Simulator:
As noted above, the simulator is built on an an individual posession framework using over 35 different team statistics as inputs. Users can choose to from a total of 353 NCAA basketball teams when simulating games. Users can choose to have the model adjust for home field advantage and/or strength of schedule.
-More Info to Come-


",R
181,"











NBA-Schedule-Data
Accessing the Schedule Data
JSON Structure
JSON Breakdown





README.md




NBA-Schedule-Data
This repository contains tools, information, and documentation for accessing NBA season/post-season data that is available through data.nba.com.
Accessing the Schedule Data
The full JSON file for an NBA season schedule (2015 or later) can be accessed through the URL:
https://data.nba.com/data/10s/v2015/json/mobile_teams/nba/{YEAR}/league/00_full_schedule.json


JSON Structure
 + lscd
    + mscd
        + mon
        + g
            - gid
            - gcode
            - seri
            - is
            - gdte
            - htm
            - vtm
            - etm
            - an
            - as
            - st
            - stt
            + bd
                + b ...
            + v
                - tid
                - re
                - ta
                - tn
                - tc
                - s
            + h
                - tid
                - re
                - ta
                - tn
                - tc
                - s
            - gdtutc
            - utctm
            - ppdst
            + ptsls ...
    + mscd 
    + mscd
    ...
               

JSON Breakdown



Name
Description
Value Type
Example




lscd
League Schedule
Array of JSON Objects



mscd
Month Schedule
Array of JSON Objects



mon
Month
String
""June""


g
Games
Array of JSON Objects



gid
Game ID
String
""0041500407""


gcode
Game Code
String
""20160619/CLEGSW""


seri
Playoff Series Summary
String
""CLE wins series 4-3""


gdte
Game Date
String
""2016-06-19""


an
Arena
String
""ORACLE Arena""


ac
Arena City
String
""Oakland""


as
Arena State
String
""CA""


stt
Game Status
String
""Final""


bd
Broadcast Information
JSON Object



b
Broadcasters
Array of JSON Objects



v
Visiting Team Information
JSON Object



h
Home Team Information
JSON Object



tid
Team ID
Integer
1610612739


re
W-L Record
String
""16-5""


ta
Team Abbreviation
String
""CLE""


tn
Team Name
String
""Cavaliers""


tc
Team City
String
""Cleveland""


s
Team Score
String
""93""


gdtutc
Game Date UTC
String
""2016-06-20""


utctm
UTC Time
String
""00:00""



Examples for data collection can be found here.


",Python
182,"











justPlay - play more, plan less
 Frontend build guide 
 Backend Update Guide 
 Testing with PHPUnit 
 API 





README.md




justPlay - play more, plan less
justPlay is a web application that enables students to play more and plan less. We believe that there are often too many obstacles to simply play a game that requires multiple human beings to participate (Badminton, Basketball, Table Tennis, Tennis etc...). justPlay attempts to take the pain out of organizing and finding others to play with by providing an intelligent match making system that groups people together based on their availability and preferences.
We have a live Alpha Version at www.just-play.ca, feel free to create an account and play around (Let us know if there are any bugs by posting an issue and labeling it with bug)
 Frontend build guide 
 Make sure you have bower installed, go to public and type bower install
 Backend Update Guide 
 first time install -> php artisan migrate --package=cartalyst/sentry 
 Every time an update has been made in the backend, run these commands 

 Import Sentry Authentication Package: ""php artisan migrate --package=cartalyst/sentry"" 
 Install Laravel: ""composer install"" 
 Install Laravel: ""composer update"" 
 Migrate your database: ""php artisan migrate"" 
 Seed your database: ""php artisan db:seed"" 
 Autoload All files: ""composer dump-autoload -o"" 

 Testing with PHPUnit 

 Windows Aliasing: @DOSKEY phpunit=vendor\bin\phpunit 
 Linux Aliasing: alias phpunit=vendor\bin\phpunit 
 phpunit 

 API 

 php artisan serve 
 localhost:8000/api-docs 



",JavaScript
183,"














wehoop 
Installation
Quick Start
WNBA full play-by-play seasons (2002-2021) ~ 1-2 minutes
Women’s college basketball full play-by-play seasons (2004-2021) ~ 2-3 minutes
Documentation
Breaking Changes
Follow the SportsDataverse on Twitter and star this repo
Our Authors
Citations





README.md




wehoop 








wehoop is an R package for working with women’s college and
professional basketball data. The package has functions to access live
play by play and box score data from ESPN with shot locations when
available.
A scraping and aggregating interface for ESPN’s women’s college
basketball and WNBA statistics. It provides users with the capability to
access the API’s game play-by-plays, box scores, standings and results
to analyze the data for themselves.
Installation
You can install the CRAN version of
wehoop with:
install.packages(""wehoop"")
You can install the released version of
wehoop from
GitHub with:
# You can install using the pacman package using the following code:
if (!requireNamespace('pacman', quietly = TRUE)){
  install.packages('pacman')
}
pacman::p_load_current_gh(""sportsdataverse/wehoop"", dependencies = TRUE, update = TRUE)
Quick Start
WNBA full play-by-play seasons (2002-2021) ~ 1-2 minutes
tictoc::tic()
progressr::with_progress({
  wnba_pbp <- wehoop::load_wnba_pbp()
})
tictoc::toc()
## 0.42 sec elapsed

## 13846 rows of WNBA play-by-play data from 35 games.

Women’s college basketball full play-by-play seasons (2004-2021) ~ 2-3 minutes
tictoc::tic()
progressr::with_progress({
  wbb_pbp <- wehoop::load_wbb_pbp()
})
tictoc::toc()
## 13.67 sec elapsed

## 1760447 rows of women's college basketball play-by-play data from 5347 games.

Documentation
For more information on the package and function reference, please see
the wehoop documentation
website.
Breaking Changes
Full News on
Releases
Follow the SportsDataverse on Twitter and star this repo


Our Authors


Saiem Gilani




Geoff Hutchinson




Citations
To cite the wehoop R package
in publications, use:
BibTex Citation
@misc{hutchinson_gilani_2021_wehoop,
  author = {Saiem Gilani and Geoff Hutchinson},
  title = {wehoop: The SportsDataverse's R Package for Women's Basketball Data.},
  url = {https://wehoop.sportsdataverse.org},
  year = {2021}
}


",R
184,"



README.md




adjusted_plusminus
Data and R code to calculate the adjusted plus minus in basketball
The data are obtained from http://basketballvalue.com/downloads.php
The matchups file includes information about line-ups while the players file includes information about the players
The code provided assumes the structure of these files, however it can be easily adjusted if the structure is different.


",R
185,"














nba_scrape
Installation:
Usage:
Example:
Get an instance of the NBA class:
Get a player:
Get a single stat:
Get multiple stats (formatted as a dict with tuples as items):
Current functionality:





README.md




nba_scrape
An easy-to-use Python utility to scrape professional basketball data off stats.nba.com using Selenium and BeautifulSoup.
Installation:
pip install nba_scrape
Usage:
from nba_scrape import NBA
Example:
>>> league = NBA()
>>> lebron = league.get_player('lebron james')
>>> lebron.get_stat('pts', '2016-17', playoffs=True)
>>> 32.8
>>> lebron.get_stats(['pts', 'reb', 'ast', 'ts%'], '2015-18', mode='playoffs')
>>> {'2015-16': (26.3, 9.5, 7.6, 0.585), '2016-17': (32.8, 9.1, 7.8, 0.649), '2017-18': (34, 9.1, 9, 0.619)}
Get an instance of the NBA class:
league = NBA()
Get a player:
player = league.get_player(player_name)
OR
player = league.get_player_by_id(id_number)
Get a single stat:
player.get_stat(stat_name, season)
Get multiple stats (formatted as a dict with tuples as items):
player.get_stats([stat1, stat2, stat3], season_range, mode=mode)
(Possible modes are 'season', 'playoffs', or 'both'; 'season' is the default.)
Current functionality:


Compile a list of all NBA players and their IDs when initializing the NBA class.


Easily load all regular season and playoff stats off a player's career page to a SQLite database. Only the player's name is required as input.


Retrieve all traditional stats and select advanced ones (such as True Shooting Percentage) via database queries; only the requested stats and seasons are required as input.


Browser-agnostic; uses the best available browser or raises an error if no supported browser is available.


Test suite to ensure correct statistics are returned.




",Python
186,"











The DeepSportRadar Player Re-Identification Challenge
** The DeepSportRadar Challenges will come back next year (2023) with some improvements, stay tuned on our Discord channel! **
Installation
Example
Data
Submission on EvalAI
Questions and remarks





README.md







The DeepSportRadar Player Re-Identification Challenge
** The DeepSportRadar Challenges will come back next year (2023) with some improvements, stay tuned on our Discord channel! **
Welcome to the DeepSportRadar Player Re-Identification Challenge, which is one of the ACM MMSports 2022 Workshop challenges.
An opportunity to publish, as well as a $1000 prize by competing on EvalAI.
See this page for more details.
In this challenge, participants will have to re-identify basketball players across multiple video frames captured from the same camera viewpoint at various time instants.
For that purpose, we provide our Synergy Re-Identification dataset with image crops of players, referees and coaches.
The dataset is split into a training, test and challenge set.
Test and challenge sets are both split into queries and galleries, similar to traditional ReID datasets.
The testing-set should be used to evaluate your model, both on the public EvalAI leaderboard that provides the temporary ranking, and when communicating about your method.
The challenge-set will be used for the official challenge ranking.
If you use any DeepSportradar dataset in your research or wish to refer to the baseline results and discussion published in our paper, please use the following BibTeX entry:
@inproceedings{
Van_Zandycke_2022,
author = {Gabriel Van Zandycke and Vladimir Somers and Maxime Istasse and Carlo Del Don and Davide Zambrano},
title = {{DeepSportradar}-v1: Computer Vision Dataset for Sports Understanding with High Quality Annotations},
booktitle = {Proceedings of the 5th International {ACM} Workshop on Multimedia Content Analysis in Sports},
publisher = {{ACM}},
year = 2022,
month = {oct},
doi = {10.1145/3552437.3555699},
url = {https://doi.org/10.1145%2F3552437.3555699}
}

Maintainer: Vladimir Somers (v.somers@sportradar.com) from Synergy Sports, a division of Sportradar.
Author of this repository: Davide Zambrano from Synergy Sports (d.zambrano@sportradar.com).
NOTE this code is based on Open-reid repo: https://github.com/Cysu/open-reid.git""
Open-ReID is a lightweight library of person re-identification for research
purpose. It aims to provide a uniform interface for different datasets, a full
set of models and evaluation metrics, as well as examples to reproduce (near)
state-of-the-art results.
We want to thank the authors for providing this tool. This version applies some changes to the original code to specifically adapt it to the DeepSportradar Challenge on Person Re-Identification.
This challenge is a fork of the player re-identification challenge proposed in the 2nd VIPriors workshop challenges
 

Installation
Note that the file setup.py specifies the libraries version to use to run the code.
Install PyTorch.
git clone https://github.com/DeepSportRadar/player-reidentification-challenge.git
cd player-reidentification-challenge
pip install -e .
Example
Run the following command to train a baseline model:
python baseline/synergyreid_baseline.py -b 64 -j 2 -a resnet50 --logs-dir logs/synergy-reid/
Data
Person re-identification data are provided by Synergy Sports.
Data come from short sequences of basketball games, each sequence is composed by 20 frames.
For the test and challenge sets, the query images are persons taken at the first frame, while the gallery images are identities taken from the 2nd to the last frame.
The idea behind the baseline is to provide a quick introduction to how to handle the re-id data.
Specifically, attention should be put on the dataset creation and the dataloaders.
The data files are provided under baseline/data/synergyreid/raw/synergyreid_data.zip.
The baseline code extracts the raw files in the same directory and prepares the splits to use for training, test and challenge.
Specifically the dataset is divided as:
SynergyReID dataset loaded
  subset      | # ids | # images
  ---------------------------
  train       |   436 |     8569
  query test   |    50 |       50
  gallery test |    50 |      910
  traintest    |   486 |     9529
  ---------------------------
  query challenge  |   468 |      468
  gallery challenge |  8703 |     8703
Train and test identities can be merged (to improve performance) using the flag --combine-traintest.
The image filename is divided in three numbers: the first one is the person-id; the second one is the sequence where the image was taken; and the third one is the frame number.
The test-set is divided in query and gallery to match the challenge-set format. With the flag --evaluate the distance matrix for the test set is also saved.
The identities of the gallery are NOT provided; gallery ids are just random.
Submission on EvalAI
Submit your result through the challenge page on the EvalAI platform.
You need to submit a .csv file as the pairwise distance matrix of size (m+1) x (n+1), where m is the number of query images and n is the number of gallery images.
The first row and the first column are the query and gallery ids respectively.
Query ids have to be ordered.
Please check the example provided in the baseline baseline/synergyreid_baseline.py with the 'write_mat_csv' function.
Please refer to the challenge webpage for complete rules, timelines and awards: https://deepsportradar.github.io/challenge.html.
Questions and remarks
If you have any question or remark regarding the challenge and related materials, please raise a GitHub issue in this repository, or contact us directly on Discord.


",Python
187,"











[正经向]如何使用STM32播放篮球视频
第一步
第二步
第三步
第四步





README.md




[正经向]如何使用STM32播放篮球视频
第一步
第一步当然是要先配置环境啦，opencv、KEIL都不会配怎么和大家一起打篮球

当然还要买硬件：一个Stm32F4（内存、flash没什么大的要求）、Stm32下载器、一块3.2英寸LCD屏幕(ILI9341)、一个micro sd(TF)卡。
淘宝买到的Stm32F4开发板都是把一些常用接口和外设都设计好的，一般比较萌新友好(坑钱)的会配套显示屏一起卖，直接插上去就可以用的那种，SD卡槽一般也会有的。
把显示屏的线接好(使用fsmc控制器)，大家如果没买那种配套设计的显示屏的话，接线就可能会像作者这么awesome了

第二步
首先我们要知道一张图片是像素点阵组成的，经过各种的编码压缩方式就变成了常说的jpg,png,gif。视频是由一帧帧图片组成的，也是有特定的编码压缩方式。想要解码视频运算量还是挺大的，通常使用硬件解码（硬解），在STM32里面挺难完成。所以我们要把视频中每一帧的图片拿出来，再用比较简单的编码方式写进文件，然后在STM32中读取。
首先我们打开一个篮球视频
VideoCapture cap(""CXK.mp4"");
我们做一个循环，每隔0.1秒读取一张图片
Mat frame;
int index=0;
while (cap.read(frame)){
    imshow(""cxk"",frame);
    index++;
    cap.set(CAP_PROP_POS_MSEC ,100 * index);
    waitKey(100);
}
这里cap.set(CAP_PROP_POS_MSEC ,100 * index);把视频的时间位置指向100 * index ms处
什么，原视频的16:9，显示屏是4:3，比例不对？那我们进行一下裁剪
void resize(Mat&img){
	resize(img,img,Size(426,240));
	img=img(Rect(53,0,320,240));
}
还有一点就是某宝买到的LCD屏幕都是16位rgb的，我们屏幕上面显示的真彩色是24位的，所以还要进行转换。
cvtColor(frame,frame_16bits,COLOR_BGR2BGR565);
然后再按照行->列的读取顺序把每一帧的图片信息写进文件，再把文件放进SD卡
第三步
什么，没有声音？没有鸡你太美的篮球视频是没有灵魂的——鲁迅。

其实音频文件里面的数据，是一连串的模拟值，经过压缩编码后变成了mp3什么的。我们用最简单的编码方式(PCM)的文件，将数据读出来，将图片和音频整合在文件中，就能同步播放视频和图片啦！！！
首先一个wav文件的文件头是这样的。
__attribute__((packed)) struct WavHead{
	int8_t RIFF[4];
	int32_t filesize;
	int8_t WAVE[4];
	int8_t FMT[4];

	int32_t size1;
	int16_t fmttag;//1
	int16_t channel;//1
	int32_t samplespersec;//每秒采样数
	int32_t bytepersec;
	int16_t blockalign;
	int16_t bitpersamples;
	int8_t DATA[4];
	int32_t datasize;
};
什么看不懂？别管那么多，我们要的是datasize和samplespersec（这里的音频文件为了方便处理，通过软件转成了16位深，16000hz采样率（即256kbps)，单声道）。datasize即后面的数据的总字节数量，samplespersec即采样率。
然后只需要在每一帧的循环里面，写入音频的数据：每0.1s采样1600个16位值，即3200字节。写入图像数据：320 * 240 * 2个字节。
这样我们就完成了视频文件的预处理啦！！！

第四步
终于来到最重要的一步了，什么不会Stm32？会抄就行了。

首先我们先拿到一份卖家提供的非常完善的示例代码，里面以及包含了各种基本功能的实现，我们需要的是LCD屏幕、SD卡读写部分的示例代码。
什么卖家没给你示例代码？在这里我教大家一个找硬件文档的万能方法：淘宝。将你手上的电子器件型号输入淘宝，随意点进一个卖家，在商品介绍一般都有很显眼的某度网盘的链接，懂了吧？
我们将lcd屏幕初始化，usart初始化，sd卡初始化等一系列看不懂的初始化放在一起。然后我们需要知道的有这么几个。
1、SD卡文件读取，卖家给的实例代码一般会封装好的，sd卡初始化之后的操作就和我们在windows下写的控制台(就是那个黑窗)的文件读写操作时一样的。
2、在lcd屏幕显示图片，这个商家也封装好的，调用个函数，传进去显示图片的位置，还有储存图片像素的数组就能显示图片。
3、定时器、时钟、dac，这是用来同步播放音乐的，我们把音频数据从文件读入之后，通过中断把音频文件通过dac播放。因为单片机是没有负电压得，所以使用2个dac输出，产生电压差。
那么显示一帧图片的时序是这样的：
开启一个计时器计数->从文件读入3200byte(16000hz / 10 * 2)的音频数据->定时器中断函数发现音频数据长度大于0，之后的中断开始循环输出音频数据，输出完将音频数据长度置0->从文件读完音频数据后同时读图片数据，显示在显示屏中->通过计时器判断这一帧图片的显示时间是否满100ms，然后开始下一帧的显示。
代码量挺多的就不贴上来了，文章最后会放出全部代码的github链接，反正，我们只是代码的搬运工。
搞完上面的代码后我们就能很清晰地播放篮球视频，但是发现声音不对劲，太小了。dac的驱动是3.3v，学过简单的电路就知道，下面是一个肥肠简单的信号放大电路。

如果想要输入电压3.3v，输出电压5v，那么1.7R1=3.3R2
那么随缘R1=2kΩ R2=1kΩ吧
使用运放的话输出电流还是挺小的，作者手上暂时只有一个蜂鸣器，全损音质，几乎听不出那句熟悉的鸡你太美，不过这个思路应该是对的，这个电流应该是可以驱动一个耳机（应该还要加个滤波电容，这得结合耳机阻抗）。如果想要实现广场舞那种震撼感，自行实现放大电路吧。
最后，献上视频（声音是另外录后期加上去的）：


视频链接


",C
188,"











NBA Match Predictor ©
A better implementation in Python with added features and a working API is now available on : Nba-Match-Predictor. The new version is still a project-in-progress
Procedure Description
Next update





README.md




NBA Match Predictor ©
A better implementation in Python with added features and a working API is now available on : Nba-Match-Predictor. The new version is still a project-in-progress
Version: 2
Author: Khai H Lai
Last Updated: 9/3/2019
Changelog:

Added hashCode() and equals() to class Team.
Added webscraping functionality using JSoup library

Language: Java

This simple program uses Monte Carlo simulation to:

predict the result of an NBA match.
output each team's probability of winning the matchup.

Has basic UI that allows users to type in the names of the teams they wish to simulate the match-up with.

Procedure Description
The simulator uses library Jsoup to scrape data from Basketball Reference NBA 2019 Ranking and Team Rankings. It then uses Monte-Carlo simulation (with added random statistical variations applied on the procedure described on Basketball Distribution) to give the probability of each team winning the match-up.
Next update

Make this program into a webapp that can be easily used and accessed by the public.
Make this program into a browser extension that automatically fetch from that day's NBA schedule and output predictions.
Goal for completion: December 20, 2019



",Java
189,"



README.md




bbgm
rosters for basketball gm


",Python
190,"



README.md




Linear-Regression-Model-Basketball
Statistical model on NBA basketball players' performance using multiple linear regression and stepwise search.


",R
